\input texinfo-altfont
\input texinfo-logo
\input texinfo
@selectaltfont{cmbright}
@setlogo{CFEngineFrontPage}
@c *********************************************************************
@c
@c  This is a TEXINFO file. It generates both TEX documentation and
@c  the "on line" documentation "info" files.
@c
@c  The file is structured like a programming language. Each chapter
@c  starts with a chapter comment.
@c
@c  Menus list the subsections so that an online info-reader can parse
@c  the file hierarchically.
@c
@c ***********************************************************************@c 
@c %** start of header
@setfilename Enterprise-3-0-OwnersManual.info
@settitle CFEngine 3 Enterprise 3.0 beta Owner's Manual
@setchapternewpage odd
@c %** end of header
@titlepage
@title CFEngine 3 Enterprise 3.0 beta Owner's Manual
@subtitle CFEngine Enterprise Documentation
@subtitle Updated 23. October 2012 @c also update in ifnottex section below
@author CFEngine
@c @smallbook
@fonttextsize 10
@page
@cartouche
Please note that this is a beta release of CFEngine 3 Enterprise, do not use in production environments. Some features may change slightly and this document will be subject to change for the final product release.
@end cartouche
@vskip 0pt plus 1filll
Copyright @copyright{} 2012 CFEngine AS.
The features described herein are in provided for user convenience and imply no warranty whatsoever
to the extent of applicable law.
@end titlepage
@c *************************** File begins here ************************
@ifinfo
@dircategory CFEngine Training
@direntry
* CFEngine Reference:
                        CFEngine is a language based framework
                        designed for configuring and maintaining
                        Unix-like operating systems attached
                        to a TCP/IP network.
@end direntry
@end ifinfo
@ifnottex
Updated 23. October 2012
@node Top, Introduction, (dir), (dir)
@top CFEngine 3 Enterprise 3.0 beta Owner's Manual
@end ifnottex
@ifhtml
@html
<a href="#Contents"><h1>COMPLETE TABLE OF CONTENTS</h1></a>
<h2>Summary of contents</h2>
@end html
@end ifhtml

@iftex
@contents
@end iftex



@menu
* Introduction::                
* Requirements::                
* Installing CFEngine 3 Enterprise::  
* Quickstart - The Mission Portal::
* Quickstart - CFEngine Policies::
* Role Based Access Control (RBAC)::
* Virtualization and Cloud::              
@c * Mission Portal::              
* Windows-specific features in CFEngine 3 Enterprise::
* REST API:: 
* Monitoring extensions::       
* File Access Control Lists::   
* Server extensions::           
@c * Environments and workflows::  
* Content-Driven Policies::     
* Upgrading CFEngine 3 Enterprise::     
* Frequently Asked Questions::
* Troubleshooting::
* Configuration of external authentication::  
* SQLite Database Schema::
@end menu

@c *****************************************************
@c * CHAPTER
@c *****************************************************
@node  Introduction, Requirements, Top, Top
@chapter Introduction

Welcome to CFEngine 3 Enterprise 3.0, the next generation of enterprise configuration management software! This document will take you through the necessary steps to get CFEngine 3 Enterprise 3.0 up and running whether you are a beginner or an experienced CFEngine user. The following links will take you to communly used sections, see above for a complete table of contents:

@itemize -
@item @ref{Requirements}
@item @ref{Installing CFEngine 3 Enterprise}
@item @ref{Quickstart - The Mission Portal}
@item @ref{Quickstart - CFEngine Policies}
@item @ref{Role Based Access Control (RBAC)}
@item @ref{Virtualization and Cloud}
@c Compliance
@item @ref{REST API}
@item @ref{Upgrading CFEngine 3 Enterprise}
@end itemize

We have made big changes to the Mission Portal to accomodate the needs of infrastructure engineers and IT managers alike. The front page consists of a list of applications, or apps, that give insight into different aspects of your infrastructure. Focus on a more intuitive UI with enhanced help functions has made the Mission Portal both easier and more powerful to use.

CFEngine 3 Free Enterprise is our commercial enterprise product offered for free for up to 25 managed hosts. It differs from our commercial offer in that it has different licensing terms, different support and it is limited to a maximum of 25 hosts. The product is described in full detail at @url{http://cfengine.com/25free}. Please note that CFEngine 3 Enterprise should not be installed as an upgrade to CFEngine Community. I that case uninstall CEngine Community, do a clean install of CFEngine 3 Enterprise and then move your existing policies to the new Enterprise hub. See the @url{http://cfengine.com/enterprise/faq, Enterprise FAQ} for more information.

@menu
* About CFEngine 3 Enterprise::
@end menu


@c --------------------------------------------------
@node About CFEngine 3 Enterprise, , Introduction, Introduction
@section About CFEngine 3 Enterprise

CFEngine 3 Enterprise is a commercially licensed version of the core CFEngine
software@footnote{Major version 3} with enterprise library extensions. All of
the documentation for CFEngine 3 applies to CFEngine 3 Enterprise. 

The aim of CFEngine 3 Enterprise is to offer a knowledge-enhanced framework for configuration man-
agement that goes beyond mere technical configuration to support the needs of businesses. Features
include compliance management, reporting and business integration, and tools for handling necessary
complexity. CFEngine 3 Enterprise has features to support Cloud Computing for public and private clouds, as
well as greater integration facilities with database resources.


@c *****************************************************
@c * CHAPTER
@c *****************************************************
@node Requirements, Installing CFEngine 3 Enterprise, Introduction, Top
@chapter Requirements

@menu
* Hardware requirements::       
* Operating system support::    
@end menu

@node Hardware requirements, Operating system support, Requirements, Requirements
@section Hardware requirements

The default CFEngine 3 Enterprise architecture uses a single hub, or policy server, to publish changes of policy
and to aggregate knowledge about the environment, but you can set up as many as you like to manage
different parts of your organization independently. The CFEngine technology is not centralized by
nature. Most users choose to centralize updating of policy and report aggregation for convenience
however.

The default architecture and configuration skeleton of CFEngine 3 Enterprise is expected to scale to a few thousand hosts with a
dedicated policy hub. In such a case, your hub machine should have at least 2 GB of memory and a modern processor.
For machines under CFEngine's management (clients), a full installation of CFEngine 3 Enterprise requires about 20 MB of disk storage. Otherwise disk usage depends on your specific policies, especially those that concern reporting. Each software component (agent) typically uses under 10 MB of memory, but spikes in memory usage can occur if several agents run simultaneously. CFEngine recommends to have 256 MB available memory on the clients.


@c --------------------------------------------------
@node  Operating system support,  , Hardware requirements, Requirements
@section Operating system support

CFEngine can be made to run on most operating systems. For efficiency
CFEngine only supports packages for a number of recent popular operating systems,
which should be up to date with patches. If we don't have packages for
your particular operating systems we can usually make packages by
special arrangement please contact your sales representative.

CFEngine 3 Free Enterprise is only available for Linux Operating Systems (both hub and client). Commercial CFEngine 3 Enterprise customers have access to all the following Operating Systems.

The hub (policy server) is only available for derivatives of the
top GNU/Linux distributions (Debian, Red Hat, SuSE, Ubuntu), as these make available
software that the hub relies on for data storage and processing.
Operating system choices for the hub are:

@example
 Debian 6
 Ubuntu 8.04, 10.04, 12.04
 RHEL/CentOS 5, 6
@end example

@noindent Operating system choices for the clients are:
@example
AIX 5.3, 6.1, CentOS 5, 6, Debian 5, 6, Fedora 14, 15, 16, FreeBSD 7, 8, 
HP-UX, NetBSD 4.0, 5.0, 5.1, openSUSE 10.2, 10.3, 11.1, 11.2, 11.3,
11.4, RHEL 4, 5, 6, SLES 9, 10, 11, SUSE Linux 9.1, 9.2, 9.3, 10.0, 10.1, 
Solaris 8, 9, 10, Ubuntu 8.04, 8.10, 9.04, 9.10, 10.04, 10.10, 
11.04, 11.10, 12.04, Windows XP, Vista, 7, Server 2003, Server 2008
@end example

@noindent See @file{Release Notes CFEngine 3 Enterprise.txt} for details on supported architectures.

CFEngine 3 Enterprise provides a version of CFEngine running natively on Windows, with support for registry management, Windows services and file security, @xref{Windows-specific features in CFEngine 3 Enterprise}. Support for Solaris zones has been added through automated zone detection and process model adaptation.

A working package manager is required on the hub/policy server to install an Apache Web Server, php module, MongoDB, subversion, etc. You should start from a blank system (i.e. with none of these components installed) to avoid potential interference with the installation process. No special software is otherwise required on machines in your network, CFEngine bundles all critical dependencies in the CFEngine 3 Enterprise package. 


@c *****************************************************
@c * CHAPTER
@c *****************************************************
@node Installing CFEngine 3 Enterprise, Quickstart - The Mission Portal, Requirements, Top
@chapter Installing CFEngine 3 Enterprise

@menu
* Installation procedure::               
* How to assess success of this procedure::
@end menu

@node Installation procedure
@section Installation procedure

CFEngine 3 Enterprise is designed to be simple to install in its default configuration. The installation
process has two phases (or three phases for commercial customers who need to obtain a license):

@itemize
@item Unpack the software
@item For commercial customers (skip for CFEngine 3 Free Enterprise): Obtain a license 
@item Bootstrap the agents to a hub (the hub serves as a policy server and report collector)
@end itemize

The following procedure counts for a fresh install, please see @ref{Upgrading CFEngine 3 Enterprise} for how to upgrade from earlier versions of CFEngine. 

You should start from a blank system (see also @ref{Hardware requirements}). If you have been using CFEngine Community Edition and you have
already developed a policy, set aside this policy during the installation process. You will be able
to integrate it back later.

CFEngine 3 Enterprise is provided in two packages, @file{cfengine-nova_<VERSION NUMBER>} and @file{cfengine-nova-expansion_<VERSION NUMBER>}. The main software package 
must be installed on every host (including the hub). The expansion package is only installed on the policy hub. You should install and set up the hub first.

References to package managers assume that additional packages might need to be installed on the hub (policy server). Root privilege is required for the installation.

@enumerate
@item Verify that the machine's network connection is working and that port 5308 (used by CFEngine) and port 80 (used for the Mission Portal) is open for both incoming and outgoing connections. On the hub, verify that package managers @code{yum},
@code{zypper} or @code{apt-get} are working. They will be used to
install a web server, database, php server and subversion. If you are not able to set up a package manager and
repository on the hub, please see @ref{How do I install the prerequisites for the hub manually?}

@item Copy the CFEngine 3 Enterprise packages to the system. On the hub (policy server):
@example
cfengine-nova_3.0.@var{xxx.[rpm|deb]}
cfengine-nova-expansion_3.0.@var{xxx.[rpm|deb]}
@end example
@noindent On all other machines:
@example
cfengine-nova_3.0.@var{xxx.[rpm|deb]}
@end example

@item Unpack the software:
@table @i
@item Red Hat family
@example
host# rpm -ihv @var{packages}
@end example

@item SUSE family
@example
host# rpm -ihv @var{packages}
@end example

@item Debian family
@example
host# dpkg --install  @var{packages}
@end example

@end table 

@item Skip this step for installation of CFEngine 3 Free Enterprise. On the hub, a public key has now been created in @file{/var/cfengine/ppkeys/localhost.pub} as part of the
package installation. Commercial customers should send this public key to CFEngine Support@footnote{You will obtain credentials to the CFEngine Support ticketing system and software download repository as a part of your purchase.} as an attachment in the ticket system, 
to obtain a license file @file{license.dat}. 

@cartouche
Save the returned license file to @file{/var/cfengine/masterfiles/license.dat} 
on the hub before continuing.
@end cartouche

@ignore
See more details for the software licensing here; 
@url{https://cfengine.com/software/Licensing.pdf}
@end ignore

@item The remaining steps apply to all hosts, but you should @b{install the hub (policy server) first}. For large systems (> 1000 hosts) we recommend increasing the memory limit in php.ini on the hub (for instance to 128 MB).

Find the hostname or IP address of the hub (policy server), here we assume @samp{123.456.789.123} is the address.
@verbatim
 hub # /var/cfengine/bin/cf-agent --bootstrap --policy-server 123.456.789.123
@end verbatim
Use the same command on all hosts, i.e. @b{do not bootstrap the policy server with a localhost address}.
If you mistype the address of the hub, we recommend doing the following steps to re-boostrap.
@verbatim
 hub # /var/cfengine/bin/cf-agent --bootstrap --policy-server 123.456.789.124
 hub # killall cf-execd cf-serverd cf-monitord cf-hub
 hub # rm -rf /var/cfengine/inputs/*
 hub # rm -f /var/cfengine/policy_server.dat
 hub # /var/cfengine/bin/cf-agent --bootstrap --policy-server 123.456.789.123
@end verbatim

CFEngine will output diagnostic information upon bootstrap (written to command line and syslog; cf-agent will also return a value: ERROR: 1, SUCCESS: 0). Error messages will be displayed if bootstrapping failed, pursue these to get an indication of what went wrong and correct accordingly. If all is well you should see the following in the output:

@verbatim

-> Bootstrap to 123.456.789.123 completed successfully

@end verbatim

@cartouche
Commercial customers: Did you bootstrap before obtaining a license? See @ref{I did bootstrap the hub before obtaining a license file - what should I do?}
@end cartouche

@item CFEngine should now be up and running on your system. The Mission Portal will not be immediately accessible, you should wait 10-15 minutes for the system to converge before attempting to connect to the hub IP-address through your web browser (the convergence process can take up to 30 minutes). CFEngine will copy its default policy files into @file{/var/cfengine/masterfiles/} on the hub (policy server) provided that the directory is empty (fresh install). When the clients are bootstrapped, they will contact the hub and copy them to their @file{/var/cfengine/inputs/} directory.

@item Skip this step for installation of CFEngine 3 Free Enterprise. To complete licensing setup, you should make a promise to accept the license
terms by editing @file{/var/cfengine/masterfiles/promises.cf} and @file{/var/cfengine/masterfiles/failsafe/failsafe.cf}
on the hub (policy server), changing the line @samp{host_licenses_paid => "<NUMBER>";}
in @samp{body common control} to reflect the correct number of licenses that you have subscribed to.

@end enumerate


@c --------------------------------------------------
@node How to assess success of this procedure
@section How to assess success of this procedure

@enumerate
@item Look at the process list on the systems with @samp{ps waux | grep cf-}.
You should be able to see @code{cf-execd} running, and eventually other processes from 
the CFEngine suite like @code{cf-monitord} @code{cf-serverd}. On the hub, you should 
also eventually see @code{cf-hub}. Note that it may take 5--10 minutes before all the
processes get started.

@item Look for files in @file{/var/cfengine/inputs} (Unix)
or @file{C:\Program Files\Cfengine\inputs} (Windows). If you are a commercial customer (not 25 free edition) the license file will be copied out from the policy server to the clients as part
of the normal distribution of policy. Each machine should get a
copy of the @file{license.dat} file in @file{/var/cfengine/inputs}
(Unix) or @file{C:\Program Files\Cfengine\inputs} (Windows).

@item On the hub, the file @file{/var/cfengine/promise_knowledge.cf} should have been
created, and should contain data.

@item  Finally, after 10--15 minutes@footnote{You may have to wait as long as 30 minutes}, try to connect to the hub (policy server) with your web browser (from the installation example: http://123.456.789.123, replace with your real IP address). You should see a login page like the one shown in the figure below:

@sp 1
@center @image{img-login-3-0,7cm,,Mission Portal login}
@center Figure: Mission Portal login screen
@sp 1
@end enumerate

Please see @ref{Frequently Asked Questions} or @ref{Troubleshooting} if you have any problems.


@c *****************************************************
@c * CHAPTER
@c *****************************************************
@node Quickstart - The Mission Portal, Quickstart - CFEngine Policies, Installing CFEngine 3 Enterprise, Top
@chapter Quickstart - The Mission Portal

@menu
* Hosts App::
* SQL Reports App::
* Docs App::
* Services App::
* Policies App::
* Knowledge App::
* Goals App::
* Compliance App::
* User Management::
* Mission Portal Settings::
@end menu

The Mission Portal is the centerpiece
of user interaction with CFEngine 3 Enterprise. It can be accessed by connecting to the hub (policy server) with your web browser (from the installation example: http://123.456.789.123, replace with your real IP address). You should see a login page, the default user name and password is @i{admin} and @i{admin}. @footnote{Make sure to change the password to prevent unauthorized access; see also Appendix A on configuration of external authentication.} Once you have logged in you will see the Mission Portal home page:

@image{img-mission-portal-3-0,15cm,,Mission Portal}
@center Figure: The Mission Portal

@noindent By default there are eight applications, or apps, on the home page. Each app offers insight into different aspects of operations:

@itemize -
@item Hosts - A place to see the current state of system repair @c (@ref{Hosts App})
@item SQL Reports - Create reports based on a simple customizable SQL interface @c (@ref{SQL Reports App})
@item Docs - Access to both offline and online CFEngine documentation @c (@ref{Docs App})
@item Services - Browse current host capacity providing services in your environment
@item Policies - Show the promises that the system is currently trying to keep
@item Knowledge - A knowledge bank that connects information together
@item Goals - Connect promises to high level organizational goals and key performance indicators
@item Compliance - Overview of the current state and history of compliance across your system, through the lens of different compliance standards
@end itemize

The apps labeled beta are under development and may not have a complete functionality set. We still choose to include them in the product to show the potential of CFEngine 3 Enterprise and get feedback from our customers. The apps that are shown is configurable through the @ref{Mission Portal Settings}, the admin user can choose to not display the apps that are not relevant for everyday use.

If you go directly to explore the different apps, please note that some of the displays in the Mission Portal may be blank when you log in just after installation. It may also take some time for the system to fully converge, do not get troubled if initially there are some promises repaired or not kept (yellow and red colors).


@c --------------------------------------------------
@c @node  Mission Portal Apps, Finders, Mission Portal, Mission Portal
@c @section Mission Portal Apps


@c -----------------------------------------------------
@node Hosts App, SQL Reports App, Quickstart - The Mission Portal, Quickstart - The Mission Portal
@section Hosts App

@menu
* Top Menu::
* Navigation Tree::
* Status tab::
* Reports tab::
* Events tab::
* Vitals tab::
* Host Info tab::
@end menu

The Hosts App illustrates the state of the system in relation to the desired state at different scales. Zoom in to specific areas and examine the impact of promises, query data, extract reports and examine compliance relative to the policy/promises you have made. Speak authoritatively on resources and avoid the cost of maintaining disconnected monitoring/reporting.

@sp 1
@image{img-hosts-app-3-0,15cm,,Hosts App}
@center Figure: Hosts App
@sp 1

@noindent The app has three main areas of user interaction:

@itemize
@item Top menu:
@itemize -
@item App Selector: Shortcut to other available apps (no need to pass through the Mission Portal home page)
@item Policy Context Selector: Choose between three different policy contexts to see the state of All, User or System (internal CFEngine) promises
@end itemize
@item Navigation Tree: Hosts can be grouped and organized in a hierarchy defined by classes
@item Content Area: Context sensitive area (effected by the selection made in the @i{Policy Context Selector} and @i{Navigation Tree}). The header/title shows the selected context from the navigation tree and underneath you will find five different content tabs:
@itemize -
@item Status: Overview of host compliance and operational status
@item Reports: Access to default reports
@item Events: Track events based on (patterns in) promise handles
@item Vitals: Monitor host parameters
@item Hosts info: Detailed information about each host (inventory)
@end itemize
@end itemize

@noindent In general we use colors to show the status of host compliance and operational status:
@itemize -
@item Red if more than 20% of promises were not kept
@item Yellow if 20% or more of promises were repaired and host is now compliant
@item Green if more than 80% of promises are kept
@item Blue if there has not been any contact between the hub and the client within a set time interval (host unreachable; default value is set to 15 minutes, see @ref{Mission Portal Settings}). 
@item Black if CFEngine's scheduling daemon, @code{cf-execd}, is not running (the hub will still able to contact the client to collect reports but the client will return stale data since it has not been running at regular intervals).
@end itemize


@c -----------------------------------------------------
@node Top Menu, Navigation Tree, Hosts App, Hosts App
@subsection Top Menu

The Top Menu consists of the @i{App Selector} (a shortcut to other apps available on the Mission Portal home page) and the @i{Policy Context Selector}. The selected policy context effects all content related to host and promise status in the @i{Hosts App}. There are three alternatives:

@sp 1
@image{img-top-menu-3-0,15cm,,Top Menu}
@center Figure: Top Menu
@sp 1

@itemize -
@item All: Navigation Tree, graphs and reports will contain data from all promises in you policy.
@item User: Navigation Tree, graphs and reports will contain data from promises that users have added.
@item System: Navigation Tree, graphs and reports will contain data from CFEngine system promises (labelled with a promise handle prefix @i{cfe_interal_} in the default policies).
@end itemize


@c -----------------------------------------------------
@node Navigation Tree, Status tab, Top Menu, Hosts App
@subsection Navigation Tree

The Navigation Tree allows the user to group and organize hosts in a hierarchy defined by CFEngine classes (boolean classifiers that describe context). 

@sp 1
@center @image{img-navigation-tree-3-0,5cm,,Navigation Tree}
@center Figure: Navigation Tree
@sp 1

The tree consists of two main parts:

@itemize -
@item The Tree Selector: Choose between default trees or custom trees defined by the user. Each tree can have a different subset of nodes. Type a name in the @i{Add Tree} text field at the bottom of dropdown menu and press enter to add your own tree. Click @code{X} next to a tree name to delete it.
@item The tree itself, grouped by classes. The user can add up to four sublevels in the Navigation Tree and edit or delete existing nodes.

@sp 1
@center @image{img-navigation-tree-expanded-3-0,5cm,,Navigation Tree Expanded}
@center Figure: Navigation Tree Expanded
@sp 1

@itemize -
@item
 To add a node:
@enumerate
@item Put the mouse pointer over the node you wish to add a sublevel to, click the plus sign shown beside the node.
@item A pop-up appears with fields to enter a label (name) to the node that you wish to create and the class expression you wish to filter by. The class expression field contains a button which opens a class finder to help you select classes.
@end enumerate
@item To delete a node: Put the mouse pointer over the node that you wish to delete, click the @code{X} shown beside the node.
@item To edit a node: 
@enumerate
@item Put the mouse pointer over the node that you wish to edit, click the @code{Pencil icon} shown beside the node.
@item A pop-up appears where you can edit the fields that you wish to change.
@end enumerate
@end itemize
@end itemize

@noindent The trees and nodes that a user creates will not be visible to other users of the Mission Portal.

Click on any host in the tree to get a quick overview of that host in the @i{Status}, @i{Vitals} or @i{Hosts Info} tabs.


@c -----------------------------------------------------
@node Status tab, Reports tab, Navigation Tree, Hosts App
@subsection Status tab

The Status tab shows the overall status of the hosts selected in the @i{Navigation Tree} and selected policy context (@i{@{All@}}, @i{@{User@}} or @i{@{System@}}). 

@sp 1
@center @image{img-status-tab-3-0,12cm,,Status tab}
@center Figure: Status tab
@sp 1

This section contains: 

@itemize
@item @i{Graph}: The row of bars shows the compliance of all registered hosts in blocks of six hours for the last week or in blocks of five minutes for the last six hours@footnote{Blue or black hosts will not appear here}. The hosts are classified into red, yellow and green according to the status of their compliance. The height of a bar corresponds to the number of registered hosts. Note that the last column may have a lower height than the others in the six hour view (i.e. show information for fewer hosts)@footnote{This is because hosts check in at different times and some hosts may not yet be accounted for at the time of generation of the graph.}. Click on a bar to see which promises were repaired or not kept.
@item @i{Host Compliance} and @i{Host Operations}: The hosts are classified into red, yellow and green according to the status of their compliance over the last hour as well as blue and black according to their operational status (host unreachable and host with scheduling deviation, respectively).
@item Clicking a link in any of the above categories (red/yellow/green/blue/black) produces a list of the hosts in that category (in the above mentioned context).
@end itemize

@ignore
Example, Compliant hosts: Click the link next to the green box under @i{Host Compliance}, a report appears showing host names, time stamp of last data collected and three action icons:

@sp 1
@center @image{img-compliant-hosts-2-2,14cm,,Compliant hosts}
@center Figure: Compliant hosts
@sp 1

@noindent Action icons:
@itemize -
@item Yellow warning triangle: View the promises not kept on this host
@item Pulse line: View vitals signs (statistics) on this host
@item Red X: Delete this host (host will be deleted from database, but may re-appear if CFEngine is still running on it; see footnote below).@footnote{You have to stop CFEngine on the concerned host before deleting it in the Mission Portal, else the host will contact the hub and re-appear in the database.}
@end itemize
@end itemize
@end ignore


@c -----------------------------------------------------
@node Reports tab, Events tab, Status tab, Hosts App
@subsection Reports tab

Reports are sorted into five main categories that contain drop down menus to select default reports. Clicking a report will bring up a search filter specific to that report.

@sp 1
@center @image{img-reports-tab-3-0,8cm,,Reports tab}
@center Figure: Reports tab
@sp 1

Reports are updated at different intervals, the default values are every 5 minutes or every 6 hours. Below is a list of standard reports, updated every 5 minutes unless otherwise noted:

@itemize
@item Policy
@itemize -
    @item Compliance by bundle: Status of promise bundles and when they were last verified
    @item Compliance by promise: Compliance of each promise individually
    @item Promises not kept (log): Log of individual promises that were not kept
    @item Promises not kept (summary): Cumulative summary of promises not kept
    @item Promises repaired (log): Log of individual promises that were repaired (fixes to the system)
    @item Promises repaired (summary): Cumulative summary of promises repaired
@end itemize
@item Accounting
@itemize -
    @item Benchmarks: Execution time of selected promises (as defined in policy)
    @item Business value report: Accumulated value of promises kept (6 hrs)
    @item Compliance summary: Compliance of each agent run
@end itemize
@item System
@itemize -
    @item Context classes: User defined classes observed on the system
    @item Last saw neighbours: Log of when neighboring hosts were last observed online
    @item Variables: Table of variable values last observed (6 hrs)
    @item Weakest hosts: Ranking of hosts according to the compliance over the last hour
@end itemize
@item Software
@itemize -
    @item Installed: List of software packages claimed to be installed according to the local package manager
    @item Patches available: A list of patches currently claimed to be available by the local package manager
    @item Patch installed: A list of (un)applied patches according to the local package manager
@end itemize
@item File watch
@itemize -
    @item Change summary: Log of all detected changes to files from changes promises
    @item Setuid: Current list of observed setuid/setgid root programs (6 hrs)
    @item Text changes: Delta/difference comparison showing file changes
@end itemize
@end itemize


@c -----------------------------------------------------
@node Events tab, Vitals tab, Reports tab, Hosts App
@subsection Events tab

The @i{Events tab} allows you to create trackers to follow selected promises or classes in near real time. The trackers are in real time and shows data as it is written to the database. They represent an easy way to monitor specific promises or trace the impact of policy changes and roll outs at a more detailed level. A classes tracker will list the hosts that satisfy the selected class.

@sp 1
@center @image{img-events-tab-3-0,6cm,,Events tab}
@center Figure: Events tab
@sp 1


@c -----------------------------------------------------
@node Vitals tab, Host Info tab, Events tab, Hosts App
@subsection Vitals tab

CFEngine has integrated monitoring capability where several parameters are measured on each client. These are presented visually in the @i{Vitals tab}. All parameters are listed if a single host is selected, otherwise the hosts are ranked according to a selected parameter.

@sp 1
@center @image{img-vitals-tab-3-0,13cm,,Vitals tab}
@center Figure: Vitals tab
@sp 1


@c -----------------------------------------------------
@node Host Info tab, , Vitals tab, Hosts App
@subsection Host Info tab

The @i{Host Info tab} is an inventory listing of discovered properties about a host. Includes host identity, operating system, architecture, CPU, interfaces, etc.

@sp 1
@center @image{img-hosts-info-tab-3-0,13cm,,Hosts Info tab}
@center Figure: Hosts Info tab
@sp 1


@c -----------------------------------------------------
@node SQL Reports App, Docs App, Hosts App, Quickstart - The Mission Portal
@section SQL Reports App

@menu
@end menu

The @i{SQL Reports} app gives the user full flexibility to create reports based on a simple customizable SQL interface. The workflow consists in choosing what fields you want to see in the report and how to filter them. You also have the option to save queries for later use or schedule queries to email reports to stakeholders. Be ready for instantaneous audits and inspections at low cost by reducing the time and work to gather reports.

There are two main areas of interaction in this app:

@itemize -
@item Left menu: List of saved and scheduled searches
@item Content area: Choose parameters for the report, view the result and save or schedule a query.
@end itemize

@sp 1
@center @image{img-sql-reports-3-0,15cm,,SQL Reports}
@center Figure: SQL Reports
@sp 1

Items in the content area are used to create a query and generate a report according to the following description:
@itemize -
@item Fields - Define your table columns (mandatory field)
@item Filters - Filter the results of you query (use valid SQLite syntax)
@item Group - Group your results according to selected criteria
@item Sort - Sort your results according to a selected criteria
@item Limit - Limit the number of entries in your report
@item Show me the query - View and edit the SQL query directly
@end itemize

@cartouche
Please note that any queries containing the PromiseDefinitions table in combination with any other table in the schema will produce erroneous output without an intermediate join to the PromiseStatusLast table. See @ref{SQLite Database Schema}.
@end cartouche

Once the query is defined you can run it to see the result, optionally save it for later use or schedule it to be emailed at a chosen interval. The report will appear below the query form:

@sp 1
@center @image{img-sql-report-result-3-0,15cm,,SQL Report Result}
@center Figure: SQL Report Table
@sp 1


@c -----------------------------------------------------
@node Docs App, Services App, SQL Reports App, Quickstart - The Mission Portal
@section Docs App

The @i{Docs} app gives access to both offline and online CFEngine documentation. The documents are scanned and parsed to be included in the integrated semantic index (see @ref{Knowledge App}), look up on the fly or study in depth. Learn about CFEngine concepts, syntax and inherent possibilites in CFEngine.

The left side shows an overview of all bundled documents, divided into categories that expand once clicked. The selected document is displayed in the main content area to the right.

@sp 1
@center @image{img-docs-3-0,15cm,,Docs}
@center Figure: Docs
@sp 1


@c -----------------------------------------------------
@node Services App, Policies App, Docs App, Quickstart - The Mission Portal
@section Services App

@menu
@end menu

The @i{Services} app allows the user to browse current host capacity providing services in your environment. Get an overview of open ports, CPU usage, network connections, capacity of storage devices and other job services. View their utilization and trends. Relate measurable data to your technical and organizational service catalogues for capacity planning and supply-demand analysis.

@sp 1
@center @image{img-services-3-0,15cm,,Services}
@center Figure: Services
@sp 1

The landing page for the @i{Services} app shows an overview of common services and a graphic display of the number of hosts that support them. There are two main areas of interaction in this app:

@itemize
@item Left menu: Two menu tabs
@itemize -
@item Status - List of services on your system, clicking an item will give its status in the content area on the right
@item Catalogue - Listing of higher level Service Catalogue which expands to the associated services on your system when clicked
@end itemize
@item Content area: Two (three) content tabs
@itemize -
@item Level - Show the current level of activity (low, normal, high) relative to learned behavior at this time of the week.
@item Trend - Show the trend in activity over 6, 12, 18 or 24 hours
@item See Also - Links to the CFEngine knowledge index. Enhance your understanding of the selected service and how it relates to your infrastructure
@end itemize
@end itemize


@c -----------------------------------------------------
@node Policies App, Knowledge App, Services App, Quickstart - The Mission Portal
@section Policies App

@menu
@end menu

The @i{Policies} app shows the promises that the system is currently trying to keep, with links to CFEngine's smart indexing and documentation. Show statistics about the quality and success of the intended state. Stay close to the intended
state of your system, by knowing what, where, when, how and why your infrastructure is defined, deployed and configured.

@sp 1
@center @image{img-policies-3-0,15cm,,Policies}
@center Figure: Policies
@sp 1


@c -----------------------------------------------------
@node Knowledge App, Goals App, Policies App, Quickstart - The Mission Portal
@section Knowledge App

@menu
@end menu

The @i{Knowledge} app embodies CFEngine's knowledge index, used to find answers and document references and reports. Use CFEngine's automated analysis of policy, collected data and local knowledge to comprehend your tools and infrastructure with greater authority.

@sp 1
@center @image{img-knowledge-3-0,15cm,,Knowledge App}
@center Figure: Knowledge App
@sp 1


@c -----------------------------------------------------
@node Goals App, Compliance App, Knowledge App, Quickstart - The Mission Portal
@section Goals App

@menu
@end menu

The @i{Goals} app allows the user to compare high level organizational goals to persons and promises. Maintain a dialogue with management around these goals to showcase your value to the business. Help management to see how IT is responsive to its needs.

@sp 1
@center @image{img-goals-3-0,15cm,,Goals}
@center Figure: Goals
@sp 1


@c -----------------------------------------------------
@node Compliance App, User Management, Goals App, Quickstart - The Mission Portal
@section Compliance App

@menu
@end menu

The @i{Compliance} app gives a view over the current state and history of compliance across your system, through the lens of different compliance standards. Demonstrate how IT infrastructure monitors, repairs and maintains promises about regulatory requirements.

@sp 1
@center @image{img-compliance-3-0,15cm,,Compliance}
@center Figure: Compliance
@sp 1


@c ----------------------------------------------------
@node User Management, Mission Portal Settings, Compliance App, Quickstart - The Mission Portal
@section User Management

On a fresh install the default user @i{admin} belongs to the @i{admin} user group and has access everything in the Mission Portal. The @i{admin} user can add users to the internal database, set up external authentication and define roles to limit access.

The following shows how to add, edit and delete users from the internal database. See the respective sections, @ref{Configuration of external authentication} and @ref{Role Based Access Control (RBAC)} for advanced user management.

@sp 1
@image{img-user-management-3-0,15cm,,User Management}
@center Figure: User Management
@sp 1

@noindent Click the @b{Add User} button to add a new user to the internal database:

@sp 1
@image{img-add-user-3-0,15cm,,Add User}
@center Figure: Add User
@sp 1

Enter the user information as requested in the fields. If user roles have been defined (see @ref{Role Based Access Control (RBAC)}), you can also choose to assign one or more roles to the user by selecting an available group and clicking the '@b{<}' button located between the list of assigned and available roles. Finish by clicking @i{Create User}.

Users can be edited in the same way as above by clicking the @i{Pencil} button next to his or her user name.

The information a user is authorized to see is determined from his or her
role memberships. A user may be member of an arbitrary number of
roles, each which may grant and deny access to certain
information. User-authentication is carried out when users log on to the Mission Portal, see also @ref{Role Based Access Control (RBAC)}.


@c ----------------------------------------------------
@node Mission Portal Settings, , User Management, Quickstart - The Mission Portal
@section Mission Portal Settings

Mission Portal settings allow the user to set or edit the administrative email, administrative role, authentication method, activation of role based access control (RBAC), show/hide the Business and Planning rooms on the Mission Portal front page, and the unreachable (blue host) threshold.

@sp 1
@center @image{img-mission-portal-settings-3-0,15cm,,Mission Portal Settings}
@center Figure: Mission Portal Settings
@sp 1

@ignore
@noindent @b{Administrative email:}@*
This is the email address that the Mission Portal uses to send reports.

@sp 1
@noindent @b{Administrative role:}@*
Select which user group will have general administrator privileges in the Mission Portal. This group will be able to access the Mission Portal settings and configuration tools.
@end ignore

@sp 1
@noindent @b{Authentication method}@*
By default the Mission Portal will use the internal database to store user information. Default user name and password on the Mission Portal login page are "admin" and "admin".

External authentication (LDAP or Active Directory) is available for CFEngine 3 Nova 2.1 and later versions. See @ref{Configuration of external authentication} for how to set this up.

@sp 1
@noindent @b{Fall-back role}@*
User group that will be able to access the Mission Portal through internal database authentication if external authentication is down or misconfigured.

@sp 1
@noindent @b{Role-Based Access Control}@*
CFEngine 3 Enterprise 2.2.0 introduces Role-Based Access Control (RBAC) for all hosts, reports and promises shown in the Mission Portal. RBAC does not cover access control for making policy changes. If you wish to use RBAC in combination with external authentication (LDAP or AD), we recommend that you wait to turn on RBAC until you log on with the LDAP or AD user that has been designated a Mission Portal admin (i.e do not turn RBAC on while logged in with an internal database user in this case). RBAC can be globally switched on or off, but see also @ref{User Management} for more details.

@sp 1
@noindent @b{Show Business Room}@*
Set whether the Business room should be visible or not on the Mission Portal main page. This is a global setting that affects all users.

@sp 1
@noindent @b{Show Planning Room}@*
Set whether the planning room should be visible or not on the Mission Portal main page. This is a global setting that affects all users.

@sp 1
@noindent @b{Unreachable host threshold}
Time after which a host is defined as unreachable (blue host; the hub is unable to reach this host due to connection problems). Default threshold is 15 minutes.


@c *****************************************************
@c * CHAPTER
@c *****************************************************
@node  Quickstart - CFEngine Policies, Role Based Access Control (RBAC), Quickstart - The Mission Portal, Top
@chapter Quickstart - CFEngine Policies

Standard CFEngine policies consist of a declarative language that describes the desired state of a system. Individual statements are called @i{promises}, they can be grouped in @i{bundles} and have parametrized @i{body} templates. @c (@samp{bundle} and @samp{body} are keywords in CFEngine that correspond to these). 

@menu
* Simple Policy::
* General Policy Structure - What - When/Where - Why - How::
* CFEngine Design Center::
@end menu


@c ----------------------------------------------------
@node  Simple Policy, General Policy Structure - What - When/Where - Why - How, Quickstart - CFEngine Policies, Quickstart - CFEngine Policies
@section Simple Policy

Below is an example of a simple CFEngine policy:

@sp 1
@multitable {spac bundlesequence => ( "test" );} {Compulsary statement at start of policy and more space}
@item @b{CFEngine syntax} @tab @b{Comment} (CFEngine words @i{are non-italic and colored in the html version of this document})
@item 
@verbatim
body common control
{
@end verbatim
@tab @i{Compulsary statement at start of policy containing at least a} bundlesequence
@item 
@verbatim
 bundlesequence => { "test" };
@end verbatim
 @tab 
@i{Defines the order in which bundles are executed}@c body common control @i{has to contain} bundlesequence
@item 
@verbatim
}
@end verbatim
@item 
@verbatim
bundle agent test
{
@end verbatim
@tab This is a @i{bundle} of type @i{agent}, named 'test'
@item 
@verbatim
files:
@end verbatim
@tab This is the promise type, i.e. we make a promise about files
@item 
@verbatim
  "/tmp/testfile"
@end verbatim
@tab This is the promiser, i.e. the concerned object
@item
@verbatim
    create => "true";

}
@end verbatim
@tab This tells CFEngine to create the file
@end multitable

@ignore
@verbatim

body common control
{
  bundlesequence => { "test" };
}

# Comments are defined by the hash tag (#), they will not be parsed by CFEngine.

bundle agent test      # This is a bundle of type agent, named 'test'
{
files:		     # This is the promise type, i.e. we make a promise about files
  "/tmp/testfile"	     # This is the promiser (i.e. the concerned object)
    create => "true";  # This tells CFEngine to create the file
}

@end verbatim
@end ignore

@ignore
This policy will create the file @file{/tmp/testfile}. It contains the bare minimum of a standalone CFEngine policy, consisting of the compulsory @samp{body common control}, containing (at least) a bundlesequence. Then follows a compulsory @samp{bundle}, of type @samp{agent} and with the arbitrary name @samp{test} (the bundle type reflects the affected CFEngine component and can take several values, here we use @samp{agent}). The bundle contains a promise type (here @samp{files}), a promiser (i.e. the affected object, here @samp{/tmp/testfile}) and a promise about desired state (here @samp{create => "true"}).
@end ignore
This policy contains the bare minimum of a standalone CFEngine policy (i.e. a @code{body common control} and a @code{bundle agent} that executes an action) and will, in this case, create the file @file{/tmp/testfile}. 
@ignore
A closer look at the different parts of the policy:
@itemize -
@item The compulsory @samp{body common control}, containing (at least) a bundlesequence.
@item Then follows a compulsory @samp{bundle}, of type @samp{agent} and with the arbitrary name @samp{test}. The bundle type reflects the involved CFEngine component and can take several values, here we use the main instigator of change @samp{cf-agent}). 
@item The bundle contains a promise type (here @samp{files:}), a promiser (i.e. the affected object, here @samp{/tmp/testfile}) and an attribute about desired state (here @samp{create => "true"}; will create the file if it does not already exist).
@end itemize
@end ignore


@c ----------------------------------------------------
@node  General Policy Structure - What - When/Where - Why - How, CFEngine Design Center, Simple Policy, Quickstart - CFEngine Policies
@section General Policy Structure - What - When/Where - Why - How

Promiser, classes, comments, bodies


@c ----------------------------------------------------
@node  CFEngine Design Center, , General Policy Structure - What - When/Where - Why - How, Quickstart - CFEngine Policies
@section CFEngine Design Center

The CFEngine Design Center is a place for CFEngine community members and developers to share code and information. It contains three main types of content:

@itemize -
@item Sketches - Ready-to-use components (e.g. collections of bundles, support files, etc.) that can be directly imported and used in CFEngine policies. Most sketches are specialized for achieving specific tasks, or for maintaining a specific piece of software, however their scope and capabilities can be varied. They are organized in categories according to their functionality. Sketches are managed (installed, configured, enabled and uninstalled) through a specialized tool called cf-sketch.
@item CFEngine policy examples - The objective is to provide starting points for executing complex tasks in CFEngine. They are in most cases not ready to use and will require customization and modification before using them in your own environment.
@item Tools - Help in miscellaneous aspects of managing or interacting with CFEngine.
@end itemize

Please see @url{https://github.com/cfengine/design-center} for more information.


@c *****************************************************
@c * CHAPTER
@c *****************************************************
@node  Role Based Access Control (RBAC), Virtualization and Cloud, Quickstart - CFEngine Policies, Top
@chapter Role Based Access Control (RBAC)

Role-Based Access Control (RBAC) limits user access to the Mission Portal settings page and access to hosts, reports and promises in the different Mission Portal Apps. RBAC can be globally switched on or off in the Mission Portal settings (see @ref{Mission Portal Settings}).

On a fresh install the default user "admin" belongs to the "admin" user group and has access everything in the Mission Portal. The "admin" user can add users to the internal database, set up external authentication (see @ref{Configuration of external authentication}) and define roles to limit access.

@menu
* Defining Roles::
* Entities Filtered::
* Limitations::
@end menu


@c -----------------------------------------------------
@node Defining Roles, Entities Filtered, Role Based Access Control (RBAC), Role Based Access Control (RBAC)
@section Defining Roles

A role is defined as reporting
access to a set of hosts and promise bundles from the Mission Portal
and REST API. This does not give any rights with respect to changing
the content or execution of the policy. It should not be confused with
the @code{roles} promise-type that can be used by @code{cf-runagent}
and @code{cf-serverd}.

@sp 1
@image{img-user-roles-2-2,15cm,,User Roles}
@center Figure: User Roles
@sp 1

@noindent Click the @b{Add Role} button to add a new user role to the Mission Portal:

@sp 1
@image{img-add-role-2-2,15cm,,Add Role}
@center Figure: Add Role
@sp 1


Roles can be defined on either classes or bundles and involves setting permissions through an include and exclude list for each. The effective permissions of a user is the cumulative set of permission granted or denied by his roles, and is used to filter the information displayed in the following way: 

@itemize
@item Create a union of the granted access for the roles.
@item Override with the rules that deny access for the roles.
@item If left unspecified, access is denied.
@end itemize

In order to scale, both entities are
defined as a set of @emph{regular expressions} to allow and
deny.

Access to hosts is defined by regular expressions on @emph{classes},
not the hostname, ip, or any other name. This is done to ensure
maximum scalability. Classes can be arbitrarily defined in the
CFEngine policy language, so this incurs no loss of flexibility, but
ensures distributed computation.

In contrast to users, a role definition and membership can only be
obtained from the internal Mission Portal database. This means that
any roles must be defined through the Mission Portal web interface,
and can not be obtained from e.g. LDAP at this time. The rationale is
that querying complex LDAP structures for role membership is too
inefficient and error-prone. This may change in future releases, if
requested. Note that the @emph{possible members} of a role can be
obtained from other sources, as described in the section on user
administration. However, assigning possible members to roles must be
done through the Mission Portal user-interface.


@c -----------------------------------------------------
@node Entities Filtered, Limitations, Defining Roles, Role Based Access Control (RBAC)
@section Entities Filtered

The above discussion showed that RBAC is supported on the @emph{host} and @emph{promise bundle} level,
each applying to different parts of the Mission Portal. Both these
entities are atomic with respect to RBAC --- either a user can see
everything they contain, or nothing of it.

Access to a host is required to see any information about it, e.g. all
its reports, host information, and compliance
category. If a user is not allowed access to a host, the Mission
Portal would look the same as if the host was not bootstrapped to that
hub.

Information about the running policy is also available in the Mission
Portal, either through the Promise Finder or
by clicking a promise handle from one of the reports. The searchable
promises in the Promise Finder and information pages about promises
and bundles are filtered in the same manner as the hosts, but defined
based on promise bundles instead. 
@ignore
The Policy Editor is not covered by
RBAC --- access to the policy source repository allows the user to see
the whole policy. Some version control systems can be configured to
only allow users to access sub-directories of the policy, which may
help in this case.
@end ignore

Note that the host and promise filtering is independent --- no attempt
is made to try to infer which promises a role should have access to
based on the hosts it has access to or vice versa.


@c -----------------------------------------------------
@node Limitations, , Entities Filtered, Role Based Access Control (RBAC)
@section Limitations

@itemize

@item Notes added in the Mission Portal are not filtered: they can be
seen by all users (including notes added to any host page).

@item The Knowledge Map is only available for members of the
@samp{admin} role when RBAC is switched on.

@item Running @code{cf-report} from the command-line on the hub will
bypass all RBAC checks.

@end itemize


@c *****************************************************
@c * CHAPTER
@c *****************************************************
@node  Virtualization and Cloud, Windows-specific features in CFEngine 3 Enterprise, Role Based Access Control (RBAC), Top
@chapter Virtualization and Cloud


@menu
* What are virtualization and cloud computing?::  
* Why build virtualization support into CFEngine?::  
* What can CFEngine do with virtual machines?::  
* Guest environments promises::
* Virtualization types supported::  
* Distinct states::             
* Example deployment::          
@end menu


@c -----------------------------------------------------
@node  What are virtualization and cloud computing?, Why build virtualization support into CFEngine?, Virtualization and Cloud, Virtualization and Cloud
@section What are virtualization and cloud computing?
@sp 1

Virtualization refers to the ability to run multiple host instances on
a single physical node. Cloud computing typically refers to what is
called `platform as a service', or deployment of virtual machines on
demand, often as an on-line service.

In this document, virtualization support refers specifically to
hypervisor technologies supported by the open source library layer @i{libvirt}
project, which includes interfaces for Xen, KVM, Vmware-ESX, and more.
CFEngine thus integrates freely with other tools based on this library, such
as @i{virsh} and the @i{Virtual Manager} graphical user interface.


@c -----------------------------------------------------
@node  Why build virtualization support into CFEngine?, What can CFEngine do with virtual machines?, What are virtualization and cloud computing?, Virtualization and Cloud
@section Why build virtualization support into CFEngine?
@sp 1

Virtualization engines (usually called supervisors or hypervisors) are
seeing an explosion of development. They exist as a number of projects
in various stages of maturity. The libvirt project was designed as
an integration layer based on an XML specification.

The tools for management are still quite primitive and require much
manual work. CFEngine has a unique role to play in maintaining desired
state in virtual machine systems.  

In the cloud, virtual machines may be rented from remote commercial
providers, and managed as disposable resources. Convergent or
`self-healing' maintenance is an essential method for managing
machines that are geographically remote and awkward to access, e.g.
machines in other time-zones that it is impractical to monitor by
legacy methods.


@c -----------------------------------------------------
@node  What can CFEngine do with virtual machines?, Guest environments promises, Why build virtualization support into CFEngine?, Virtualization and Cloud
@section What can CFEngine do with virtual machines?
@sp 1

The simple answer is: most things that @i{libvirt} can do, with added
convergence to a desired state: that means, creating, destroying and
starting and stopping machines. By starting virtual machines through
CFEngine, you can be sure that a given `virtual guest' is running on
one and only one physical host, thus avoiding conflicts that are
difficult to detect with centralized systems.

CFEngine does not support everything that libvirt does -- it offers a
simplified interface that is meant for robustness, stability and
hands-free repeatability.

@sp 1
@cartouche
CFEngine does not use libvirt's TLS based web communication layer.  It
manages every host as an independent entity, in typical CFEngine
fashion, using CFEngine's own distributed cooperation to provide the
implicit communication.  CFEngine does not currently support so-called
`live migration' of virtual machines.
@end cartouche
@sp 1


@c -----------------------------------------------------
@node  Guest environments promises, Virtualization types supported, What can CFEngine do with virtual machines?, Virtualization and Cloud
@section Guest environments promises
@sp 1

A virtual machine is one example of what CFEngine calls an `guest
environment'.  You can promise to create (and host) an guest
environment with certain attributes, just as you can promise to host a
file or a process. Here is a simple example:

@verbatim
body common control
{
bundlesequence  => { "my_vm_cloud" };   
}

#######################################################

bundle agent my_vm_cloud
{
guest_environments:

   "myUbuntu" # the running instance name, defined in XML

       environment_resources => virt_xml,
       environment_type      => "xen",
       environment_host      => "my_physical_computer", # ipv4_10_1_2_3
       environment_state     => "create";
}

#######################################################

body environment_resources virt_xml
{
env_spec_file => "/srv/xen/centos5-libvirt-create.xml";
}

@end verbatim

@itemize
@item The promiser (in this case @samp{myUbuntu}) is the name of the virtual
machine. This should be a unique identifier, as we need to be able to
refer to machines uniquely.

@item The guest environment host is the name of the computer that
is the host for the virtual machine. 

@item Normally when we want to ensure something on a machine, we use classes
to decide where the promise will be made. For guest environments, however,
we need to make promises about the uniqueness of the machine. When you
make a machine instance you normally want it to be running on one and
only one host. So you want @i{every} machine to make a promise. On the
guest environment's host, you want to promise that the guest environment is
running, and on every other machine you want to promise that it is
not. In CFEngine, you simply include a unique class belonging to host
in the promise using @code{environment_host} and CFEngine assumes that
rest. Unique classes might include
@itemize
@item Hostname class e.g. @code{myhost_CFEngine_com}
@item IP address class e.g. @code{ipv4_123_456_789_123}
@end itemize
@end itemize

An alternative way to write this example is to quote the XML
specification in CFEngine directly. This has a few advantages: you can
re-use the data and use it as a template, filling in
CFEngine-variables. You can thus adapt the configuration using
CFEngine's classes.

@page
@verbatim
bundle agent my_vm_cloud
{
guest_environments:

   "myUbuntu" # the running instance name, defined in XML
       environment_resources => virt_xml("$(this.promiser)"),
       environment_type      => "xen",
       environment_host      => "myphysicalcomputer";
       environment_state     => "create"
}

#######################################################

body environment_resources virt_xml(host)
{
env_spec_file => 

"<domain type='xen'>
  <name>$(host)</name>
  <os>
    <type>linux</type>
    <kernel>/var/lib/xen/install/vmlinuz-ubuntu10.4-x86_64</kernel>
    <initrd>/var/lib/xen/install/initrd-vmlinuz-ubuntu10.4-x86_64</initrd>
    <cmdline> kickstart=http://example.com/myguest.ks </cmdline>
  </os>
  <memory>131072</memory>
  <vcpu>1</vcpu>
  <devices>
    <disk type='file'>
      <source file='/var/lib/xen/images/$(host).img'/>
      <target dev='sda1'/>
    </disk>
    <interface type='bridge'>
      <source bridge='xenbr0'/>
      <mac address='aa:00:00:00:00:11'/>
      <script path='/etc/xen/scripts/vif-bridge'/>
    </interface>
    <graphics type='vnc' port='-1'/>
    <console tty='/dev/pts/5'/>
  </devices>
</domain>
";
}
@end verbatim

You should consult the libvirt documentation for the details of the XML specification.


@c -----------------------------------------------------
@node  Virtualization types supported, Distinct states, Guest environments promises, Virtualization and Cloud
@section Virtualization types supported
@sp 1

CFEngine currently supports virtualization only through libvirt, so it supports
those technologies that libvirt supports. Currently this includes  most popular
technologies. You must choose the type of monitor that is to be responsible for
keeping the guest environment promise. In CFEngine, you should choose between a
machine environment or network environment of the following types:
@table @code
@item xen
A Xen hypervisor virtual domain.
@item kvm
A KVM hypervisor virtual domain.
@item esx
A VMware hypervisor virtual domain.
@item test
The libvirt test-hypervisor virtual domain.
@item xen_net
A Xen hypervisor virtual network.
@item kvm_net
A KVM hypervisor virtual network
@item esx_net
An ESX/VMWare hypervisor virtual network.
@item test_net
The test hypervisor virtual network.
@item zone
A Solaris zone (future development)
@item ec2
An Amazon EC2 instance (future development)
@item eucalyptus
A Eucalyptus instance (future development)
@end table


Once again, you must consult the libvirt documentation for details.


@c -----------------------------------------------------
@node  Distinct states, Example deployment, Virtualization types supported, Virtualization and Cloud
@section Distinct states
@sp 1

Libvirt recognizes a number of distinct states are transliterated into CFEngine
as
@table @code
@item create
Build and start an guest environment.
@item delete
Halt and remove runtime resources associated with an guest environment.
@item running
An existing guest environment is in a running state.
@item suspended
An existing guest environment is in a `paused' state.
@item down
An existing guest environment is in a halted state.
@end table
The default promised state is for a machine to be running 
wherever the  @code{environment_host} class is true, and
suspended or down elsewhere.


@c -----------------------------------------------------
@node  Example deployment,  , Distinct states, Virtualization and Cloud
@section Example deployment
@sp 1

Prerequisites: you need to make a `disk image' for the machine, or a
virtual disk of blocks that can be allocated. This image does not have to
contain any data, it will simply as a block device for the VM. You
can then install it by booting the machine from a network image, like a
PXE/kickstart installation.

If you want to allocate disk blocks as the file grows, you can create
a file with a hole. The following command will creates a file of
2048MB, but the actual data blocks are allocated in a lazy fashion:

@verbatim

# dd if=/dev/zero of=/srv/xen/my.img oflag=direct bs=1M seek=2047 count=1

@end verbatim
To reserve all the data blocks right away: 
@verbatim

# dd if=/dev/zero of=/srv/xen/my.img oflag=direct bs=1M count=2048

@end verbatim

Libvirt uses an XML file format that cannot be circumvented. CFEngine
promises to honor the promises that are expressed in this file, as in
the examples above.  You need to find out about this file format from
the libvirt website.  To get CFEngine to Honor these promises, you
point it to the specification that it should promise using
@code{spec_file}.

You need to set up a network for virtual machines to communicate with
the outside world. This can also be done with CFEngine, using the
network promise types to build a bridge into a virtual network.

Then just run CFEngine to start, stop or manage the guest environments on
each localhost. Run in verbose mode to see how CFEngine maintains the states
convergently.
@verbatim
# cf-agent -v
@end verbatim


@c *****************************************************
@c * CHAPTER
@c *****************************************************
@node Windows-specific features in CFEngine 3 Enterprise, REST API, Virtualization and Cloud, Top
@chapter Windows-specific features in CFEngine 3 Enterprise

In this section, we will explore the Windows-specific features of the
native Windows version of CFEngine 3 Enterprise, and how it integrates with
Windows. We will also consider features that are more interesting or
popular on Windows than on other platforms.

Feature highlights include Windows service management and integration,
event logging, Windows registry repair, and fine-tuned file security
support through access control lists. See the sections on databases
and ACLs to find information on Windows registry repair and NTFS ACLs,
respectively. We will look at some of the other added features next.

@section Windows service management

CFEngine 3 Enterprise can maintain complete control of the state of all
Windows services, in addition to Unix daemons. Services prone to
security issues or errors can easily be given a disabled state.

@image{winservice-disabled_policy,8cm,,Disabled Windows service,png}

A service can also be given a running state, in which case CFEngine
3 Enterprise ensures that it is running, and starts it if it is not, with
parameters if desired. More advanced policy options are also
available, including support for starting and stopping dependencies,
and configuring when the services should be started (e.g. only when
they are being used).

Furthermore, the CFEngine executor in CFEngine 3 Enterprise now runs as a Windows
service itself. This means it runs in the background an starts with
Windows, before any user logs in. It can be configured, started and
stopped from the ``Services'' listing in Windows.

Note that the name of a service in Windows may be different from its
``Display name''. CFEngine 3 Enterprise policies use the name, not the display
name, due to the need of uniqueness.

@image{winservice-properties_name,7cm,,Windows service name and Display name,png}


@section Windows event logging
Event logs are the Windows counterpart to syslog from Unix. The main
difference is that event logs aim to group similar log messages,
giving each group an event id.

@image{winevent-repaired-acl-closeup,7cm,,Promise repaired in Event Viewer,png}

A program that creates logs, such as CFEngine 3 Enterprise, must define the
possible event IDs, and their meaning. In many applications, only one
event id is defined, a generic log message. However, CFEngine 3 Enterprise
defines the following range of event IDs, which allows for automatic
handling of log messages.

@multitable @columnfractions .4 .2 .2
@headitem Description @tab Event ID @tab Type
@item Promise kept @tab 100 @tab Information
@item Promise repaired @tab 101 @tab Information
@item Promise not repaired due warn only policy @tab 102 @tab Error
@item Promise not repaired due to error @tab 103 @tab Error
@item Report promise @tab 104 @tab Information
@item Generic information @tab 105 @tab Information
@item Generic verbose @tab 106 @tab Information
@item Generic warning @tab 107 @tab Warning
@item Generic error @tab 108 @tab Error
@end multitable

@image{winevent-notkept-storage,10cm,,Promise not kept in Event Viewer,png}

The CFEngine 3 Enterprise event logs can be found under the ``System'' logs.  Almost
all monitoring products for Windows supports reading event logs, and
they can thus monitor logs from CFEngine 3 Enterprise as well. This makes it
possible to do more advanced querying on the status of a machine
running CFEngine 3 Enterprise, e.g. to show all promises that have not been
kept in a certain time interval. However, we recommend using the
Knowledge Map to do more advanced things, as it is specifically made
for this purpose and supports all operating systems that CFEngine runs
on.

@section Windows special variables
Three new special variables have been added to the Windows version of
CFEngine 3 Enterprise.

@itemize

@item @code{sys.windir} contains the Windows directory,
e.g. ``C:\WINDOWS''.

@item @code{sys.winsysdir} contains the Windows system directory,
e.g. ``C:\WINDOWS\system32''.

@item @code{sys.winprogdir} contains the program files directory,
e.g. ``C:\Program Files''.

@end itemize

Note that these variables are not statically coded, but retrieved from
the current system. For example, @code{sys.winprogdir} is often
different on Windows versions in distinct languages.


@section Windows hard classes
The Windows version of CFEngine 3 Enterprise defines hard classes to pinpoint
the exact version of Windows that it is running on, the service pack
version and if it's a server or workstation.

First of all, the class @code{windows} is defined on all Windows
platforms. For Windows workstations, such as Windows XP,
@code{WinWorkstation} is defined. On Windows servers, such as Windows
Server 2003, @code{WinServer} is defined. In addition, if the server
is a domain controller, @code{DomainController} is defined. Note that
if @code{DomainController} is defined, then @code{WinServer} is also
defined, for natural reasons.

The class @code{Service_Pack_X_Y} is defined according to the service
pack version. For example, at the time of writing,
@code{Service_Pack_3_0} is set on an updated Windows XP operating
system.

To allow taking specific actions on different Windows versions, one
of the following hard classes is defined.

@itemize
@item @code{Windows_7}
@item @code{Windows_Server_2008_R2}
@item @code{Windows_Server_2008}
@item @code{Windows_Vista}
@item @code{Windows_Server_2003_R2}
@item @code{Windows_Home_Server}
@item @code{Windows_Server_2003}
@item @code{Windows_XP_Professional_x64_Edition}
@item @code{Windows_XP}
@item @code{Windows_2000}
@end itemize

Note that all defined hard classes for a given system is shown by
running @code{cf-promises -v}.


@section Notes on windows policies
A potential problem source when writing policies for windows is that
paths to executables often contain spaces. This makes it impossible
for CFEngine to know where the executable ends and the parameters to
it starts. To solve this, we place escaped quotes around the
executable.

Additionally, Windows does not support that processes start themselves
in in the background (i.e. fork off a child process in the Unix
world). The result is that CFEngine is always waiting for the commands
to finish execution before checking the next promise. To avoid this,
use the background attribute in the action body-part.

Both these things are demonstrated in the following example.

@verbatim

body common control
{
bundlesequence  => { "main" };
}

bundle agent main
{
commands:

"\"C:\Program Files\Some Dir\program name.bat\" --silent --batch"
  action => background;
}

body action background
{
background => "true";
}

@end verbatim

Finally, one should note that Windows lacks support for certain
features that are utilized in Unix versions of CFEngine. These include
symbolic links, file groups, user and group identifiers.

Thus, the parts of promises containing these features will be
ignored. For example, the @code{getgid()} function does not return
anything on Windows. The reference manual documents exactly which
promises are ignored and not.  Also, @code{cf-agent} from CFEngine
3 Enterprise prints warning messages on ignored attributes when run in verbose
mode.


@c **************************************************
@c CHAPTER
@c **************************************************
@node REST API, Monitoring extensions, Windows-specific features in CFEngine 3 Enterprise, Top
@chapter REST API

@menu
* API Overview::
* Resources::
@end menu

The Nova REST API allows HTTP clients to access report information gathered by the Nova Hub. Most of the information contained in the reports available through the Mission Portal are also available through REST, although in a slightly different form. Furthermore, the REST API is currently read-only.

@c -----------------------------------------------------
@node API Overview, Resources, REST API, REST API
@section API Overview

@menu
* Response Codes::
* Response Bodies::
* Common Query Parameters::
* Time::
* Versioning and Content-Types::
* Authentication::
@end menu

The API is composed of a set of HTTP resources available by issuing an HTTP GET request to the resource URI. The available resources at the top-level are:

@itemize -
@item @b{Status} @code{/rest/}: Version information and database connectivity status.
@item @b{Contexts} @code{/rest/context}: Occurrences of contexts (classes) at hosts
@item @b{Hosts} @code{/rest/host}: Host information and last seen records. 
@item @b{Promises} @code{/rest/promise}: Promise compliance, logs and log summaries.
@item @b{Setuid Programs} @code{/rest/setuid}: Programs running with the setuid flag.
@item @b{Software} @code{/rest/software}: Installed software.
@item @b{Variables} @code{/rest/variable}: Policy variables and their most recent values.
@item @b{File Changes} @code{/rest/file}: Host file changes and their diffs if available.
@end itemize


@c -----------------------------------------------------
@node Response Codes, Response Bodies, API Overview, API Overview
@subsection Response Codes
We have taken some care to return appropriate HTTP error codes and descriptive messages for responses. However, because the API is read-only, the set of codes a client should expect is limited. Some error codes an API should be able to handle are:

@itemize -
@item @b{200 OK}. This is the response you should normally expect when querying the API.
@item @b{400 Bad request}. Usually indicates that query parameters where not accepted or malformed.
@item @b{401 Unauthorized}. Client credentials did not authenticate.
@item @b{403 Forbidden}. Client requested a specific resource that was denied by RBAC.
@item @b{404 Not found}. A non-existing resource was requested.
@item @b{406 Not Acceptable}. Unable to accomodate the @code{Accept} header of the request.
@item @b{500 Internal Error}. Usually this means that there was a database connectivity problem. If not, it may indicate a bug.
@end itemize


@c -----------------------------------------------------
@node Response Bodies, Common Query Parameters, Response Codes, API Overview
@subsection Response Bodies
The response body always consists of two elements, @code{meta} and @code{data}. @code{meta} always contains the fields @code{total} (the total number of results matched by the query), @code{page} (the page index returned), @code{count} (the number of results on the returned page) and @code{timestamp}. @code{data} contains the result set. Here is an example.

@verbatim
{
  "meta": {
    "total": 1,
    "timestamp": 1329315702,
    "page": 1,
    "count": 1
  },
  "data": [{
    "apiName": "CFEngine Nova",
    "apiVersion": "v1",
    "hubVersion": "2.2.0.a1.rexported",
    "database": "connected"
  }]
}
@end verbatim

@b{Note}: For the remainder of this document we show only the contents of the @code{data} field for the sake of brevity.


@c -----------------------------------------------------
@node Common Query Parameters, Time, Response Bodies, API Overview
@subsection Common Query Parameters
Each resource accept their own set of query parameters, but we have attempted to keep to keep this set uniform within reason across resources. Moreover, a common set of query parameters will be accepted for all resources (and observed where it makes sense).

@itemize -
@item @b{count}: The number of results to return per page. Default is 50.
@item @b{page}: The index of the results page to return: Default is 1.
@item @b{from}: Unix timestamp before which we discard records as too old. Default is 0.
@item @b{to}: Unix timestamp after which we discard records as too new. Default is current time.
@end itemize

@b{Note}: that Software and Setuid resources currently do not support time ranges.


@c -----------------------------------------------------
@node Time, Versioning and Content-Types, Common Query Parameters, API Overview
@subsection Time
Unless otherwise specified, all timestamps or durations are in seconds. Timestamps are reported in Unix time, i.e. seconds since 1970.


@c -----------------------------------------------------
@node Versioning and Content-Types, Authentication, Time, API Overview
@subsection Versioning and Content-Types
Clients may specify the version of the API to use by appending an @code{Accept} header to a request with an appropriate content-type. The server responds in turn by appending a @code{Content-Type} header to the response, encoding the API version employed. The content-type is a vendor MIME-type of the form @code{application/vnd.cfengine.nova-v<N>+<format>}. We only support JSON in this first release of the API, so the content-type header will be @code{application/vnd.cfengine.nova-v1+json}. If no @code{Accept} header is specified by the client, the server will always return the most recent version available. It is the responsibility of the client to request the desired version and condition on the type of response. In the future, the version will only be bumped in the event of breaking backward-compatibility, not merely adding new resources or options.


@c -----------------------------------------------------
@node Authentication, , Versioning and Content-Types, API Overview
@subsection Authentication

@menu
* Role-based Access Control for REST::
@end menu

The REST API uses HTTP basic authentication. Unauthenticated requests will receive a @code{401} response with a @code{WWW-Authenticate} header. Clients are required to append an @code{Authorization: Basic <key>} header to each request (since REST is stateless, there is no notion of session state). The key is a Base64 encoded string of the format @code{<username>:<password>}. (Note that clients such as web-browsers and @code{curl} handle basic authentication seamlessly). This means that the username and password is transmitted effectively as plaintext. Encryption is commonly handled through SSL at the HTTP server.


@c -----------------------------------------------------
@node Role-based Access Control for REST, , Authentication, Authentication
@subsubsection Role-based Access Control for REST
The user table is the same as for the Mission Portal and is stored either in the database or delegated to LDAP. The REST API also works in conjunction with Role-based Access Control (RBAC). Most requests are effectively searches across multiple dimensions, and RBAC may render the result set empty without providing an authorization error. However, when requesting specific resources a client should be prepared for a @b{403 Forbidden}.


@c -----------------------------------------------------
@node Resources, , API Overview, REST API	
@section Resources

@menu
* Status::
* Contexts::
* Hosts::
* Promises::
* Setuid Programs::
* Software::
* Variables::
* File Changes::
@end menu

@c -----------------------------------------------------
@node Status, Contexts, Resources, Resources
@subsection Status

@itemize -
@item @b{URI Path}: @code{/rest/}
@item @b{Query Parameters}: (common only)
@end itemize

The Status resource serves as a simple way to to see if the API is alive and to check which version of Nova it is running. Note that the Nova database (MongoDB) needs to be running in order to authenticate. The Status resource serves as a good starting point to demonstrate simple usage. Here we use @code{curl}, a command-line client. The @code{-v} flag shows the full HTTP request and response returned.

@verbatim
curl --user admin:admin -v http://localhost:8888/rest

* About to connect() to localhost port 8888 (#0)
*   Trying 127.0.0.1... connected
* Connected to localhost (127.0.0.1) port 8888 (#0)
* Server auth using Basic with user 'admin'
> GET /rest HTTP/1.1
> Authorization: Basic YWRtaW46YWRtaW4=
> User-Agent: curl/7.21.6 (x86_64-pc-linux-gnu) libcurl/7.21.6 OpenSSL/1.0.0e zlib/1.2.3.4 libidn/1.22 librtmp/2.3
> Host: localhost:8888
> Accept: */*
> 
< HTTP/1.1 200 OK
< Server: nginx/1.0.5
< Date: Mon, 13 Feb 2012 17:23:39 GMT
< Content-Type: application/vnd.cfengine.nova-v1+json
< Transfer-Encoding: chunked
< Connection: keep-alive
< X-Powered-By: PHP/5.3.6-13ubuntu3.5
< Allow: GET
< X-Resource: Base
< 
{"status":"ok","timestamp":1329316866,"page":1,"count":50,"total":1,"result":
 {"apiName":"CFEngine Nova","apiVersion":"v1","hubVersion":"2.2.0.a1.rexported",
  "database":"connected"}}
* Connection #0 to host localhost left intact
* Closing connection #0
@end verbatim

Note that the REST API compacts the JSON response rather than pretty-printing it. It is possible to pipe the response from curl into a json prettifier at the command-line. Another option is to use a plugin for a browser like Firefox (e.g. RESTClient).


@c -----------------------------------------------------
@node Contexts, Hosts, Status, Resources
@subsection Contexts

A context (previously class) resource describes the probability of occurrence of a context at a host. Contexts are either defined or not defined during a single run of agent execution.

@itemize -
@item @b{URI Path}: /rest/context
@item @b{Query Parameters}:

@itemize 
@item @b{hostkey}: Host the context occurs at.
@item @b{context}: A regular expression to filter on contexts active at host.
@end itemize

@end itemize

Example of a typical body from a context response:

@verbatim
[
  {
    "hostkey": "SHA=33736d45041e2a9407be8cf449aeffa95114bef661c20deaca1bbcfbc2922856",
    "context": "entropy_udp_in_low",
    "average": 0.7000,
    "stdv": 0.8367,
    "lastseen": 1328194134
  },
  ...
]
@end verbatim

The average and standard deviation refer to the frequency with which the context is observed in agent runs at the host.


@c -----------------------------------------------------
@node Hosts, Promises, Contexts, Resources
@subsection Hosts

@menu
* Listing hosts::
* Basic Host Information::
* Hosts Seen::
@end menu

Hosts are naturally fundamental to CFEngine, being the environment in which @code{cf-agent} runs. The REST API allows you to get at some basic information about hosts which agents have corresponded with the Hub. Hosts are universally identified by their @code{hostkey} - a SHA1 identifier. To list hosts visibile to the Hub, we can issue the following


@c -----------------------------------------------------
@node Listing hosts, Basic Host Information, Hosts, Hosts
@subsubsection Listing hosts
@itemize -
@item @b{URI Path}: @code{/rest/host}
@item @b{Query Parameters}:

      @itemize 
      @item @b{hostname}: Name of host.
      @item @b{ip}: IP-address of host.
      @item @b{context}: Context active at host (Regular Expression).
      @end itemize

@end itemize

The base host resource simply returns a list of matching keys.

@verbatim
[
  "SHA=305658693b94e003e765956f1609731419cbc0e5c9caa09e230df5e005f1f283",
  "SHA=33736d45041e2a9407be8cf449aeffa95114bef661c20deaca1bbcfbc2922856"
]
@end verbatim


@c -----------------------------------------------------
@node Basic Host Information, Hosts Seen, Listing hosts, Hosts
@subsubsection Basic Host Information
Now, we can get the name and IP of a particular host, providing the hostkey.

@itemize -
@item @b{URI Path}: @code{/rest/host/:id}
@item @b{Query Parameters}: (common only)
@end itemize

@verbatim
{
  "hostkey": "SHA=305658693b94e003e765956f1609731419cbc0e5c9caa09e230df5e005f1f283",
  "name": "hostA",
  "ip": "10.0.0.150"
}
@end verbatim

Note that there are tons of other information we could have returned about the host, such as variables. You can get that by issuing requests like @code{/rest/variable?hostkey=SHA...}. As we need the capability of searching in variables by other properties than hostkey, we have opted to keep a separate variable resource, rather than a @code{/rest/host/:id/variable}.


@c -----------------------------------------------------
@node Hosts Seen, , Basic Host Information, Hosts
@subsubsection Hosts Seen

Next, we can get information about which hosts a host has seen or has been seen by.

@itemize -
@item @b{URI Path}: @code{/rest/host/:id/seen}
@item @b{Query Parameters}: (common only)
@end itemize

@verbatim
[
  {
    "hostkey": "SHA=33736d45041e2a9407be8cf449aeffa95114bef661c20deaca1bbcfbc2922856",
    "lastseen": 108,
    "average": 108,
    "stdv": 180
  },
  ...
]

@end verbatim

We can also discover when agents at other hosts discovered a given host. The format of the body of the response is the same - only the URI path is different.

@itemize -
@item @b{URI Path}: @code{/rest/host/:id/seen-by}
@item @b{Query Parameters}: (common only)
@end itemize


@c -----------------------------------------------------
@node Promises, Setuid Programs, Hosts, Resources
@subsection Promises

@menu
* Promise Compliance::
* Promise Log::
* Promise Log Summary::
@end menu

Promises are the statements executed by CFEngine agents. We provide three views of promise execution results: Compliance, Log and Log Summary.


@c -----------------------------------------------------
@node Promise Compliance, Promise Log, Promises, Promises
@subsubsection Promise Compliance

Promise Compliance is the current status of promises in the system and their aggregated statistics.

@itemize -
@item @b{URI Path}: @code{/rest/promise/compliance}
@item @b{Query Parameters}:

      @itemize 
      @item @b{hostkey}: Host of agent executing the promise.
      @item @b{handle}: Handle of promise.
      @item @b{context}: Context of agent executing the promise (Regular Expression).
      @item @b{state}: Result state of promise, valid values are: @code{kept}, @code{notkept} and @code{repaired}.
      @end itemize

@end itemize

Here is an examplary response:

@verbatim
[
  {
    "handle": "cfengine_correct_cftwin_files_libtwin",
    "hostkey": "SHA=33736d45041e2a9407be8cf449aeffa95114bef661c20deaca1bbcfbc2922856",
    "state": "kept",
    "average": 100.0000,
    "stdv": 0.0000,
    "timestamp": 1328194134
  },
  ...
]
@end verbatim


@c -----------------------------------------------------
@node Promise Log, Promise Log Summary, Promise Compliance, Promises
@subsubsection Promise Log

A promise ends up in the promise log if the agent managed to repair a previously broken promise, or if a promise was broken. These are held as two separate logs by the Nova database, so we have opted to require the requestor to specify which log to look at, effectively specifying either state @code{repaired} or @code{notkept}. The results are the same for both states. 

@itemize -
@item @b{URI Path}: @code{/rest/promise/log/repaired} or @code{/rest/promise/log/notkept}
@item @b{Query Parameters}:

      @itemize 
      @item @b{hostkey}: Host of agent executing the promise.
      @item @b{handle}: Handle of promise.
      @item @b{context}: Context of agent executing the promise (Regular Expression).
      @item @b{to}: In addition to the common @b{from} parameter, discards entries newer than this upper bound.
      @end itemize

@end itemize

Example response:

@verbatim
[
  {
    "handle": "garbage_collection_files_tidy_outputs",
    "hostkey": "SHA=305658693b94e003e765956f1609731419cbc0e5c9caa09e230df5e005f1f283",
    "description": " -> Deleted file /var/cfengine/outputs/cf_policy_test_cfengine_com__1326972365_Thu_Jan_19_12_26_05_2012_0x7ff1b940f700",
    "state": "repaired",
    "timestamp": 1327577464
  },
  ...
]
@end verbatim

Note that the description field is the collected output from the agent, in this case having repaired a promise.


@c -----------------------------------------------------
@node Promise Log Summary, , Promise Log, Promises
@subsubsection Promise Log Summary

Promise log summaries provides an aggregated view of log messages by grouping similar agent reports and counting them up.

@itemize -
@item @b{URI Path}: @code{/rest/promise/log/repaired/summary} or @code{/rest/promise/log/notkept/summary}
@item @b{Query Parameters}:

      @itemize 
      @item @b{hostkey}: Host of agent executing the promise.
      @item @b{handle}: Handle of promise.
      @item @b{context}: Context of agent executing the promise (Regular Expression).
      @item @b{to}: In addition to the common @b{from} parameter, discards entries newer than this upper bound.
      @end itemize

@end itemize

Example response:

@verbatim
[
  {
    "handle": "cfengine_correct_cftwin_files_libtwin",
    "description": "Can't stat /var/cfengine/lib in files.copyfrom promise",
    "count": 4,
    "state": "notkept"
  },
  ...
]
@end verbatim

From this response, we can deduce that the promise @code{cfengine_correct_cftwin_files_libtwin} failed four times across all hosts.


@c -----------------------------------------------------
@node Setuid Programs, Software, Promises, Resources
@subsection Setuid Programs

Setuid programs is a special report provided by agents about which programs are running with the setuid flag set.

@itemize -
@item @b{URI Path}: @code{/rest/setuid}
@item @b{Query Parameters}:

      @itemize 
      @item @b{hostkey}: Host where the setuid program is running.
      @item @b{path}: Path of the setuid program (Regular Expression).
      @item @b{context}: Context active at host (Regular Expression).
      @end itemize

@end itemize

Example response:

@verbatim
[
  {
    "path": "/usr/sbin/pppd",
    "hostkeys": [
      "SHA=305658693b94e003e765956f1609731419cbc0e5c9caa09e230df5e005f1f283"
    ]
  },
  ...
]
@end verbatim


@c -----------------------------------------------------
@node Software, Variables, Setuid Programs, Resources
@subsection Software

The agent reports on which software is currently installed on the host.

@itemize -
@item @b{URI Path}: @code{/rest/software}
@item @b{Query Parameters}:

      @itemize 
      @item @b{hostkey}: Host where the software is installed.
      @item @b{name}: Name of the software.
      @item @b{version}: Version of the software.
      @item @b{arch}: Architecture of the software.
      @item @b{context}: Context active at host (Regular Expression).
      @end itemize

@end itemize

Example response:

@verbatim
[
  {
    "name": "sed",
    "version": "4.1.5-5.fc6",
    "arch": "x86_64",
    "hostkeys": [
      "SHA=33736d45041e2a9407be8cf449aeffa95114bef661c20deaca1bbcfbc2922856"
    ]
  },
  ...
]
@end verbatim


@c -----------------------------------------------------
@node Variables, File Changes, Software, Resources
@subsection Variables

@menu
* Variable Types::
@end menu

Variables are similar to contexts in that they are either built-in (hard) or promises (soft). In contrast to contexts, variables may assume a range of value types, whereas contexts are either defined or not defined. The scope of the variable is the name of the bundle (container of promises) where it was defined. In the case of variables redefined during execution, the final value is reported.

@itemize -
@item @b{URI Path}: @code{/rest/variable}
@item @b{Query Parameters}:

      @itemize 
      @item @b{hostkey}: Host where the variable promise was executed.
      @item @b{scope}: Name of the variable.
      @item @b{name}: Name of the variable.
      @item @b{value}: Value of the variable.
      @item @b{type}: Type of the variable (see Variable Types).
      @item @b{context}: Context active at host (Regular Expression).
      @end itemize

@end itemize


@c -----------------------------------------------------
@node Variable Types, , Variables, Variables
@subsubsection Variable Types

Variables are either lists of scalars, or scalars. The following are scalar types.

@itemize 
@item @b{string}
@item @b{int}
@item @b{real}
@item @b{menu} (an enumerated value)
@end itemize

Correspondingly, the list types are @code{slist}, @code{ilist}, @code{rlist} and @code{mlist}.

Here is an example response to a variable request.

@verbatim
[
  {
    "hostkey": "SHA=33736d45041e2a9407be8cf449aeffa95114bef661c20deaca1bbcfbc2922856",
    "scope": "control_runagent",
    "name": "hosts",
    "type": "slist",
    "value": [
      "127.0.0.1"
    ]
  },
  {
    "hostkey": "SHA=33736d45041e2a9407be8cf449aeffa95114bef661c20deaca1bbcfbc2922856",
    "scope": "control_reporter",
    "name": "style_sheet",
    "type": "string",
    "value": "/cf_enterprise.css"
  },
  ...
]
@end verbatim


@c -----------------------------------------------------
@node File Changes, , Variables, Resources
@subsection File Changes

The agent is able to monitor files for changes, and optionally produce a diff for the changes.

@itemize -
@item @b{URI Path}: @code{/rest/file}
@item @b{Query Parameters}:

      @itemize 
      @item @b{hostkey}: Host where the software is installed.
      @item @b{path}: Path of file changed (Regular Expression)
      @item @b{context}: Context active at host (Regular Expression).
      @end itemize

@end itemize

Here is an example of a two file files, one for which a diff was also captured.

@verbatim
[
    {
        "hostkey": "SHA=305658693b94e003e765956f1609731419cbc0e5c9caa09e230df5e005f1f283",
        "path": "/etc/passwd",
        "timestamp": 1234567
    },
    {
        "hostkey": "SHA=305658693b94e003e765956f1609731419cbc0e5c9caa09e230df5e005f1f283",
        "path": "/etc/group",
        "timestamp": 1234567,
        "diff": {
            "type": "add",
            "line": 5,
            "value": "sambashare:x:124:a10021"
        }
    },
    ...
]

@end verbatim


@c *****************************************************
@c * CHAPTER
@c *****************************************************
@node Monitoring extensions, File Access Control Lists, REST API, Top
@chapter Monitoring extensions

CFEngine 3 Enterprise incorporates a lightweight monitoring agent, whose aim
is to provide meaningful performance data about systems, in a scalable
fashion.  CFEngine 3 Enterprise does not aim to replace specialized
rapid-update monitoring and alarm systems; it provides a context-aware
summary of current state that is always displayed in relation to
previous system behavior, for comparison. The aim is to offer useful
analytics rather than jump-to alarms.

CFEngine's monitoring component @code{cf-monitord} records a number of
performance data about the system by default. These include process
counts, service traffic, load average and CPU utilization and
temperature when available.  In the Community Edition, data are
only collected and stored for personal use, but users have to work to see
results.  CFEngine 3 Enterprise improves on this in three ways.

@itemize

@item Data collected from the monitoring system are integrated into
the aggregate knowledge console.

@item It adds a three year life-cycle trend summary, based on
`shift'-averages.

@item It adds customizable promises to monitor or
log specific highly specific user data through the generic promise
interface.

@end itemize

The end result is to display time series traces of system performance, like the
above mentioned values, and customized logs feeding custom-defined
reports.


@menu
* Integration of monitoring with knowledge base::  
* Long term trends::            
* Custom promises to measure::  
* Uses for custom monitoring::  
@end menu


@c ----------------------------------------------------
@node  Integration of monitoring with knowledge base, Long term trends, Monitoring extensions, Monitoring extensions
@section Integration of monitoring with knowledge base

CFEngine 3 Enterprise integrates monitoring reports with the automated base
knowledge to provide self-analysis and simple summary reporting;
the Mission Portal shows important status summaries and allow users to drill down to specific reporting data.

@center @image{img-status,15cm,,Integrated Monitoring,png}

Detailed time-series views can be collected and collated, providing
honest and accurate data that allow you to gauge your own confidence
level in system performance.  Unlike most monitoring solutions,
CFEngine shows you its own confidence in the measurements taken. It
takes a finite amount of time to measure and transport data from
systems to the knowledge console. That time also provides information
about system performance. CFEngine always promises to tell you how old
data are and how confident it is in the values.

@image{img-vitalsviewer,15cm,,Integrated Monitoring,png}


@c ------------------------------------------------------
@node  Long term trends, Custom promises to measure, Integration of monitoring with knowledge base, Monitoring extensions
@section Long term trends

CFEngine normally operates with time-series data represented
in two forms:

@itemize
@item A weekly average, plotted on a periodogram, showing performance now in relation
to the same time of week in previous weeks. After about a month data are forgotten
to ensure a sufficient rate of adaptation to new patterns.
@item The past four hours in high resolution.
@end itemize

CFEngine 3 Enterprise adds quarter day averages of recorded time-series which go back three
years in time. Three years is considered to be the lifetime of a computer.
Summaries of the detailed performance are summarized by flat averages for
a four-shift day:
@itemize
@item @b{Night shift}: from midnight 00:00 to 06:00
@item @b{Morning shift}: from 06:00 to 12:00
@item @b{Afternoon shift}: from 12:00 to 18:00
@item @b{Evening shift}: from 18:00 to 00:00
@end itemize



@c ------------------------------------------------------
@node  Custom promises to measure, Uses for custom monitoring, Long term trends, Monitoring extensions
@section Custom promises to measure

CFEngine 3 Enterprise adds a new promise type in bundles for the monitoring
agent. These are written just like all other promises within a bundle
destined for the agent concerned. In this case:

@verbatim
bundle monitor watch

{
measurements:

  # promises ...

}

@end verbatim

@menu
* Extraction strings and logging::  
* Extracting one-off numerical data::  
* Extraction to list variable::  
@end menu


@c ------------------------------------------------------
@node  Extraction strings and logging, Extracting one-off numerical data, Custom promises to measure, Custom promises to measure
@subsection Extraction strings and logging

Let's take a generic example. Suppose we have a file of nonsense  @file{/tmp/testmeasure}
and we want to extract some information that we call a `blonk'
from the file. A blonk is always on the second line of this file following
a prefix `Blonk blonk '. We would get the value like this:

@verbatim

  "/tmp/testmeasure"

      handle => "blonk_watch",
      stream_type => "file",
      data_type => "string",
      history_type => "log",
      units => "blonks",
      match_value => find_blonks,
      action => sample_min("10");

@end verbatim

This promise body has several attributes.

@table @code
@item handle
It is essential to give measurement promises handles, as these are used to label the
log files that will store the values.

@item stream_type
Tells us that we are reading from what the system considered to be a regular file
on the file-system.

@item data_type
This says that data are to be treated as text with no other meaning.

@item history_type
This tells us that we want to log the values with a time stamp.

@item units
This string is used in documentation to explain the measurement units of this result.

@item match_value
This is a body reference that represents the algorithm by which we extract data from the file.

@item action
This is the generic action parameter that may be added to all promises. We use it
here to limit the sample rate of this promise; @code{cf-monitord} samples by default
at a rate of once per 2.5 minutes.
@end table

The matching body uses a method for selecting the correct line, and a way
for extracting a pattern from the line. In every case the value extracted
is described  by using a regular expression @i{back-reference}, i.e.
a parenthesized expression  within a regular expression. The expression should
match the entire line and should contain exactly one parenthesis.

@verbatim
body match_value find_blonks
{
select_line_number => "2";
extraction_regex => "Blonk blonk ([blonk]+).*";
}
@end verbatim

The sampling rate is controlled by using the generic @code{action} constraint.
@verbatim
body action sample_min(x)
{
ifelapsed => "$(x)";
expireafter => "$(x)";
}
@end verbatim


@c ------------------------------------------------------
@node  Extracting one-off numerical data, Extraction to list variable, Extraction strings and logging, Custom promises to measure
@subsection Extracting one-off numerical data

In this example we extract an integer value from an existing file.
Notice that CFEngine samples the process table during @code{processes}
promises so you might be able to save a new execution of a
shell command and use the cached data, depending on your need
for immediacy. It is always good practice to limit the system
load incurred by monitoring.

@verbatim
  # Test 2 - follow a special process over time
  # using CFEngine's process cache to avoid re-sampling

   "/var/cfengine/state/cf_rootprocs"

      handle => "monitor_self_watch",
      stream_type => "file",
      data_type => "int",
      history_type => "static",
      units => "kB",
      match_value => proc_value(".*cf-monitord.*",

         "root\s+[0-9.]+\s+[0-9.]+\s+[0-9.]+\s+[0-9.]+\s+([0-9]+).*");

@end verbatim

This match body selects a line matching a particular regular expression
and extracts the 6th column of the process table. The regular expression
skips first the root string and then five numerical values.
The value is extracted into a one-off value

@verbatim
body match_value proc_value(x,y)
{
select_line_matching => "$(x)";
extraction_regex => "$(y)";
}
@end verbatim


@c ------------------------------------------------------
@node  Extraction to list variable,  , Extracting one-off numerical data, Custom promises to measure
@subsection Extraction to list variable


In this example we discover a list of disks attached to the system.
@verbatim
  # Test 3, discover disk device information

  "/bin/df"

      stream_type => "pipe",
      data_type => "slist",
      history_type => "static",
      units => "device",
      match_value => file_system,
      action => sample_min("480"); # this is not changing much!

@end verbatim

@verbatim

body match_value file_system
{
select_line_matching => "/.*";
extraction_regex => "(.*)";
}

@end verbatim


@c ------------------------------------------------------
@node  Uses for custom monitoring,  , Custom promises to measure, Monitoring extensions
@section Uses for custom monitoring

Unlike most other monitoring tools that use heavy-weight scripting
languages to extract data, often running many processes for each
measurement, CFEngine is a lightweight probe, using file interfaces
and regular expressions. Thus its impact on the
system is minimal. The possibilities for using this are therefore
extremely broad:

@itemize
@item Extracting accounting data from systems for charge-back.
This could be useful in cloud scenarios.
@item Discovering memory leaks.
@item Looking for zombie processes relating to specific software.
@item Logging up-time.
@item System class-dependent discovery and extraction of any kind of text
for insertion into a CMDB.
@end itemize


@c *****************************************************
@c * CHAPTER
@c *****************************************************
@node  File Access Control Lists, Server extensions, Monitoring extensions, Top
@chapter File Access Control Lists

@menu
* ACL Introduction::                
* File ACL example::            
* CFEngine 3 Generic ACL Syntax::  
* POSIX ACL type::              
* NT ACL type::                 
@end menu


@c ------------------------------------------------------
@node  ACL Introduction, File ACL example, File Access Control Lists, File Access Control Lists
@section ACL Introduction

Access Control Lists (ACL) allow for a more fine-grained access control on
file system objects than standard Unix permissions. In spite of the success
of the POSIX model's simplicity the functionality is limited.

File permission security is a subtle topic. Users should take care
when experimenting with ACLs as the results can often be
counter-intuitive. In some cases the functioning of a system can be
compromised by changes of access rights.

Not all file systems support ACLs. In Unix systems there is a plethora
of different file system types, which have different models of ACLs.
Be aware that the mount-options for a file-system may affect the ACL
semantics.

@cartouche
@i{Note that when adding a user to a group, this will not have any
effect until the next time the user logs in on many operating
systems.}
@end cartouche

As CFEngine works across multiple platforms and needs to support ACLs
with different APIs, a common ACL syntax has been abstracted to add a
layer of portability. This is a specific feature of CFEngine, not of
the host systems. A generic syntax ensures that the ACLs that are
commonly needed can be coded in a portable fashion. CFEngine 3 Enterprise's
ACL model is translated into native permissions for implementation;
CFEngine does not interfere with native access mechanisms in any way.
The CFEngine ACL syntax is similar to the POSIX ACL syntax, which is
supported by BSD, Linux, HP-UX and Solaris.

CFEngine also allows you to specify platform-dependent ACLs. Of
course, these ACLs will only work on the given platform, and must
therefore be shielded with classes that select the appropriate model
within the promise body.

Currently, CFEngine 3 Enterprise supports the following ACL APIs and operating
systems.

@multitable @columnfractions .3 .3
@headitem ACL type @tab Operating system
@item NTFS @tab Windows Server 2003, 2008
@item POSIX @tab Linux
@end multitable


@c ------------------------------------------------------
@node  File ACL example, CFEngine 3 Generic ACL Syntax, ACL Introduction, File Access Control Lists
@section File ACL example

The form of a CFEngine files promise that uses ACLs is as follows:
@verbatim

#
# test_acl.cf
#

body common control
{
bundlesequence => { "acls" };
}

#########################################

bundle agent acls

{
files:

  "/office/shared"

    acl => template;
}

#########################################

body acl template

{
acl_method => "overwrite";
acl_directory_inherit => "parent";

 linux|solaris::

  acl_type => "posix";

  aces => {
          "user:*:rw",
          "user:root:rw",
          "group:*:r",
          "mask:rwx",
          "all:r"
          };

 windows::

  acl_type => "ntfs";

  aces => {
          "user:Administrator:rw(po)",
          "all:r"
          };
}

@end verbatim

@menu
* Concepts::                    
* Entity types::                
* Owners::                      
* Changing owner::              
* Permissions::                 
* Deny permissions::            
* Changing permissions::        
* Effective permissions::       
* Inheritance::                 
@end menu


@c ------------------------------------------------------
@node  Concepts, Entity types, File ACL example, File ACL example
@subsection Concepts

As mentioned, there are many different ACL APIs. For example, the
POSIX draft standard, NTFS and NFSv4 have different and incompatible
ACL APIs. As CFEngine is cross-platform, these differences should, for
the most usual cases, be transparent to the user. However, some
distinctions are impossible to make transparent, and thus the user
needs to know about them.

We will explore the different concepts of ACL implementations that are
critical to understanding how permissions are defined and enforced in
the different file systems. As a running example, we will consider
NTFS ACLs and POSIX ACLs, because the distinction between these ACL
APIs is strong.


@c ------------------------------------------------------
@node  Entity types, Owners, Concepts, File ACL example
@subsection Entity types

All ACL APIs support three basic entity types: user, group and
all. User and group are simply users and groups of the system, where a
group may contain multiple users. all is all users of the system, this
type is called "other" in POSIX and "Everyone" in NTFS.


@c ------------------------------------------------------
@node  Owners, Changing owner, Entity types, File ACL example
@subsection Owners

All file system objects have an owner, which by default is the entity
that created the object. The owner can always be a user. However, in
some file systems, groups can also be owners (e.g. the
"Administrators" group in NTFS). In some ACL APIs (e.g POSIX),
permissions can be set explicitly for the owner, i.e. the owner has an
independent ACL entry.


@c ------------------------------------------------------
@node  Changing owner, Permissions, Owners, File ACL example
@subsection Changing owner

It is generally not possible for user A to set user B as the
owner of a file system object, even if A owns the object. The
superuser ("root" in POSIX, "Administrator" in NTFS) can however
always set itself as the owner of an object. In POSIX, the superuser
may in fact set any user as the owner, but it NTFS it can only take
ownership.


@c ------------------------------------------------------
@node  Permissions, Deny permissions, Changing owner, File ACL example
@subsection Permissions

An entity can be given a set of permissions on a file system object
(e.g. read and write). The data structure holding the permissions for
one entity is called an "Access Control Entry" (ACE). As many users
and groups may have sets of permissions on a given object, multiple
Access Control Entries are combined to an Access Control List, which
is associated with the object.

The set of available permissions differ with ACL APIs. For example,
the "Take Ownership" permission in NTFS has no equivalent in
POSIX. However, for the most common situations, it is possible to get
equivalent security properties by mapping a set of permissions in one
API to another set in a second API.

There are however different rules for the access to the contents of a
directory with no access. In POSIX, no sub-objects of a directory with
no access can be accessed. However, in NTFS, sub-objects that the entity
has access rights to can be accessed, regardless of whether the entity
has access rights to the containing directory.


@c ------------------------------------------------------
@node  Deny permissions, Changing permissions, Permissions, File ACL example
@subsection Deny permissions

If no permissions are given to a particular entity, the entity will be
denied any access to the object. But in some file systems, like NTFS,
it is also possible to explicitly deny specific permissions to
entities. Thus, two types of permissions exist in these systems: allow
and deny.

It is generally good practice to design the ACLs to specify who is
allowed to do some operations, in contrary to who is not allowed to do
some operations, if possible. The reason for this is that describing
who is not allowed to do things tend to lead to more complex
rules and could therefore more easily lead to mis-configurations and
security holes. A good rule is to only define that users should not be
able to access a resource in the following two scenarios:

@itemize
@item Denying access to a subset of a group which is allowed access
@item Denying a specific permission when a user or a group has full access
@end itemize

If you think about it, this is the same principle that applies to
firewall configuration: it is easier to white-list, specify who should
have access, than to blacklist, specify who should not have access. In
addition, since CFEngine is designed to be cross-platform and some ACL
permissions are not available on all platforms, we should strive to
keep the ACLs as simple as possible. This helps us avoid surprises
when the ACLs are enforced by different platforms.


@c ------------------------------------------------------
@node  Changing permissions, Effective permissions, Deny permissions, File ACL example
@subsection Changing permissions

Generally, only the owner may change permissions on a file system
object. However, superusers can also indirectly change permissions by
taking ownership first. In POSIX, superusers can change permissions
without taking ownership. In NTFS, either ownership or a special
permission ("Change Permissions") is needed to alter permissions.


@c ------------------------------------------------------
@node  Effective permissions, Inheritance, Changing permissions, File ACL example
@subsection Effective permissions

Unfortunately, even though two ACL APIs support all the permissions
listed in an ACL, the ACL may be interpreted differently. For a given
entity and object with ACL, there are two conceptually different ways
to interpret which permissions the entity obtains: ACE precedence and
cumulative ACL.

@c TODO: create figure of example?
For example, let @samp{alice} be a user of the group
@samp{staff}. There is an ACL on the file @file{schedule}, giving
@samp{alice} write permission, and the group @samp{staff} read
permission. We will consider two ways to determine the effective
permissions of @samp{alice} to @file{schedule}.

Firstly, by taking the most precise match in the ACL, @samp{alice} will be
granted write permission only. This is because an ACE describing @samp{alice}
is more precise than an ACE describing a group @samp{alice} is member
of. However, note that some ACEs may have the same precedence, like
two ACEs describing permissions for groups @samp{alice} is member of. Then,
cumulative matching will be done on these ACEs (explained next). This
is how POSIX does it.

Secondly, we can take the cumulative permissions, which yields a user
permissions from all the ACE entries with his user name, groups he is
member of or the ACE entry specifying all users. In this case,
@samp{alice} would get read and write on @file{schedule}. NTFS
computes the effective permissions in this way.


@c ------------------------------------------------------
@node  Inheritance,  , Effective permissions, File ACL example
@subsection Inheritance

 @c TODO: Correct to inherit to someone ?

Directories have ACLs associated with them, but they also have the
ability to inherit an ACL to sub-objects created within them. POSIX
calls the former ACL type "access ACL" and the latter "default ACL",
and we will use the same terminology.

@c TODO: Create tool to output effective permissions if ACL is applied ?


@c ------------------------------------------------------
@node  CFEngine 3 Generic ACL Syntax, POSIX ACL type, File ACL example, File Access Control Lists
@section CFEngine 3 Generic ACL Syntax

@c FIXME: TODO: Say which OS's we are supporting, and which ACL types
@c we are supporting on them.

The CFEngine 3 ACL syntax is divided into two main parts, a generic
and an API specific (native). The generic syntax can be used on any
file system for which CFEngine supports ACLs, while the native syntax
gives access to all the permissions available under a particular ACL
API.

An ACL can contain both generic and native syntax. However, if it
contains native syntax, it can only be enforced on systems supporting
the given ACL API. Thus, only the generic syntax is portable.

Note that even though the same generic ACL is set on two systems with
different ACL APIs, it may be enforced differently because the ACE
matching algorithms differ. For instance, as discussed earlier, NTFS
uses cumulative matching, while POSIX uses precedence
matching. CFEngine cannot alter the matching algorithms, and
simulating one or the other by changing ACL definitions is not
possible in all cases, and would probably lead to confusion. Thus, if
an ACL is to be used on two systems with different ACL APIs, the user
is encouraged to check that any differences in matching algorithms do
not lead to mis-configurations.

The CFEngine generic ACL syntax explained next, and native syntax is
described in following sections.

@cartouche
@smallexample
body acl acl_alias:
@{
acl_type              => "@var{generic}"/"@var{ntfs}"/"@var{posix}";
acl_method            => "@var{append}"/"@var{overwrite}";
acl_directory_inherit => "@var{nochange}"/"@var{clear}"/"@var{parent}"/"@var{specify}";
aces                  => @{
                          "user:uid:mode[:perm_type]", ...,
                          "group:gid:mode[:perm_type]", ...,
                          "all:mode[:perm_type]"
                         @};
specify_inherit_aces  => @{
                          "user:uid:mode[:perm_type]", ...,
                          "group:gid:mode[:perm_type]", ...,
                          "all:mode[:perm_type]"
                         @};
@}
@end smallexample
@end cartouche

@itemize
@item @code{acl_alias} is the name of the specified ACL. It can be any
  identifier containing alphanumeric characters and underscores. We
will use this name when referring to the ACL.

@item @code{acl_type} (optional) specifies the ACL API used to
describe the ACL. It defaults to @code{generic}, which allows only
CFEngine generic ACL syntax, but is valid on all supported
systems. @code{acl_type} only needs to be specified if native
permissions are being used in the ACL (see @code{nperms} below). If
@code{acl_type} is set to anything other than @code{generic}, the
system on which it is enforced must support this ACL API.

@item @code{acl_method} (optional) can be set to either
  @code{append} or @code{overwrite}, and defaults to
  @code{append}. Setting it to @code{append} only adds or modifies the
  ACEs that are specified in @code{aces} (and
  @code{specify_inherit_aces}, see below). If set to
  @code{overwrite}, the specified ACL will completely replace the
  currently set ACL. All required fields must then be set in the
  specified ACL (e.g. @code{all} in POSIX), see the following sections
  describing the supported native APIs.

@c TODO: Support acl_method:append for specify_inherit_aces independently?

@item @code{acl_directory_inherit} (optional) specifies the ACL of
  newly created sub-objects. Only valid if the ACL is set on a
directory. On directories, @code{nochange} is the default and
indicates that the ACL that is currently given to newly created child
objects is left unchanged. If set to @code{clear}, no ACL will be
inherited, but the file system specifies a default ACL, which varies
with the file system (see the following sections on the supported ACL
APIs). @code{parent} indicates that the ACL set in @code{aces} (see
below) should be inherited to sub-objects.  If set to @code{specify},
@code{specify_inherit_aces} specifies the inherited ACL, and
@code{acl_method} applies for @code{specify_inherit_aces} too.

@item @code{aces} is a list of access control entries. It is parsed
  from left to right, and multiple entries with the same entity-type
  and id is allowed. This is necessary to specify permissions with
  different @code{perm_type} for the same entity (e.g. to allow read
  permission but explicitly deny write).

@item @code{specify_inherit_aces} (optional) is a list of access control
  entries that are set on child objects. It is also parsed from left
  to right and allows multiple entries with same entity-type and
  id. Only valid if @code{acl_directory_inherit} is set to
  @code{specify}.

@item @code{user} indicates that the line applies to a user specified
  by the user identifier @code{uid}. @code{mode} is the permission
  mode string.

@item @code{group} indicates that the line applies to a group specified
  by the group identifier @code{gid}. @code{mode} is the permission
  mode string.

@item @code{all} indicates that the line applies to every
  user. @code{mode} is the permission mode string.

@item @code{uid} is a valid user name for the system and
  cannot be empty. However, if @code{acl_type} is @code{posix},
@code{uid} can be set to * to indicate the user that owns the file
system object.

@item @code{gid} is a valid group name for the system and
  cannot be empty. However, if @code{acl_type} is @code{posix},
@code{gid} can be set to * to indicate the file group.

@item @code{mode} is one or more strings
  @code{op}|@code{gperms}|(@code{nperms}); a concatenation of @code{op},
  @code{gperms} and optionally (@code{nperms}), see below, separated
  with commas (e.g. +rx,-w(s)). @code{mode} is parsed from left to
  right.
@c TODO: include support for @code{fullaccess}, @code{noaccess},
@c and @code{remove}

@item @code{op} specifies the operation on any existing permissions,
  if the specified ACE already exists. @code{op} can be =, empty, + or
  -. = or empty sets the permissions to the ACE as stated, + adds and
  - removes the permissions from any existing ACE.

@item @code{nperms} (optional) specifies ACL API specific
  (native) permissions. Only valid if @code{acl_type} is not
  @code{generic}. Valid values for @code{nperms} varies with different
  ACL types, and are specified in subsequent sections.

@item @code{perm_type} (optional) can be set to either @code{allow} or
  @code{deny}, and defaults to @code{allow}. @code{deny} is only valid
  if @code{acl_type} is set to an ACL type that support deny
  permissions.

@item @code{gperms} (generic permissions) is a concatenation of zero
  or more of the characters shown in the table below. If left empty,
  none of the permissions are set.
@end itemize

@multitable @columnfractions .05 .2 .30 .4
@headitem Flag @tab Description @tab Semantics on file @tab Semantics on directory

@item @code{r} @tab Read @tab Read data, permissions, attributes @tab Read
directory contents, permissions, attributes
@item @code{w} @tab Write @tab Write data @tab Create, delete, rename sub-objects
@item @code{x} @tab Execute @tab Execute file @tab Access sub-objects
@end multitable


Note that the @code{r} permission is not necessary to read an object's
permissions and attributes in all file systems (e.g. in POSIX, having
@code{x} on its containing directory is sufficient).


@c ------------------------------------------------------
@menu
* Generic syntax examples::     
@end menu

@node  Generic syntax examples,  , CFEngine 3 Generic ACL Syntax, CFEngine 3 Generic ACL Syntax
@subsection Generic syntax examples

@verbatim
body common control
{
bundlesequence => { "acls" };
}

bundle agent acls
{
files:
  "/office/schedule"
    acl => small;

  "/office/audit_dir"
    acl => dirinherit;
}

body acl small
{
aces => {"user:alice:w", "group:staff:r", "all:"};
}

body acl dirinherit
{
acl_directory_inherit => "parent";
aces => {"user:alice:+w,-x", "user:bob:+r,-w", "group:staff:=rx", "all:-w"};
}
@end verbatim
See the following sections on native ACL types for more examples.


@c  TODO: include support for the following as mode
@c  Keywords:
@c  remove              = setting mode = remove removes any existing
@c                ACE with the given user or group. Only valid if
@c                    @code{method}:@code{overwrite}.

@c  fullaccess  = setting mode = fullaccess grants every permission
@c                    supported by the file system to the given entity
@c                    (user, group, all). The owner of the object and
@c                    properties like suid, sgid and
@c                sticky are left unchanged.

@c  noaccess    = setting mode = noaccess denies every permission for
@c                    the entity (user, group, all). The entity is left
@c                    with no access rights to the object. Note that the
@c                    entity might nonetheless be able to change the
@c                    permissions (e.g. by being the owner of the object
@c                    or a superuser).




@c TODO: Define user, group, mask and other to u, g, m, o instead / also?
@c TODO: Examples: ACLs, console output, screen-shots



@c ------------------------------------------------------
@node  POSIX ACL type, NT ACL type, CFEngine 3 Generic ACL Syntax, File Access Control Lists
@section POSIX ACL type


@c ------------------------------------------------------
@menu
* POSIX-specific ACL syntax::   
* Generic syntax mapping::  
* POSIX ACL examples::    
@end menu

@node  POSIX-specific ACL syntax, Generic syntax mapping, POSIX ACL type, POSIX ACL type
@subsection POSIX-specific ACL syntax

@b{Native permissions}
The valid values for @code{nperms} in POSIX are @code{r},@code{w}, and
@code{x}. These are in fact the same as the generic permissions, so
specifying them as generic or native gives the same effect.

@b{File owner and group}
A user-ACE with uid set to * indicates file object owner. A group-ACE
with gid set to * indicates file group.

@b{mask} mask can be specified as a normal ACE, as
@code{mask:mode}. mask specifies the maximum permissions that are
granted to named users (not owning user), file group and named
groups. mask is optional, if it is left unspecified it will will be
computed as the union of the permissions granted to named users, file
group and named groups (see acl_calc_mask(3)).

@b{Required ACEs} POSIX requires existence of an ACE for the file
owner, (@code{user:*:mode}), the file group (@code{group:*:mode}),
other (@code{all:mode}) and mask (@code{mask:mode}). As mentioned,
CFEngine automatically creates a mask-ACE, if missing. However, if
@code{method} is set to @code{overwrite}, the user must ensure that
the rest of the required entries are specified.


@c ------------------------------------------------------
@node  Generic syntax mapping, POSIX ACL examples, POSIX-specific ACL syntax, POSIX ACL type
@subsection Generic syntax mapping

@b{Entity types}
All entity types in the generic syntax are mapped to the corresponding
entity types with the same name in POSIX, except @code{all} which
corresponds to @code{other} in POSIX.

@b{Generic permissions}

As shown in the table below, @code{gperms} is mapped straightforward
from generic to POSIX permission flags.

@multitable @columnfractions .3 .3
@headitem Generic flag  @tab POSIX flag
@item @code{r} @tab @code{r}
@item @code{w} @tab @code{w}
@item @code{x} @tab @code{x}
@end multitable


@b{Inheritance} POSIX supports @code{acl_directory_inherit} set to
@code{specify}. The @code{specify_inherit_aces} list is then set as the
default ACL in POSIX (see acl(5)).

If @code{acl_directory_inherit} is set to @code{parent}, CFEngine
copies the access ACL to the default ACL. Thus, newly created objects
get the same access ACL as the containing directory.

@code{acl_directory_inherit} set to @code{clear} corresponds to no
POSIX default ACL. This results in that newly created objects get ACEs
for owning user, group and other. The permissions are set in
accordance with the mode parameter to the creating function and the
umask (usually results in 644 for files and 755 for directories).

@b{Further reading} The manual page @code{acl(5)} contains much
information on POSIX ACLs, including the access check algorithm. In
particular, this shows that POSIX uses ACE precedence matching, and
exactly how it is done. Operating systems usually bundle tools for
manipulating ACLs, for example @code{getfacl(1)} and
@code{setfacl(1)}.


@node POSIX ACL examples, , Generic syntax mapping, POSIX ACL type
@subsection POSIX ACL examples
@verbatim
body common control
{
bundlesequence => { "acls" };
}

bundle agent acls
{
files:

  "/office/timetable"
    acl => nativeperms;

  "/office/user_dir"
    acl => specifyinherit;
}

body acl nativeperms
{
acl_type => "posix";
aces => {"user:alice:r(w)", "user:root:=(rwx)",
         "group:staff:-r(x)", "all:-(w)", "mask:(rx)"};
}

body acl specifyinherit
{
acl_type => "posix";
acl_method => "overwrite";
acl_directory_inherit => "specify";
aces => {"user:*:rwx", "group:*:rx", "user:alice:rwx",
         "user:root:rx", "group:staff:r", "all:rx"};
specify_inherit_aces => {"user:*:", "group:*:", "all:"};
}
@end verbatim


@c ------------------------------------------------------
@node  NT ACL type,  , POSIX ACL type, File Access Control Lists
@section NT ACL type


@c ------------------------------------------------------
@menu
* NT-specific ACL syntax::      
@end menu

@node  NT-specific ACL syntax,  , NT ACL type, NT ACL type
@subsection NT-specific ACL syntax

@b{Native permissions}
NTFS supports fourteen so-called special file permissions. However, we
do not consider the @code{Synchronize} permission because it is used
for a different purpose than the other permissions. In order to give
access to the thirteen relevant permissions, CFEngine defines a native
permission flag for each of them. This one-to-one mapping is as
follows.

@multitable @columnfractions .40 .20
@headitem NTFS Special Permission @tab CFEngine nperm
@item Execute File / Traverse Folder @tab x
@item Read Data / List Folder @tab r
@item Read Attributes @tab t
@item Read Extended Attributes @tab T
@item Write Data / Create Files @tab w
@item Append Data / Create Folders @tab a
@item Write Attributes @tab b
@item Write Extended Attributes @tab B
@item Delete Sub-folders and Files @tab D
@item Delete @tab d
@item Read Permissions @tab p
@item Change Permissions @tab c
@item Take Ownership @tab o
@end multitable

The semantics of these special permissions can be found in the
references for further reading below.


@b{Denying permissions}
NTFS supports setting @code{perm_type} to @code{deny} in addition to
@code{allow}, which is the default. This can for instance be used to
denying a user a particular permission that a group membership grants
him. It is important to note that the precedence of allow and deny
permissions is as follows:

@enumerate
@item Explicit Deny
@item Explicit Allow
@item Inherited Deny from parent
@item Inherited Allow from parent
@item Inherited Deny from grandparent
@item Inherited Allow from grandparent
@item ...
@end enumerate

Thus, the closer the permission is to the object in the directory
path, the greater precedence it is given.

An important point here is that even though a user is denied access in
a parent directory and this permission is inherited, but one of the
groups he is member of is explicitly allowed access to a file in that
directory, he is actually allowed to access the file.


@b{Ownership}
In NTFS, the default owner is the user who is currently logged on. The
only exceptions occur when the user is a member of either the
@samp{Administrators} group or the @samp{Domain Admins} group.

Owners of NTFS objects can allow another user to take ownership by
giving that user Take Ownership permission. Owners can also give other
users the Change Permissions flag. In addition, members of the
@samp{Administrator} group can always take ownership. It is never
possible to give ownership of an object to a user, but members of
the @samp{Administrator} group can give ownership to that group.


@subsection Generic syntax mapping

@b{Entity types}
The three entity types of NTFS are called user, group and
Everyone. The user and group entity types in NTFS are mapped to the
user and group entity types in CFEngine. Everyone is mapped to all in
CFEngine.

@b{Generic permissions}
For NTFS, CFEngine maps the @code{gperms} to @code{nperms} as
follows.

@multitable @columnfractions .3 .3
@headitem Generic flag  @tab Native flags
@item @code{r} @tab @code{rtTp}
@item @code{w} @tab @code{wabB}
@item @code{x} @tab @code{x}
@end multitable

The rationale for this mapping is discussed next.

NTFS groups the thirteen special permissions to create five sets of
permissions:
@itemize
@item Read
@item Read & Execute
@item Write
@item Modify
@item Full Control
@end itemize
In addition, we have the List Folder Contents set, which is equivalent
to the Read & Execute set but is only available to- and inherited by
directories. The Full Control set is unsurprisingly all the thirteen
special permissions. An overview of the NTFS mapping of special
permissions to sets is given in the references stated as further
reading below. The NTFS permission sets can be expressed in CFEngine
syntax as follows.

@multitable @columnfractions .3 .4
@headitem NTFS sets  @tab CFEngine gperms|(nperms)
@item @code{Read} @tab @code{r}
@item @code{Write} @tab @code{w}
@item @code{Read & Execute} @tab @code{rx}
@item @code{Modify} @tab @code{rwx(d)}
@item @code{Full Control} @tab @code{rwx(dDco)}
@end multitable


@b{Inheritance}
@code{acl_directory_inherit} set to @code{clear} disables
inheritance, such that child objects get a default ACL specified by
the operating system, namely Full control for the file object creator and
@code{SYSTEM} accounts.


@b{POSIX compatibility}
Be aware that setting @code{gperms} to @samp{rwx} on directories is
more restrictive in NTFS than in POSIX ACLs. This is because NTFS does
not allow deletion of objects within a directory without a Delete
Sub-folders and Files permission on the directory (or a Delete
permission on the object itself), while in POSIX, @samp{rwx} on the
directory is sufficient to delete any file or directory within it
(except when the sticky-flag is set on the directory). Thus, on
directories, the NTFS-equivalent to POSIX @code{gperms} set to
@samp{rwx} is @samp{rwx(D)}. However, for files, @samp{rwx} is
equivalent in POSIX and NTFS semantics.

In POSIX ACLs, there is no explicit delete permission, but the
execute, write and sticky permissions on the containing directory
determines if a user has privileges to delete. In POSIX, the owner and
root can change permissions, while usually only the root may change
the ownership, so there is no direct equivalent to the Change
Permission and Take Ownership in POSIX.


@b{Further reading}
A description of the fourteen NTFS permission and the mapping of these
into sets is given at @url{http://support.microsoft.com/kb/308419}.


@subsection NT ACL examples

@verbatim
body common control
{
bundlesequence => { "acls" };
}

bundle agent acls
{
files:

  "C:\Program Files\Secret Program"
    acl => restrictive;

  "D:\Shared"
    acl => sharespace;
}

body acl restrictive
{
acl_type => "ntfs";
acl_method => "overwrite";
acl_directory_inherit => "parent";
aces => {"user:Administrator:r"};
}

body acl sharespace
{
acl_type => "ntfs";
acl_method => "overwrite";
acl_directory_inherit => "specify";
aces => { "user:Administrator:rwx(dDco)",
          "group:Hackers:rwx(dDco):deny",
          "all:rw" };
specify_inherit_aces => {"user:Administrator:r"};
}
@end verbatim


@c *****************************************************
@c * CHAPTER
@c *****************************************************
@node  Server extensions, Content-Driven Policies, File Access Control Lists, Top
@chapter Server extensions

CFEngine 3 Enterprise adds a simple server extension to the Community Edition
server, namely the ability to encode data directly in policy.
This feature is useful for distributing password hashes
to systems.

@menu
* Server access resource type::  
* Function remotescalar::  
* Example remote scalar lookup::  
@end menu

@node  Server access resource type, Function remotescalar, Server extensions, Server extensions
@section Server access resource type

By default, access to resources granted by the server are
files. However, sometimes it is useful to cache @code{literal}
strings, hints and data in the server, e.g. the contents of variables,
hashed passwords etc for easy access. In the case of literal data, the
promise handle serves as the reference identifier for queries. Queries
are instigated by function calls by any agent.

@verbatim
access:

  "This is a string with a $(localvar) for remote collection"

        handle  => "test_scalar",
  resource_type => "literal",
        admit   => { "127.0.0.1" };

@end verbatim

The promise looks exactly like a promise for a file object, but the data
are literal and entered into the policy. This is a useful approach for
distributing password hashes on a need-to-know basis from a central location.
The server configuration file need not be distributed to any client, thus
only authorized systems will have access to the hashes.


@node  Function remotescalar, Example remote scalar lookup, Server access resource type, Server extensions
@section Function @code{remotescalar}

The client side of the literal look up function is:

@cartouche
@example

(string) remotescalar(@var{resource handle},@var{host/IP address},@var{encrypt});

@end example
@end cartouche

This function downloads a string from a remote server, using the promise handle
as a variable identifier.

@noindent @b{ARGUMENTS}:

@table @samp
@item resource handle
The name of the promise on the server side
@item host or IP address
The location of the server on which the resource resides.
@item encrypt
Whether to encrypt the connection to the server.
@smallexample
     true
     yes
     false
     no
@end smallexample
@end table

@node  Example remote scalar lookup,  , Function remotescalar, Server extensions
@section Example remote scalar lookup

@verbatim
########################################################
#
# Remote value from server connection to cf-serverd
#
########################################################

body common control

{
bundlesequence  => { "testbundle"  };

version => "1.2.3";
}

########################################################

bundle agent testbundle

{
vars:

 "remote" string => remotescalar("test_scalar","127.0.0.1","yes");

reports:

  linux::

    "Receive value $(remote)";
}

#########################################################
# Server config
#########################################################

body server control

{
allowconnects         => { "127.0.0.1" , "::1" };
allowallconnects      => { "127.0.0.1" , "::1" };
trustkeysfrom         => { "127.0.0.1" , "::1" };
allowusers            => { "mark" };
}

#########################################################

bundle server access_rules()

{
vars:

  "localvar" string => "literal string";

access:

  "This is a $(localvar) for remote access"

        handle  => "test_scalar",
  resource_type => "literal",
        admit   => { "127.0.0.1" };
}

@end verbatim

@ignore
@c *****************************************************
@c * CHAPTER
@c *****************************************************
@node  Environments and workflows, Virtualization, Server extensions, Top
@chapter Environments and workflows

@menu
* Environments in CFEngine 3 Enterprise::        
* Implementing workflows in CFEngine 3 Enterprise::  
@end menu

@node  Environments in CFEngine 3 Enterprise, Implementing workflows in CFEngine 3 Enterprise, Environments and workflows, Environments and workflows
@section Environments in CFEngine 3 Enterprise
@sp 1

CFEngine 3 Enterprise supports notion of `environments' -- named groups of hosts, like
`development', 'QA' and 'production' hosts.

Each environment gets
@itemize
@item Separate subdirectory `environment_<NAME>' for storing promises
@item Separate subdirectory `environment_<NAME>/cdp_inputs' for content-based policies
@item grouping of hosts belonging to environment in GUI
@end itemize

Default CFEngine 3 Enterprise policies group hosts into environments in bundle `common
environments'. This bundle defines
@itemize
@item `environments.active' variable. This variable holds the name of environment for current host, and is used by other promises in CFEngine 3 Enterprise templates. This variable does not affect grouping in GUI.
@item global `environment_<NAME>' class. This class should be defined if given host belongs to the `<NAME>' environment. GUI groups hosts using this class.
@end itemize
Administrator may customize this bundle as needed, adding or removing
environments defined (CFEngine 3 Enterprise does not have any built-in environment
names), changing rules for hosts selection and making any other
modifications, the only requirement for environments feature to work
is keeping aforementioned variables and classes defined. Note that the
environment name 'any' is reserved.

Default rules expect file `environment_$(promises.active)/promises.cf'
to exist and to contain bundle `agent main', this bundle is included
last from main promises.cf and should implement/include/use any
environment-specific rules.

@node  Implementing workflows in CFEngine 3 Enterprise,  , Environments in CFEngine 3 Enterprise, Environments and workflows
@section Implementing workflows in CFEngine 3 Enterprise

Workflows are implemented easily with CFEngine 3 Enterprise, administrator starts with
defining necessary set of environments (usually those are
`development', `testing' and 'production'), then develops new
configuration in one enviroment, and promotes rules first to testing
and then to production environment.

Promotion of rules is performed by copying rules from one
environment's subdirectory to next one.
@end ignore


@c *****************************************************
@c * CHAPTER
@c *****************************************************
@node  Content-Driven Policies, Upgrading CFEngine 3 Enterprise, Server extensions, Top
@chapter Content-Driven Policies

In CFEngine 3 Nova 2.0, Content-Driven Policies (CDP) were introduced to make
policy management easier. In contrast to policies written in the
CFEngine language, these are semi-colon separated fields in a text
file that the user just fills with content. All the underlying
enforcement and reporting are taken care of automatically by CFEngine 3 Enterprise.

For example, to manage three Windows services, the following
services-CDP will suffice.

@verbatim
# masterfiles/cdp_inputs/service_list.txt

Dnscache;stop;fix;windows
ALG;start;warn;windows
RemoteRegistry;start;fix;Windows_Server_2008

@end verbatim

The meanings of the fields are different depending of the CDP-type,
but explained in the file header. With these three lines, we ensure
the correct status of three services on all our Windows machines and
are given specialized reports on the outcome. 

@c The Content-Driven Policy services report is shown below.

@c @image{cdp_services_report,15cm,,The Content-Driven Policy services report,png}


@section Benefits of Content-Driven Policies

As seen in the example above, Content-Driven Policies are easy to
write and maintain, especially for users unfamiliar with the CFEngine
language. They are designed to capture the essence of a specific,
popular use of CFEngine, and make it easier. For example, the services
Content-Driven Policy above has the following equivalent in the
CFEngine language.

@smallexample

bundle agent service_example
@{
services:

  "Dnscache"
    comment            => "Check services status of Dnscache",
    handle             => "srv_Dnscache_windows",
    service_policy     => "stop",
    service_method     => force_deps,
    action             => policy("fix"),
    ifvarclass         => "windows";

  "ALG"
    comment            => "Check services status of ALG",
    handle             => "srv_ALG_windows",
    service_policy     => "start",
    service_method     => force_deps,
    action             => policy("warn"),
    ifvarclass         => "windows";

  "RemoteRegistry"
    comment            => "Check services status of ALG",
    handle             => "srv_ALG_windows",
    service_policy     => "start",
    service_method     => force_deps,
    action             => policy("fix"),
    ifvarclass         => "Windows_Server_2008";

@}

@end smallexample

Writing this policy is clearly more time-consuming and error-prone. On
the other hand, it allows for much more flexibility than Content-Driven
Policies, when that is needed.

CFEngine provides Content-Driven Policies to cover mainstream
management tasks like the following.

@itemize
@item File change/difference management
@item Service management
@item Database management
@item Application / script management
@end itemize


@section Getting started
All the CDP input files are located in
@code{/var/cfengine/masterfiles/cdp_inputs} on your policy hub. CFEngine 3 Enterprise
is bundled with some examples, but ensure to @emph{edit the examples
before enabling them}.

To enable all the CDPs located in @code{cdp_inputs/}, open
@code{promises.cf} in your masterfiles directory. Remove the comment
(@code{#}) in front of the cdp entries in @code{bundlesequence} and
@code{inputs}, to make it look like the following.

@verbatim
bundlesequence => {
                  "def",
                  "cfengine_management",
                  "service_catalogue",
                  "cdp",
...

        inputs => {
...
                  "cdp_lib/cdp.cf",
                  "cdp_lib/cdp_acls.cf",
                  "cdp_lib/cdp_registry.cf",
                  "cdp_lib/cdp_file_changes.cf",
                  "cdp_lib/cdp_file_diffs.cf",
                  "cdp_lib/cdp_services.cf",
                  "cdp_lib/cdp_commands.cf",
...
@end verbatim

@c When the hosts start reporting back on the outcome of these policies (usually within 10 minutes), you can view the reports in the CDP reports viewer or from your Knowledge Map on the policy hub. 

@c Go to the @code{Status} tab, find the
@c Content-Driven Policies drop-down, select the CDP type
@c (e.g. @code{Services}) and click @code{Generate}.

@c @image{cdp_reports_generate,15cm,,Generating Content-Driven Policy reports,png}


@c *****************************************************
@c * CHAPTER
@c *****************************************************
@node  Upgrading CFEngine 3 Enterprise, Frequently Asked Questions, Content-Driven Policies, Top
@chapter Upgrading CFEngine 3 Enterprise

@cartouche
This is a beta release, no upgrade procedure provided. Please try out in a clean test environment.
@end cartouche
@ignore
Please follow the following instructions to the point to ensure a smooth upgrade. When upgrading the software from an earlier version, you should
upgrade the hub (policy server) machine first. Any other hosts
in your network that act as servers for encrypted copy operations
would preferably be upgraded next. This is because a stronger form of
encryption-hash is used in newer versions, which the older servers
cannot understand.

CFEngine packages its software in operating system compatible package
formats (RPM, DEB, PKG, MSI, etc). New packages are made available on the
cfengine.com website; these can be downloaded and installed
in the standard way.

@enumerate
@item Go to @url{https://cfengine.com/software} (login required)
@item Download the particular package for your operating systems
@end enumerate


@c ------------------------------------------------------
@menu
* Upgrade procedure for the hub (and policy)::           
* Upgrade procedure for the clients::           
* Upgrade procedure for the standard library::
* How can I do phased deployment?::  
* What if I have multiple operating system platforms?::  
* How do CFEngine 3 Enterprise policies update if I already have my own policy?::  
* How do I upgrade from CFEngine Community 3 to CFEngine 3 Enterprise?::
@end menu

@node Upgrade procedure for the hub (and policy), Upgrade procedure for the clients, Upgrading CFEngine 3 Enterprise, Upgrading CFEngine 3 Enterprise
@section Upgrade procedure for the hub (and policy)

The following is a general procedure to upgrade to CFEngine 3 Enterprise from earlier versions, please follow each step unless otherwise indicated. It is assumed that the packages are placed in the @file{/tmp} directory. To upgrade, start with the hub (policy server):

@enumerate
@item Stop all CFE processes
@verbatim
   $ /etc/init.d/cfengine3 stop
or
   $ for i in cf-execd cf-serverd cf-monitord cf-hub mongod; do pkill $i; done
@end verbatim

@item Upgrade cfengine-nova and cfengine-nova-expansion (in that order or simultaneously as below):@*
[RedHat/CentOS/SUSE]
@verbatim
   $ rpm -Uvh /tmp/cfengine-nova-3.0.x-y.x86_64.rpm /tmp/cfengine-nova-
   expansion-3.0.x-y.x86_64.rpm
@end verbatim
[Debian/Ubuntu]
@verbatim
   $ dpkg --install /tmp/cfengine-nova_3.0.x-y_x86_64.deb /tmp/cfengine-nova-
   expansion_3.0.x-y_x86_64.deb
@end verbatim

@item Remove Mongodb lock if present
@verbatim
   $ rm -f /var/cfengine/state/mongod.lock
@end verbatim

@item If you upgrade from CFEngine Enterprise 2.2.0 or 2.2.1, skip this step and go directly to step 7. For all other versions, CFEngine 3 Enterprise's dependencies have changed so we have to correct cf-twin (libgnutls and libmongo.c were updated)
@verbatim
   $ cp /var/cfengine/bin/cf-agent /var/cfengine/bin/cf-twin
@end verbatim

@item Copy the new CFE_ prefixed policy files to $(sys.workdir)/masterfiles (the files with a prefix "CFE_" are maintained by CFEngine, do not make changes to these, they are there to ensure that the Mission Portal works properly).
@verbatim
   $ cd /var/cfengine/share/NovaBase
   $ cp CFE_cfengine.cf CFE_knowledge.cf CFE_hub_specific.cf 
   /var/cfengine/masterfiles
@end verbatim

@page
Comments (for your information, no need to verify anything):
@itemize *
@item CFE_cfengine.cf
    - contains 
@verbatim
           bundle agent cfengine_management{}
@end verbatim
      and agent bundles for all CFEngine 3 Enterprise hosts.
@item CFE_knowledge.cf
    - mostly CFEngine 3 Enterprise Knowledge Map setup
@item CFE_hub_specific.cf
    - all necessary bundles to build the CFEngine 3 Enterprise HUB (policy server) is in this file
@item cfengine_stdlib.cf
    - the latest standard CFEngine bodies and bundles
@item If you are using CFEngine 3 Nova 2.0.1 or older: package_method has been updated, the Nova/Enterprise self-upgrade will not work properly on some systems. We strongly recommended to synchronise contents of the file before rolling out new packages to clients. (Please contact your sales representative or file a ticket in the CFEngine support system to help you out.)
@end itemize

@item Upgrade from Nova 2.0.x (skip this step if you run 2.1.x or higher): Modify contents in @file{/var/cfengine/masterfiles/promises.cf}
@itemize *
@item Correct input files in 
@verbatim
   "inputs => {}";
@end verbatim
@itemize -
@item Change cfengine.cf to CFE_cfengine.cf
@item Change knowledge.cf to CFE_knowledge.cf
@item Add CFE_hub_specific.cf
@item "inputs" should look similiar to this after changes:
@verbatim
   inputs => {
              "CFE_cfengine.cf",
              "CFE_hub_specific.cf",
              "CFE_knowledge.cf",
              "update.cf",
              "cfengine_stdlib.cf",
              "environment_$(environments.active)/promises.cf",
	      <YOUR OWN INPUT FILES>
             };
@end verbatim
@end itemize

@item Add "commercial_customer" class to 
@verbatim
   "bundle common def{}"

   classes:
    "commercial_customer" or => { "nova_edition"},
               comment => "Define a global class for CFEngine 3 Enterprise",
                handle => "common_def_classes_commercial_customer";
@end verbatim

@item Delete the whole 
@verbatim
   bundle agent cfengine_management{}
@end verbatim
(It was moved to CFE_hub_specific.cf)

@item Add @code{"track_value"} to @code{"body agent control}"
@verbatim
   any:
    track_value => "true";
@end verbatim
@end itemize

@item If you upgrade from CFEngine Enterprise 2.2.0 or 2.2.1 (skip this step for other versions), modify line 131 in @file{/var/cfengine/masterfiles/update.cf} (approximate location, please verify that you change the corresponding content) to ensure automatic updates of the CFEngine packages for the clients. The packages promises changed behavior in the new version and the following modification will make sure that the newest packages up to version 9.9.9 are installed. The original line looks like this:
@verbatim
   package_version => "1.0.0",         # Install new Nova anyway
@end verbatim
@noindent The modified line looks like this (i.e. changed the version number):
@verbatim
   package_version => "9.9.9",         # Install new Nova anyway
@end verbatim

@item If you run any Windows machines under CFEngine management (CFEngine Enterprise 2.2.x or CFEngine Nova 2.1.x), replace the packages promises in @file{/var/cfengine/masterfiles/update.cf}. The original version looks like this:
@verbatim
 packages:
  # update packages after all Cfengine have been killed

  stopped_cfprocs::
   "$(novapkg)"
                  comment => "Update Nova package to a newer version",
                   handle => "update_bins_packages_nova_update_all",
           package_policy => "update",
           package_select => ">=", # picks the newest Nova available
    package_architectures => { "$(pkgarch)" },
          package_version => "1.0.0", # at least Nova version 1.0.0
           package_method => u_generic( "$(local_software_dir)" ),
               ifvarclass => "nova_edition",
                  classes => u_if_else("bin_update_success", "bin_update_fail");

@end verbatim

The modified version looks like this (modified package_version number and added separate section for windows):
@verbatim
packages:
  # update packages after all CFEngine have been killed

  stopped_cfprocs.!windows::
   "$(novapkg)" 
                  comment => "Update Nova package to a newer version",
                   handle => "update_bins_packages_nova_update_all",
           package_policy => "update",
           package_select => ">=",           # picks the newest Nova available
    package_architectures => { "$(pkgarch)" },
          package_version => "9.9.9",        # Install new Nova anyway
           package_method => u_generic( "$(local_software_dir)" ),
               ifvarclass => "nova_edition",
                  classes => u_if_else("bin_update_success", "bin_update_fail");

  stopped_cfprocs.windows::
   "$(novapkg)" 
                  comment => "Update Nova package to a newer version",
                   handle => "update_bins_packages_nova_update_all",
           package_policy => "update",
           package_select => ">=",           # picks the newest Nova available
    package_architectures => { "$(pkgarch)" },
          package_version => "9.9.9.9",      # Install new Nova anyway
           package_method => u_generic( "$(local_software_dir)" ),
               ifvarclass => "nova_edition",
                  classes => u_if_else("bin_update_success", "bin_update_fail");

@end verbatim

@item If you upgrade from CFEngine Nova 2.1.x or earlier, modify line 298 in@* @file{/var/cfengine/masterfiles/update.cf} (approximate location, please verify that you change the corresponding content) to run mongod without journaling. The original line looks like this (line has been split and indented for presentability):
@verbatim
   "/var/cfengine/bin/mongod --fork --logpath /var/log/mongod.log --dbpath
      $(sys.workdir)/state --bind_ip 127.0.0.1 --nohttpinterface > /dev/null
      < /dev/null 2>&1"
@end verbatim

The modified line looks like this (add @code{--nojournal --logappend}; line has been split and indented for presentability):
@verbatim
   "/var/cfengine/bin/mongod --fork --logpath /var/log/mongod.log --dbpath
      $(sys.workdir)/state --bind_ip 127.0.0.1 --nohttpinterface --nojournal
      --logappend > /dev/null < /dev/null 2>&1"
@end verbatim

@noindent As a final part of step 9, copy the modified update.cf to the inputs directory:
@verbatim
   $ cp /var/cfengine/masterfiles/update.cf /var/cfengine/inputs/update.cf
@end verbatim

@item Tidy up $(sys.doc_root) directory@*
[Debian/Ubuntu]
@verbatim
   $ rm -rf /var/www/*
@end verbatim
[RHEL/CentOS]
@verbatim
   $ rm -rf /var/www/html/*
@end verbatim
[SLES/openSUSE]
@verbatim
   $ rm -rf /srv/www/htdocs/*
@end verbatim

@item Restart CFEngine processes
@verbatim
   $ /etc/init.d/cfengine3 start
or
   $ /var/cfengine/bin/cf-execd
@end verbatim

@item You will need to re-initialize the MongoDB if you have trouble logging in after upgrade, see @xref{First time login to Mission Portal fails}.
@end enumerate


@c -----------------------------------------------------
@node Upgrade procedure for the clients, Upgrade procedure for the standard library, Upgrade procedure for the hub (and policy), Upgrading CFEngine 3 Enterprise
@section Upgrade procedure for the clients

@noindent For client upgrades there are 2 approaches: manual or automatic upgrade.
@enumerate
@item Manual: Update cfengine-nova on each client by @code{rpm}, @code{dpkg} or corresponding Windows command. For Linux/UNIX systems, update cf-twin as described in step 4 in the upgrade procedure for the hub (i.e. overwrite the old cf-twin). For Windows systems copy/overwrite the content of 
@verbatim
   C:\Program Files\Cfengine\bin
@end verbatim
@noindent to 
@verbatim
   C:\Program Files\Cfengine\bin-twin
@end verbatim
@item Automatic: On the hub, copy the cfengine-nova packages to the operating system specific distribution directories in @file{/var/cfengine/master_software_updates} (i.e. put the files in the respective operating specific subdirectories) and CFEngine 3 Enterprise will take care of the rest.
@end enumerate


@c -----------------------------------------------------
@node Upgrade procedure for the standard library, How can I do phased deployment?, Upgrade procedure for the clients, Upgrading CFEngine 3 Enterprise
@section Upgrade procedure for the standard library

When all clients have been upgraded to CFEngine 3 Enterprise 2.2.x, i.e. you have completed both hub and client upgrades as described above, copy the most recent standard library to @file{/var/cfengine/masterfiles} on the hub (note that the new library version is incompatible with versions of CFEngine 3 Enterprise older than 2.2.0):
@verbatim
   $ cp /var/cfengine/share/NovaBase/cfengine_stdlib.cf /var/cfengine/masterfiles
@end verbatim


@c -----------------------------------------------------
@node How can I do phased deployment?, What if I have multiple operating system platforms?, Upgrade procedure for the standard library, Upgrading CFEngine 3 Enterprise
@section How can I do phased deployment?

Using CFEngine classes to select a subset of machines, you can deploy of updates on a small
number of test systems first.


@c -----------------------------------------------------
@node  What if I have multiple operating system platforms?, How do CFEngine 3 Enterprise policies update if I already have my own policy?, How can I do phased deployment?, Upgrading CFEngine 3 Enterprise
@section What if I have multiple operating system platforms?

As of version 1.1 of CFEngine Nova, CFEngine will look for updates in an operating specific
location on the policy server. To update a particular operating system, you only need to place
its package in the correct subdirectory and the client host will know where to look.


@c ------------------------------------------------------
@node How do CFEngine 3 Enterprise policies update if I already have my own policy?, How do I upgrade from CFEngine Community 3 to CFEngine 3 Enterprise?, What if I have multiple operating system platforms?, Upgrading CFEngine 3 Enterprise
@section How do CFEngine 3 Enterprise policies update if I already have my own policy?

New CFEngine package updates will not overwrite your existing policy. That means that they
will also not improve your current updating arrangement without your approval.

@cartouche
If you want to make use of CFEngine’s enhancements to standard policy files like
‘update.cf’, you need to examine and integrate these changes to your policy server manually.
Update the software before updating policy, as new policy might require new features in
the software.
@end cartouche

If you require assistance upgrading, contact CFEngine Support.


@c ----------------------------------------------------
@node How do I upgrade from CFEngine Community 3 to CFEngine 3 Enterprise?, , How do CFEngine 3 Enterprise policies update if I already have my own policy?, Upgrading CFEngine 3 Enterprise
@section How do I upgrade from CFEngine Community 3 to CFEngine 3 Enterprise?

CFEngine 3 Enterprise comes with policies that are specific to Enterprise functionality, we therefore urge you to set aside your
current community policy. Install CFEngine 3 Enterprise, set up the Enterprise hub by
following this document, and then integrate your existing
policy to the hub manually, in small testable steps.

CFEngine 3 Enterprise is compatible with the Community Edition of CFEngine 3 for distributing policies, but
some process files are now managed by CFEngine 3 Enterprise and reporting will not work in the CFEngine 3 Enterprise Mission Portal.

Please see @ref{Troubleshooting} if you have any problems.
@end ignore


@c *****************************************************
@c * CHAPTER
@c *****************************************************
@node Frequently Asked Questions, Troubleshooting, Upgrading CFEngine 3 Enterprise, Top
@chapter Frequently Asked Questions

@menu
* How do I install the prerequisites for the hub manually?::
* I did bootstrap the hub before obtaining a license file - what should I do?::
@end menu

@c ----------------------------------------------------
@node How do I install the prerequisites for the hub manually?, I did bootstrap the hub before obtaining a license file - what should I do?, Frequently Asked Questions, Frequently Asked Questions
@section How do I install the prerequisites for the hub manually?

See the bundled INSTALL file for a list of dependencies for the hub (can also be found on the CFEngine software download page: @url{https://cfengine.com/software/}). 

To install the packages you might want to use @code{yum} on Red Hat/CentOS/Fedora, 
@code{zypper} on SUSE or @code{apt} on Debian/Ubuntu.


@c ----------------------------------------------------
@node I did bootstrap the hub before obtaining a license file - what should I do?, , How do I install the prerequisites for the hub manually?, Frequently Asked Questions
@section I did bootstrap the hub @emph{before} obtaining a license file - what should I do?

Four steps need to be followed to correct this minor issue.
@enumerate
@item obtain a working license file and copy it to @file{/var/cfengine/masterfiles}
@verbatim
 hub # cp /tmp/license.dat /var/cfengine/masterfiles
@end verbatim
@item killall CFEngine running processes
@verbatim
 hub # killall cf-execd cf-serverd cf-monitord cf-hub
@end verbatim
@item wipe out @file{/var/cfengine/inputs }
@verbatim
 hub # rm -rf /var/cfengine/inputs
@end verbatim
@item bootstrap the policy hub
@verbatim
 hub # /var/cfengine/bin/cf-agent --bootstrap --policy-server 123.456.789.123
@end verbatim
@end enumerate


@c *****************************************************
@c * CHAPTER
@c *****************************************************
@node Troubleshooting, Configuration of external authentication, Frequently Asked Questions, Top
@chapter Troubleshooting

@menu
* Mission Portal Logs::
* Apache HTTP error_log is your friend::  
* Some report pages return HTTP error 404::  
* CFEngine processes are running but I cannot connect to the Mission Portal web page:: 
* First time login to Mission Portal fails::
* Cannot send emails from the Mission Portal::  
* Warning messages on web pages in SLES/OpenSuSE Hub::  
* Knowledge map remains unpopulated::
* I get a promise failed with the message "Can't stat /var/cfengine/master_software_updates/SOME-OS" on some hosts::
* I get messages of connection failures to a database on my hub::
@end menu


@c -----------------------------------------------------
@node Mission Portal Logs, Apache HTTP error_log is your friend, Troubleshooting, Troubleshooting
@section Mission Portal Logs

The Mission Portal will log php errors, errors related to the configuration of external authentication (LDAP/Active Directory) and occurrences of the fall-back solution if external authentication fails. The log can be found in DOCROOT/application/logs (i.e. @code{/var/www/application/logs} for Ubuntu and @code{/var/www/html/application/logs} for Red Hat). The logs folder must be writable by apache, i.e. by 'www-data' user. 


@c -----------------------------------------------------
@node Apache HTTP error_log is your friend, Some report pages return HTTP error 404, Mission Portal Logs, Troubleshooting
@section Apache HTTP error_log is your friend
The first place to diagnose (if all CFEngine processes and mongod are up and running) is:@*
@i{RHEL 5,6 / CentOS 5}
@verbatim
   /var/log/httpd/error_log
@end verbatim
@noindent @i{SLES 11 / OpenSuSE 11 / Debian 5,6 / Ubuntu 8,10}
@verbatim
   /var/log/apache2/error_log
@end verbatim

@noindent This log file will often provide useful information on which components are not operating properly. 


@c -----------------------------------------------------
@node Some report pages return HTTP error 404, CFEngine processes are running but I cannot connect to the Mission Portal web page, Apache HTTP error_log is your friend, Troubleshooting
@section Some report pages return HTTP error 404
Confirm that Apache REWRITE module is ON. Restarting httpd/apache2 service is required if rewrite was disabled.


@c ----------------------------------------------------
@node CFEngine processes are running but I cannot connect to the Mission Portal web page, First time login to Mission Portal fails, Some report pages return HTTP error 404, Troubleshooting
@section CFEngine processes are running but I cannot connect to the Mission Portal web page

There can be several reasons for this, please check the following:

@itemize *
@item Check that apache is running (the process should appear in the list when you run this command):
@verbatim
   $ ps waux | grep apache
@end verbatim

@item Ensure that port 80 is open on the hub and not blocked by a firewall (the following telenet connection should succeed):
@verbatim
   $ telnet <IP-ADDRESS> 80
@end verbatim

@item Check that there are no problems with php-mod by looking for error messages in the httpd error log or apache_error log.
@end itemize


@c -----------------------------------------------------
@node First time login to Mission Portal fails, Cannot send emails from the Mission Portal, CFEngine processes are running but I cannot connect to the Mission Portal web page, Troubleshooting
@section First time login to Mission Portal fails
MongoDB needs to be initialized for authentication of the default user. Run the following command (line has been split and indented for presentability):
@sp 1
@verbatim
   $ /var/cfengine/bin/mongo phpcfengine 
	/var/cfengine/share/GUI/phpcfenginenova/export.js
@end verbatim
@sp 1
@noindent Default user name and password on the Mission Portal login page are 'admin' and 'admin'.


@c -----------------------------------------------------
@node Cannot send emails from the Mission Portal, Warning messages on web pages in SLES/OpenSuSE Hub, First time login to Mission Portal fails, Troubleshooting
@section Cannot send emails from the Mission Portal
The default email address used by the system is "admin@@cfengine.com". To change this, edit @file{application/config/ion_auth.php} at the line containing:
@verbatim
   $config['admin_email'] = "admin@cfengine.com";
@end verbatim


@c -----------------------------------------------------
@node Warning messages on web pages in SLES/OpenSuSE Hub, Knowledge map remains unpopulated, Cannot send emails from the Mission Portal, Troubleshooting
@section Warning messages on web pages in SLES/OpenSuSE Hub
Warnings appear because the default environment is set to "Development" and in this context the Mission Portal will show all php errors to the user. Set the environment to "Production" to silence these warnings, they will still be logged in Apache Error_log. To edit the default environment, visit "index.php" in your default web root directory and change the following line to suit your needs:
@verbatim
   define('ENVIRONMENT', 'Development');
@end verbatim


@c -----------------------------------------------------
@node Knowledge map remains unpopulated, I get a promise failed with the message "Can't stat /var/cfengine/master_software_updates/SOME-OS" on some hosts, Warning messages on web pages in SLES/OpenSuSE Hub, Troubleshooting
@section Knowledge map remains unpopulated
   Try building the Knowledge map manually:@*
   @i{RHEL 5 / CentOS 5}
@verbatim
   $ /var/cfengine/bin/cf-promises -r && /var/cfengine/bin/cf-know -f 
       /var/www/html/docs/enterprise_build.cf -b
@end verbatim
   @i{SLES 11 / OpenSuSE 11}
@verbatim
   $ /var/cfengine/bin/cf-promises -r && /var/cfengine/bin/cf-know -f 
       /srv/www/htdocs/docs/enterprise_build.cf -b
@end verbatim
   @i{Debian 5,6 / Ubuntu 8,10}
@verbatim
   $ /var/cfengine/bin/cf-promises -r && /var/cfengine/bin/cf-know -f 
       /srv/www/htdocs/docs/enterprise_build.cf -b
@end verbatim


@c ----------------------------------------------------
@node I get a promise failed with the message "Can't stat /var/cfengine/master_software_updates/SOME-OS" on some hosts, I get messages of connection failures to a database on my hub, Knowledge map remains unpopulated, Troubleshooting
@section I get a promise failed with the message @code{Can't stat /var/cfengine/master_software_updates/SOME-OS} on some hosts

There is a built-in promise to automatically upgrade the CFEngine 3 Enterprise
binaries. By default, the clients will check for an update package
every time CFEngine 3 Enterprise runs. So if the clients find that there is no source
directory to download the files from, the message will be displayed.

To fix the problem, simply create an empty directory mentioned in the
message on the hub.
@verbatim
 hub # mkdir /var/cfengine/master_software_updates/SOME-OS
@end verbatim


@c ----------------------------------------------------
@node I get messages of connection failures to a database on my hub, , I get a promise failed with the message "Can't stat /var/cfengine/master_software_updates/SOME-OS" on some hosts, Troubleshooting
@section I get messages of connection failures to a database on my hub

For example, in @code{messages}, I can see something like @code{!! Could not open connection to report database for saving}. What should I do?

This message comes from the @code{cf-hub} process. It is responsible
for pulling reports from hosts that have contacted the hub to get
policy updates. When these reports are fetched, they are stored in a local MongoDB database on the hub. This message is produced when there is a failure in the connection to the database.

Probably, the issue is that the database server is not running on your
hub. Run the @code{ps}-command to check this.
@verbatim
 hub # ps -e | grep mongod
@end verbatim

If the @code{mongod} process @emph{is} running, it must be
misconfigured or in some bad state. Please look at the newest entry in
@file{/var/log/mongod.log} to diagnose the problem, and contact
CFEngine Technical Support if necessary.

If the @code{mongod} process @emph{is not} running, please follow the
steps below.

@enumerate
@item Run 
  hub # @code{/var/cfengine/bin/cf-twin -Kvf failsafe.cf > /tmp/cfout}
@item Check again if the @code{mongod} is running, if so, the problem
is probably fixed now.
@item If @code{mongod} is still not running, please search the output
file for lines starting as follows.

@verbatim
...
nova>  -> Making a one-time restart promise for mongod
...
...
nova>  -> Executing '/var/cfengine/bin/mongod....
nova>  -> Backgrounding job /var/cfengine/bin/mongod...
nova>  -> Completed execution of /var/cfengine/bin/mongod...
...
@end verbatim

If you don't see the first line above, CFEngine 3 Enterprise does not try to start
@code{mongod} --- so check if you bootstrapped your hub correctly. If
you see all lines, it means that CFEngine 3 Enterprise starts @code{mongod}, but the process just
terminates immediately after. If so, continue to the next step.

@item Look at the newest entry in @file{/var/log/mongod.log}. It
should give you more details of why the @code{mongod} process refuses
to start. The two most common scenarios are described next.

@item If @code{mongod} has been terminated unexpectedly, it might have
left a lock-file behind that stops it from starting again. Try
deleting @file{/var/cfengine/state/mongod.lock} if it exists.

@item If the database is corrupted, you can have @file{mongod} create a new one by moving
@file{/var/cfengine/state/cf-report.*} out of the way. There are also
tools and documentation for repairing a database at
@url{http://www.mongodb.org/}.

Note that almost all of the @code{cfreport} database is recreated with data collected from clients. This happens every 5 minutes or 6 hours (depending on the probe), you may consider whether deleting the database is an acceptable solution. CFEngine AS or CFEngine Inc can not be held responsible for data loss in this respect.
@end enumerate


@c *****************************************************
@c * APPENDIX A
@c *****************************************************
@node Configuration of external authentication, SQLite Database Schema, Troubleshooting, Top
@appendix Configuration of external authentication

External authentication is available for CFEngine 3 Nova 2.1 and later versions, but by default the Mission Portal will use the embedded database to store user information (default user name and password on the Mission Portal login page are "admin" and "admin"). Note that users in the default database will be locked out of the Mission Portal upon configuration of external authentication. They will regain access if external authentication is deactivated by selecting the Database button on the Mission Portal Settings page (see below).

To enable external authentication on a fresh install, log on to the Mission Portal with the default user and password and go to "User Settings and Preferences" (see @ref{Mission Portal Settings}). Click "Mission Portal Settings" and enter the appropriate configuration for LDAP or Active Directory as described below. Note that the actual setup of LDAP or Active Directory (definition of users, directory hierarchy, etc.) has to be done independently and is not covered in this document.


@menu
* Configure LDAP::              
* Configure Active Directory::  
@end menu


@c ----------------------------------------------------------
@node Configure LDAP, Configure Active Directory, Configuration of external authentication, Configuration of external authentication
@section Configure LDAP

Select the LDAP button and enter the appropriate configuration settings for your system.

@sp 1
@center @image{img-config-ldap-2-2,15cm,,Configure LDAP}
@center Figure: Configure LDAP
@sp 1

@noindent Form fields:

@itemize -
@item LDAP host: Address of the LDAP machine
@item Base dn: LDAP root, the top entry (starting point) in the directory
@item Login attribute: Field name used to match user name, e.g. uid.
@item User directory: Directory name where user names are stored, e.g. cn=users or ou=people
@item Encryption: Chose the encryption protocol to be used for authentication
@item External admin user name: Enter the LDAP user name of the person that is supposed to have admin rights
@item Fall-back role: User group that will be able to access the Mission Portal through internal database authentication if external authentication is down or misconfigured. 
@c @item Member attribute: Field name used to match user group (only needed for OPENLDAP), e.g. memberUid
@end itemize

Always check that the entered configuration is correct by clicking the "Test it" button before submitting changes. Enter a valid user name and password in the popup to test LDAP bind. Submitting an incorrect configuration will put LDAP down and lock out all users, CFEngine 3 Enterprise therefore comes with a fallback solution. Select a fallback administrator group in the database from the dropbox, CFEngine 3 Enterprise will look for users in this group when an incorrect configuration has been passed. A member of this group will then be able to log on to the Mission Portal using his internal database user name and password and restart the external authentication configuration.

If you wish to use RBAC in combination with LDAP, we recommend that you wait to turn on RBAC until you log on with the LDAP user that has been designated a Mission Portal admin (i.e do not turn RBAC on while logged on with an internal database user in this case).


@c ----------------------------------------------------------
@node Configure Active Directory, , Configure LDAP, Configuration of external authentication
@section Configure Active Directory

Select the Active Directory button and enter the appropriate configuration settings for you system.

@sp 1
@center @image{img-config-active-directory-2-2,15cm,,Configure Active Directory}
@center Figure: Configure Active Directory
@sp 1

@noindent Form fields:

@itemize -
@item LDAP host: Address of the LDAP machine
@item Base dn: LDAP root, the top entry (starting point) in the directory
@item Login attribute: Field name used to match user name, e.g. uid.
@item User directory: Directory name where user names are stored, e.g. cn=users or ou=people
@item Active directory domain: Field name used to match directory domain on Windows machines, e.g. windows1.test.cfengine.com
@item Encryption: Chose the encryption protocol to be used for authentication
@item External admin user name: Enter the AD user name of the person that is supposed to have admin rights
@item Fall-back role: User group that will be able to access the Mission Portal through internal database authentication if external authentication is down or misconfigured.
@end itemize

Always check that the entered configuration is correct by clicking the "Test it" button before submitting changes. Enter a valid user name and password in the popup to test LDAP bind. Submitting an incorrect configuration will put LDAP down and lock out all users, CFEngine 3 Enterprise therefore comes with a fallback solution. Select a fallback administrator group in the database from the dropbox, CFEngine 3 Enterprise will look for users in this group when an incorrect configuration has been passed. A member of this group will then be able to log on to the Mission Portal using his internal database user name and password and restart the external authentication configuration.

If you wish to use RBAC in combination with LDAP, we recommend that you wait to turn on RBAC until you log on with the LDAP user that has been designated a Mission Portal admin (i.e do not turn RBAC on while logged on with an internal database user in this case).


@c *****************************************************
@c * APPENDIX B
@c *****************************************************
@node SQLite Database Schema, , Configuration of external authentication, Top
@appendix SQLite Database Schema

The following figure shows the database schema used in the @ref{SQL Reports App}:

@sp 1
@center @image{img-sql-db-schema-3-0,15cm,,SQLite Database Schema}
@center Figure: SQLite Database Schema
@sp 1

@cartouche
Please note that any queries containing the PromiseDefinitions table in combination with any other table in the schema will produce erroneous output without an intermediate join to the PromiseStatusLast table.
@end cartouche


@c =========================================================================
@c @node Index,  , CFEngine Methods, Top
@c @unnumbered Concept Index
@c @printindex cp
@c =========================================================================
@ifhtml
@html
<a name="Contents">
@contents
@end html
@end ifhtml

@c  The file is structured like a programming language. Each chapter
@c  starts with a chapter comment.
@c
@c  Menus list the subsections so that an online info-reader can parse
@c  the file hierarchically.
@ifhtml
@html
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2576171-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>
@end html
@end ifhtml
@bye
