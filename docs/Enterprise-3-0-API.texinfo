\input texinfo-altfont
\input texinfo-logo
\input texinfo
@selectaltfont{cmbright}
@setlogo{CFEngineFrontPage} 

@c *********************************************************************
@c
@c  This is a TEXINFO file. It generates both TEX documentation and
@c  the "on line" documentation "info" files.
@c
@c  The file is structured like a programming language. Each chapter
@c  starts with a chapter comment.
@c
@c  Menus list the subsections so that an online info-reader can parse
@c  the file hierarchically.
@c
@c ***********************************************************************
@c %** start of header
@setfilename st-coredev.info
@settitle CFEngine Enterprise 3.0 API
@setchapternewpage odd
@c %** end of header

@titlepage
@title CFEngine Enterprise 3.0 API
@author CFEngine AS

@vskip 0pt plus 1filll
Copyright @copyright{} 2012 CFEngine AS

@end titlepage

@contents

@c **************************************************
@c CHAPTER
@c **************************************************

@chapter Introduction

The CFEngine Enterprise API allows HTTP clients to interact with the Hub of a CFEngine Enterprise 3.0 installation. With the Enterprise API, you can..

@itemize
@item Check installation status
@item Manage users, groups and settings
@item Browse host (agent) information and policy
@item Issue flexible SQL queries against data collected by the Hub from agents
@item Schedule reports for email and later download
@end itemize

The Enterprise API is a REST API, but a central part of interacting with the API involves using SQL. This is new in 3.0 and was done to provide users with maximal flexibility for crafting custom reports based on the wealth of data residing on the Hub.

@subsection Basic Properties of the API

@subsubsection HTTP + JSON
The Enterprise API is a conventional REST API in the sense that it has a number of URI resources that support one or more GET, PUT, POST, or DELETE operations. While reporting is done using SQL, this query is always wrapped in a JSON request.

@subsubsection Requests
@b{GET} requests are one of @b{listing} or @b{getting}. @b{Listing} resources means that a number of results will be returned, but each entry may contain limited information. An example of a @b{listing} query is @i{/api/user} to list users. Notice that URI components are always non-plural. An exception to this is @i{/api/settings}, which returns the singleton resource for settings. @b{Getting} a resource specifies an individual resource to return, e.g. @i{/api/user/homer}. @b{PUT} request typically create a new resource, e.g. a user. @b{POST} requests typically updates an existing resource. @b{DELETE} requests are also supported in some cases.

@subsubsection Responses
3.0 responses are always of the following format, consisting of a @b{meta} object and a @b{data} array.
@verbatim
{
  "meta": {
    "page": 1,
    "count": 1,
    "total": 1,
    "timestamp": 1350922925
  },
  "data": [
     ... 
  ]
}
@end verbatim

@b{page} refers to the current page number of the request. @b{count} is the number of results in the current page, equaling the length of the @b{data} array. @b{total} is the number of results in all available pages combined. @b{timestamp} is the time the request was processed by the API. The @b{data} array is resource dependent, but will always contain objects. Response objects typically do not contain error codes. If the response is not @i{200 OK}, the appropriate HTTP error code returned along with a (possibly non-JSON) payload.

@subsubsection Pagination
Pagination is handled by @b{page} and @b{count} query parameters to a @b{GET} request, e.g. @i{/api/user?page=5&count=30} to get the 5th page of pages of 30 entries each. The default @b{page} is 1 and the default @b{count} is 50 if these are not specified explicitly.

@subsubsection Time
All timestamps are reported in @i{Unix Time}, i.e. seconds since 1970.

@subsubsection Authentication
The API supports both internal and external authentication. The internal users table will always be consulted first, followed by an external source specified in the settings. External sources are @i{OpenLDAP} or @i{Active Directory} servers configurable through @i{POST /api/settings}.

@subsubsection Authorization
Some resources require that the request user is a member of the @i{admin} role. Roles are managed with @i{/api/role}. @b{Role-Based Access Control (RBAC)} is configurable through settings. Users typically have permission to access their own resources, e.g. their own scheduled reports.

@subsection Differences between the CFEngine Nova 2.2 REST API and the CFEngine Enterprise 3.0 API.

@subsubsection Read vs. Read/Write
The 2.2 API was read-only and users, roles and settings was managed by the Mission Portal. By contrast, the 3.0 API is read/write and completely standalone from the Mission Portal. In the CFEngine Enterprise 3.0, users, roles and settings belong in the API, and the Mission Portal uses this to determine access to data. Additionally, some other resources support PUT, POST and DELETE, but most data collected from agents are read-only.

@subsubsection Built-in Reports vs. Reporting Engine
The 2.2 API provided an almost one-to-one correspondence between the reports in the Mission Portal and the API. One of the big changes in CFEngine Enterprise 3.0 is the advent of SQL reports. This is provided to the Mission Portal through the API, and you can use it too. You may issue both synchronous and asynchronous reporting requests, and optionally schedule reports to be received by email.

@subsubsection Content-Type
The 2.2 API has a HTTP content-type @code{application/vnd.cfengine.nova-v1+json}. In the 3.0 API the content-type is @code{application/vnd.cfengine.enterprise-v1+json}. This reflects a branding change away from Nova to Enterprise.

@subsubsection New Users
The 2.2 API used credentials from the Mission Portal database to authenticate and authorize users. These users have been moved into the Hub database and security has been strengthened. We are now using salted SHA256 passwords for the user table. Unfortunately, this means that internal users need to be recreated. The Mission Portal now relies on the API for authentication and authorization. This was partially done to support multi-hub installations.

@subsubsection Base Path
The 2.2 API had a base path @code{/rest}. In the 3.0 API the base path is @code{/api}.

@subsubsection Still available
In 3.0, the old 2.2 API is still available along side the new 3.0 API, so you can keep calling the old API if needed.

@subsubsection Mission Portal
Starting in 3.0, most of the API is exercised by the Mission Portal web-UI.

@chapter Checking Status
You can get basic info about the API by issuing @i{GET /api}. This status information may also be useful if you contact support, as it gives some basic diagnostics.

@b{Request}
@verbatim
curl -k --user admin:admin https://test.cfengine.com/api/
@end verbatim

@b{Response}
@verbatim
{
  "meta": {
    "page": 1,
    "count": 1,
    "total": 1,
    "timestamp": 1351154889
  },
  "data": [
    {
      "apiName": "CFEngine Enterprise API",
      "apiVersion": "v1",
      "enterpriseVersion": "3.0.0a1.81c0d4c",
      "coreVersion": "3.5.0a1.f3649b2",
      "databaseHostname": "127.0.0.1",
      "databasePort": 27017,
      "authenticated": "internal",
      "license": {
        "expires": 1391036400,
        "installTime": 1329578143,
        "owner": "Stage Environment",
        "granted": 20,
        "licenseUsage": {
          "lastMeasured": 1351122120,
          "samples": 1905,
          "minObservedLevel": 7,
          "maxObservedLevel": 30,
          "meanUsage": 21.9689,
          "meanCumulativeUtilization": 109.8446,
          "usedToday": 7
        }
      }
    }
  ]
}
@end verbatim

@chapter Managing Settings
Most of the settings configurable in the API relate to LDAP authentication of users. Settings support two operations, @b{GET} (view settings) and @b{POST} (update settings). When settings are updated, they are sanity checked individually and as a whole. All or no settings will be updated for a request.

@subsection Viewing settings
@b{Request}
@verbatim
curl --user admin:admin http://test.cfengine.com/api/settings
@end verbatim

@b{Response}
@verbatim
{
  "meta": {
    "page": 1,
    "count": 1,
    "total": 1,
    "timestamp": 1350992335
  },
  "data": [
    {
      "rbacEnabled": true,
      "ldapEnabled": false,
      "ldapActiveDirectoryDomain": "ad.cfengine.com",
      "ldapBaseDN": "DC=ad,DC=cfengine,DC=com",
      "ldapEncryption": "plain",
      "ldapHost": "ldap-server.cfengine.com",
      "ldapLoginAttribute": "sAMAccountName",
      "ldapMode": "activeDirectory",
      "ldapPassword": "password",
      "ldapPort": 389,
      "ldapPortSSL": 636,
      "ldapUsername": "test",
      "ldapUsersDirectory": "CN=Users",
      "blueHostHorizon": 900,
      "logLevel": "error"
    }
  ]
}
@end verbatim

@subsection Example: Configuring LDAP
The setting @b{ldapEnabled} turns external authentication on or off. When turned on, the API will check to see that the other LDAP related settings make sense, and attempt to authenticate using the configured credentials. If it is not successful in doing this, no settings will be changed. The API will notify you with a return code an a message describing the error.

@b{Request}
@verbatim
curl --user admin:admin http://test.cfengine.com/api/settings -X POST -d
{
  "ldapEnabled": true,
  "ldapActiveDirectoryDomain": "ad.cfengine.com",
  "ldapBaseDN": "DC=ad,DC=example,DC=com",
  "ldapEncryption": "ssl",
  "ldapHost": "ldap-server.cfengine.com",
  "ldapLoginAttribute": "sAMAccountName",
  "ldapMode": "standard",
  "ldapPassword": "password",
  "ldapUsername": "test",
  "ldapUsersDirectory": "ou",
}
@end verbatim
@b{Response}
@verbatim
204 No Content
@end verbatim

@subsection Example: Configuring Active Directory
Active Directory is configured in much the same way as OpenLDAP, but the additional field @b{ldapActiveDirectoryDomain} is required. @b{ldapMode} is also changed from @i{standard} to @i{activeDirectory}.

@b{Request}
@verbatim
curl --user admin:admin http://test.cfengine.com/api/settings -X POST -d
{
  "ldapEnabled": true,
  "ldapBaseDN": "DC=example,DC=com",
  "ldapEncryption": "plain",
  "ldapHost": "ad-server.cfengine.com",
  "ldapLoginAttribute": "uid",
  "ldapMode": "activeDirectory",
  "ldapPassword": "password",
  "ldapUsername": "test",
  "ldapUsersDirectory": "CN=Users",
}
@end verbatim

@b{Response}
@verbatim
204 No Content
@end verbatim

@subsection Example: Changing The Log Level
The API uses standard Unix syslog to log a number of events. Additionally, log events are sent to stderr, which means they may also end up in your Apache log. Log events are filtered based on the log level in settings. Suppose you wanted to have greater visibility into the processing done at the backend. The standard log level is @i{error}. Changing it to @i{info} is done as follows.

@b{Request}
@verbatim
curl --user admin:admin http://test.cfengine.com/api/settings -X POST -d
{
  "logLevel": "info"
}
@end verbatim

@b{Response}
@verbatim
204 No Content
@end verbatim


@chapter Managing Users and Roles
Users and Roles determine who has access to what data from the API. Roles are defined by regular expressions that determine which hosts the user can see, and what policy outcomes are restricted. 

@subsection Example: Listing Users


@b{Request}
@verbatim
curl --user admin:admin http://test.cfengine.com/api/user
@end verbatim

@b{Response}
@verbatim
{
  "meta": {
    "page": 1,
    "count": 2,
    "total": 2,
    "timestamp": 1350994249
  },
  "data": [
    {
      "id": "calvin",
      "external": true,
      "roles": [
        "Huguenots", "Marketing"
      ]
    },
    {
      "id": "quinester",
      "name": "Willard Van Orman Quine",
      "email": "noreply@@aol.com",
      "external": false,
      "roles": [
        "admin"
      ]
    }
  ]
}
@end verbatim

@subsection Example: Creating a New User
All users will be created for the internal user table. The API will never attempt to write to an external LDAP server.
@b{Request}
@verbatim
curl --user admin:admin http://test.cfengine.com/api/user/snookie -X PUT -d
{
  "email": "snookie@mtv.com",
  "roles": [
    "HR"
  ]
}
@end verbatim

@b{Response}
@verbatim
201 Created
}
@end verbatim

@subsection Example: Updating an Existing User
Both internal and external users may be updated. When updating an external users, the API will essentially annotate metadata for the user, it will never write to LDAP. Consequently, passwords may only be updated for internal users. Users may only update their own records, as authenticated by their user credentials.
@b{Request}
@verbatim
curl --user admin:admin http://test.cfengine.com/api/user/calvin -X POST -d
{
  "name": "Calvin",
}
@end verbatim

@b{Response}
@verbatim
204 No Content
}
@end verbatim

@subsection Example: Retrieving a User
It is possible to retrieve data on a single user instead of listing everything. The following query is similar to issuing @i{GET /api/user?id=calvin}, with the exception that the previous query accepts a regular expression for @i{id}.
@b{Request}
@verbatim
curl --user admin:admin http://test.cfengine.com/api/user/calvin
@end verbatim

@b{Response}
@verbatim
{
  "meta": {
    "page": 1,
    "count": 1,
    "total": 1,
    "timestamp": 1350994249
  },
  "data": [
    {
      "id": "calvin",
      "name": "Calvin",
      "external": true,
      "roles": [
        "Huguenots", "Marketing"
      ]
    },
  ]
}
@end verbatim

@subsection Example: Adding a User to a Role
Adding a user to a role is just an update operation on the user. The full role-set is updated, so if you are only appending a role, you may want to fetch the user data first, append the role and then update. The same approach is used to remove a user from a role.
@b{Request}
@verbatim
curl --user admin:admin http://test.cfengine.com/api/user/snookie -X POST -d
{
  "roles": [
    "HR", "gcc-contrib"
  ]
}
@end verbatim

@b{Response}
@verbatim
204 No Content
}
@end verbatim

@subsection Example: Deleting a User
Users can only be deleted from the internal users table.
@b{Request}
@verbatim
curl --user admin:admin http://test.cfengine.com/api/user/snookie -X DELETE
@end verbatim

@b{Response}
@verbatim
204 No Content
@end verbatim

@subsection Example: Creating a New Role
Once you've learned how to manage users, managing roles is pretty much the same thing. Roles are defined by four fields that filter host data and policy data: @b{includeContext}, @b{excludeContext}, @b{includeBundles}, @b{excludeBundles}. Each field is a comma separated list of regular expressions. See the corresponding section on RBAC for an explanation of these fields. Updating, and deleting roles are similar to updating and deleting users, using POST and DELETE.
@b{Request}
@verbatim
curl --user admin:admin http://test.cfengine.com/api/user/solaris-admins -X PUT -d
{
  "email": "snookie@mtv.com",
  "roles": [
    "description": "Users managing 64-bit Solaris boxes",
    "includeContext": "solaris,x86_64",
  ]
}
@end verbatim

@b{Response}
@verbatim
204 No Content
@end verbatim

@chapter Browsing Host Information
A resource @i{/api/host} is added as an alternative interface for browsing host information. For full flexibility we recommend using SQL reports via @i{/api/query} for this, however, currently vital signs (data gathered from cf-monitord) is not part of the SQL reports data model.

@subsection Example: Listing Hosts With A Given Context

@b{Request}
@verbatim
curl --user admin:admin http://test.cfengine.com/api/host?context-include=windows.*
@end verbatim

@b{Response}
@verbatim
{
  "meta": {
    "page": 1,
    "count": 2,
    "total": 2,
    "timestamp": 1350997528
  },
  "data": [
    {
      "id": "1c8fafe478e05eec60fe08d2934415c81a51d2075aac27c9936e19012d625cb8",
      "hostname": "windows2008-2.test.cfengine.com",
      "ip": "172.20.100.43"
    },
    {
      "id": "dddc95486d97e4308f164ddc1fdbbc133825f35254f9cfbd59393a671015ab99",
      "hostname": "windows2003-2.test.cfengine.com",
      "ip": "172.20.100.42"
    }
  ]
}
@end verbatim

@subsection Example: Looking Up Hosts By Hostname

Contexts are powerful, as you can use them to categorize hosts according to a rich set of tags. For example, each host is automatically tagged with a canonicalized version of its hostname and IP-address. So we could lookup the host with hostname @i{windows2003-2.test.cfengine.com} as follows.

@b{Request}
@verbatim
curl --user admin:admin http://test.cfengine.com/api/host?context-include=windows2003_2_stage_cfengine_com
@end verbatim

@b{Response}
@verbatim
{
  "meta": {
    "page": 1,
    "count": 1,
    "total": 1,
    "timestamp": 1350997528
  },
  "data": [
    {
      "id": "dddc95486d97e4308f164ddc1fdbbc133825f35254f9cfbd59393a671015ab99",
      "hostname": "windows2003-2.test.cfengine.com",
      "ip": "172.20.100.42"
    }
  ]
}
@end verbatim

@subsection Example: Looking Up Hosts By IP

Similarly we can lookup the host with hostname @i{windows2008-2.test.cfengine.com} by IP as follows.

@b{Request}
@verbatim
curl --user admin:admin http://test.cfengine.com/api/host?context-include=172_20_100_43
@end verbatim

@b{Response}
@verbatim
{
  "meta": {
    "page": 1,
    "count": 1,
    "total": 1,
    "timestamp": 1350997528
  },
  "data": [
    {
      "id": "1c8fafe478e05eec60fe08d2934415c81a51d2075aac27c9936e19012d625cb8",
      "hostname": "windows2008-2.stage.cfengine.com",
      "ip": "172.20.100.43"
    }
  ]
}
@end verbatim

@subsection Example: Removing Host Data

If a host has been decommissioned from a Hub, we can explicitly remove data associated with the host from the Hub, by issuing a DELETE request.

@b{Request}
@verbatim
curl --user admin:admin http://test.cfengine.com/api/host/1c8fafe478e05eec60fe08d2934415c81a51d2075aac27c9936e19012d625cb8 -X DELETE
@end verbatim

@b{Response}
@verbatim
204 No Content
@end verbatim

@subsection Example: Listing Available Vital Signs For A Host

Each host record on the Hub has a set of vital signs collected by cf-monitord on the agent. We can view the list of vitals signs from as host as follows.

@b{Request}
@verbatim
curl --user admin:admin http://test.cfengine.com/api/host/4e913e2f5ccf0c572b9573a83c4a992798cee170f5ee3019d489a201bc98a1a/vital
@end verbatim

@b{Response}
@verbatim
{
  "meta": {
    "page": 1,
    "count": 4,
    "total": 4,
    "timestamp": 1351001799
  },
  "data": [
    {
      "id": "messages",
      "description": "New log entries (messages)",
      "units": "entries",
      "timestamp": 1351001400
    },
    {
      "id": "mem_swap",
      "description": "Total swap size",
      "units": "megabytes",
      "timestamp": 1351001400
    },
    {
      "id": "mem_freeswap",
      "description": "Free swap size",
      "units": "megabytes",
      "timestamp": 1351001400
    },
    {
      "id": "mem_free",
      "description": "Free system memory",
      "units": "megabytes",
      "timestamp": 1351001400
    },
}
@end verbatim

@subsection Example: Retrieving Vital Sign Data

Each vital sign has a collected time series of values for up to one week. Here we retrieve the time series for the @i{mem_free} vital sign at host @i{4e913e2f5ccf0c572b9573a83c4a992798cee170f5ee3019d489a201bc98a1a} for October 23rd 2012 12:20pm to 12:45pm GMT.

@b{Request}
@verbatim
curl --user admin:admin http://test.cfengine.com/api/host/4e913e2f5ccf0c572b9573a83c4a992798cee170f5ee3019d489a201bc98a1a/vital/mem_free?from=1350994800&to=1350996300
@end verbatim

@b{Response}
@verbatim
"meta": {
    "page": 1,
    "count": 1,
    "total": 1,
    "timestamp": 1351002265
  },
  "data": [
    {
      "id": "mem_free",
      "description": "Free system memory",
      "units": "megabytes",
      "timestamp": 1351001700,
      "values": [
        [
          1350994800,
          36.2969
        ],
        [
          1350995100,
          36.2969
        ],
        [
          1350995400,
          36.2969
        ],
        [
          1350995700,
          36.2969
        ],
        [
          1350996000,
          36.1758
        ],
        [
          1350996300,
          36.2969
        ]
      ]
    }
  ]

@end verbatim

@chapter SQL Queries

The standard way of creating reports in CFEngine Enterprise 3.0 is with SQL queries. See the chapter on SQL queries for an explanation. The API has a few ways of creating a report.

@itemize
@item Synchronous query, where we issue a query and wait for the table to be sent back with the response.
@item Asynchronous query, where we get a response immediately with an id that we can later query to download the report.
@item Subscribed query, where we specify a query to be run on a schedule and have the result emailed to someone.
@end itemize

@section Synchronous Queries

Issuing a synchronous query is the most straight forward way of running an SQL query. We simply issue the query and wait for a result to come back.

@subsection Example: Listing Hostname and IP for Ubuntu Hosts

@b{Request}
@verbatim
curl -k --user admin:admin https://test.cfengine.com/api/query -X POST -d
{
  "query": "SELECT Hosts.HostName, Hosts.IPAddress FROM Hosts JOIN Contexts ON Hosts.Hostkey = Contexts.HostKey WHERE Contexts.ContextName = \"ubuntu\""
}
@end verbatim

@b{Response}
@verbatim
{
  "meta": {
    "page": 1,
    "count": 1,
    "total": 1,
    "timestamp": 1351003514
  },
  "data": [
    {
      "query": "SELECT Hosts.HostName, Hosts.IPAddress FROM Hosts JOIN Contexts ON Hosts.Hostkey = Contexts.HostKey WHERE Contexts.ContextName = \"ubuntu\"",
      "header": [
        "HostName",
        "IPAddress"
      ],
      "rowCount": 3,
      "rows": [
        [
          "ubuntu10-2.stage.cfengine.com",
          "172.20.100.1"
        ],
        [
          "ubuntu10-3.stage.cfengine.com",
          "172.20.100.2"
        ],
        [
          "ubuntu10-4.stage.cfengine.com",
          "172.20.100.3"
        ]
      ],
      "cached": false,
      "sortDescending": false
    }
  ]
}
@end verbatim

The @b{cached} and @b{sortDescending} fields here mean that the the result was not retrieved from cache, and that post-processing sorting was not applied. It is also possible to specify @b{skip} and @b{limit} fields that will be applied to the result set after it is returned by the SQL engine. These fields are mainly used by the Mission Portal to paginate quickly on already processed queries.

@section Asynchronous Queries

Because some queries may take some time to compute, it is possible to fire off a query and check the status of it later. This is useful for dumping a lot of data into CSV files for example. The sequence consists of three steps.

@enumerate
@item Issue the asynchronous query and get a job id
@item Check status of processing using the id
@item When the query is completed, get a download link using the id
@end enumerate

@subsection Issuing The Query

@b{Request}
@verbatim
curl -k --user admin:admin https://test.cfengine.com/api/query/async -X POST -d
{
  "query": "SELECT Hosts.HostName, Hosts.IPAddress FROM Hosts JOIN Contexts ON Hosts.Hostkey = Contexts.HostKey WHERE Contexts.ContextName = \"ubuntu\""
}
@end verbatim

@b{Response}
@verbatim
{
  "meta": {
    "page": 1,
    "count": 1,
    "total": 1,
    "timestamp": 1351003514
  },
  "data": [
    {
      "id": "32ecb0a73e735477cc9b1ea8641e5552",
      "query": "SELECT Hosts.HostName, Hosts.IPAddress FROM Hosts JOIN Contexts ON Hosts.Hostkey = Contexts.HostKey WHERE Contexts.ContextName = \"ubuntu\""
    }
  ]
]
@end verbatim

@subsection Checking Status

@b{Request}
@verbatim
curl -k --user admin:admin https://test.cfengine.com/api/query/async/:id
@end verbatim

@b{Response}
@verbatim
{
  "meta": {
    "page": 1,
    "count": 1,
    "total": 1,
    "timestamp": 1351003514
  },
  "data": [
    {
      "id": "32ecb0a73e735477cc9b1ea8641e5552",
      "percentageComplete": 42,
    ]
}
@end verbatim

@subsection Getting The Completed Report

This is the same API call as checking the status. Eventually, the @b{percentageComplete} field will reach 100 and there will be a link to the completed report available for downloading.

@b{Request}
@verbatim
curl -k --user admin:admin https://test.cfengine.com/api/query/async/:id
@end verbatim

@b{Response}
@verbatim
{
  "meta": {
    "page": 1,
    "count": 1,
    "total": 1,
    "timestamp": 1351003514
  },
  "data": [
    {
      "id": "32ecb0a73e735477cc9b1ea8641e5552",
      "percentageComplete": 100,
      "href": "https://test.cfengine.com/api/static/32ecb0a73e735477cc9b1ea8641e5552.csv"
    }
  ]
}
@end verbatim

@section Subscribed Queries

Subscribed queries happen in the context of a user. Any user can create a query on a schedule and have it email to someone.

@subsection Example: Creating A Subscribed Query

Here we create a new query to count file changes by name and have the result sent to us by email. The schedule field is any CFEngine context expression. The backend polls subscriptions in a loop and checks whether it's time to generate a report and send it out. In the following example, user @i{milton} creates a new subscription to a report which he names @i{file-changes-report}, which will be sent out every Monday night. His boss will get an email with a link to a PDF version of the report.

@b{Request}
@verbatim
curl -k --user admin:admin https://test.cfengine.com/api/user/milton/subscription/query/file-changes-report -X PUT -d
{
  "to": "boss@megaco.com",
  "query": "SELECT Name Count(1) FROM FileChanges GROUP BY Name",
  "schedule": "Monday.Hr23.Min59",
  "title": "A very important file changes report"
  "description": "Text that will be included in email"
  "outputTypes": [ "pdf" ]
}
@end verbatim

@b{Response}
@verbatim
204 No Content
@end verbatim

@subsection Example: Listing Report Subscriptions

Milton can list all his current subscriptions by issuing the following.

@b{Request}
@verbatim
curl -k --user admin:admin https://test.cfengine.com/api/user/milton/subscription/query
@end verbatim

@b{Response}
@verbatim
@b{Response}
@verbatim
{
  "meta": {
    "page": 1,
    "count": 1,
    "total": 1,
    "timestamp": 1351003514
  },
  "data": [
    {
      "id": "file-changes-report"
      "to": "boss@megaco.com",
      "query": "SELECT Name Count(1) FROM FileChanges GROUP BY Name",
      "title": "A very important file changes report"
      "description": "Text that will be included in email"
      "schedule": "Monday.Hr23.Min59",
      "outputTypes": [ "pdf" ]
    }
]
@end verbatim

@subsection Example: Removing A Report Subscription

@b{Request}
@verbatim
curl -k --user admin:admin https://test.cfengine.com/api/user/milton/subscription/query/file-changes-report -X DELETE
@end verbatim

@b{Response}
@verbatim
204 No Content
@end verbatim

@chapter API Reference

@section /api
@subsection Supported Operations
@b{GET}
@subsection Fields
@itemize
@item @b{apiName} @i{(string)} Human-friendly API name.
@item @b{apiVersion} @i{(string)} API version string.
@item @b{enterpriseVersion} @i{(string)} Version of the CFEngine Enterprise build.
@item @b{coreVersion} @i{(string)} The version of CFEngine Core (Community) the Enterprise version was built against.
@item @b{databaseHostname} @i{(string)} Hostname (or IP) of the database the API is connected to.
@item @b{databasePort} @i{(integer)} Port number of the database the API is connected to.
@item @b{authenticated} @i{("internal", "external")}, Whether the request was authenticated using the internal users table or an external source.
@item @b{license.expires} @i{(integer)} Time when the license expires.
@item @b{license.installTime} @i{(integer)} Time when the license was installed.
@item @b{license.owner} @i{(string)} The name of the license owner.
@item @b{license.granted} @i{(integer)} Host number capacity granted by the license.
@item @b{license.licenseUsage.lastMeasured} @i{(integer)} Time when license usage was last updated.
@item @b{license.licenseUsage.samples} @i{(integer)} Number of samples collected for license usage.
@item @b{license.licenseUsage.minObservedLevel} @i{(integer)} Minimum number of observed host licenses in use.
@item @b{license.licenseUsage.minObservedLevel} @i{(integer)} Maximum number of observed host licenses in use.
@item @b{license.licenseUsage.meanUsage} @i{(integer)} Average number of observed host licenses in use.
@item @b{license.licenseUsage.meanCumulativeUtilization} @i{(integer)} (not sure)
@item @b{license.licenseUsage.usedToday} @i{(integer)} Total number of host licenses observed used today.
@end itemize

@section /api/settings
@subsection Supported Operations
@b{GET}, @b{POST}
@subsection Fields
@itemize
@item @b{rbacEnabled} @i{(boolean)} Whether RBAC is applied to requests.
@item @b{ldapEnabled} @i{(boolean)} Whether external authentication is activated.
@item @b{activeDirectoryDomain} @i{(string)} AD domain to use if AD is enabled in @b{ldapMode}.
@item @b{ldapBaseDN} @i{(string)} LDAP BaseDN to use for external LDAP requests.
@item @b{ldapEncryption} @i{("plain", "ssl", "tls")} Type of LDAP binding to establish to external LDAP server. (Default: "plain").
@item @b{ldapHost} @i{(string)} Hostname of external LDAP server.
@item @b{ldapMode} @i{("standard", "activeDirectory")} Type of LDAP server to use. "standard" is effectively OpenLDAP. (Default: "standard").
@item @b{ldapLoginAttribute} @i{(string)} LDAP attribute to use for usernames. (default: "uid").
@item @b{ldapUsername} @i{(string)} LDAP username.
@item @b{ldapPassword} @i{(string)} LDAP password.
@item @b{ldapUsersDirectory} @i{(string)} Attribute and value to qualify the directory in which to look up users, e.g. "ou=people".
@item @b{ldapPort} @i{(integer)} Port for external LDAP connections not using SSL. (default 389).
@item @b{ldapPort} @i{(integer)} Port for external LDAP connections using SSL. (default 636).
@item @b{blueHostHorizon} @i{(integer)} Time interval (seconds) for when to consider a host unreachable. (default 900).
@item @b{logLevel} @i{("emergency", "alert", "critical", "error", "warning", "notice", "info", "debug")} Syslog filter specifying the severity level at which messages produced by the API should be emitted to syslog and apache.log. (default: error).
@end itemize

@section /api/user
@subsection Supported Operations
@b{GET}
@subsection Query Parameters
@itemize
@item @b{id} @i{(regex string)} Regular expression for filtering usernames.
@item @b{external} @i{("true", "false")} Returns only internal users (false) or only external (true), or all if not specified.
@end itemize

@section /api/user/:id
@subsection Supported Operations
@b{GET}, @b{PUT}, @b{POST}, @b{DELETE}
@subsection Fields
@itemize
@item @b{id} @i{(string)} ID of a user.
@item @b{password} @i{(string)} Password of a user. (Never returned from API).
@item @b{email} @i{(string)} Email address associated with user.
@item @b{roles} @i{(array of strings)} Set of IDs of roles a user is in. (Default: empty)
@item @b{external} @i{(boolean)} Whether or not the user was found externally (LDAP).
@end itemize

@section /api/role
@subsection Supported Operations
@b{GET}

@section /api/role/:id
@subsection Supported Operations
@b{GET}, @b{PUT}, @b{POST}, @b{DELETE}
@subsection Fields
@itemize 
@item @b{id} @i{(string)} ID of a role.
@item @b{description} @i{(string)} Arbitrary text describing the role
@item @b{includeContext} @i{(comma delimited string of regular expression strings)} Includes hosts visible to the users in the role.
@item @b{excludeContext} @i{(comma delimited string of regular expression strings)} Excludes bundles visible to the users in the role.
@item @b{includeBundles} @i{(comma delimited string of regular expression strings)} Includes bundles visible to the users in the role.
@item @b{excludeBundles} @i{(comma delimited string of regular expression strings)} Excludes bundles visible to the users in the role.
@end itemize

@section /api/host
@subsection Supported Operations
@b{GET}
@subsection Query Parameters
@itemize
@item @b{include-context} @i{(comma delimited string of regular expression strings)} Includes hosts having context matching the expression.
@item @b{exclude-context} @i{(comma delimited string of regular expression strings)} Excludes hosts having context matching the expression.
@end itemize

@section /api/host/:host-id
@itemize
@item @b{id} @i{(string)} ID of a host.
@item @b{hostname} @i{(string)} Hostname of a host.
@item @b{ip} @i{(string)} IP address of a host.
@end itemize

@section /api/host/:host-id/context
@subsection Supported Operations
@b{GET}

@section /api/host/:host-id/context/:context-id
@subsection Supported Operations
@b{GET}
@subsection Fields
@itemize
@item @b{id} @i{(string)} ID of a context (class name)
@item @b{mean} @i{(real)} Occurrence probability of the context in an agent run.
@item @b{stdv} @i{(real)} Standard deviation of occurrence probability.
@item @b{timestamp} @i{(integer}) Last time context was activated on agent.
@end itemize

@section /api/host/:host-id/vital
@subsection Supported Operations
@b{GET}

@subsection /api/host/:host-id/vital/:vital-id
@subsection Supported Operations
@b{GET}
@subsection Query Parameters
@itemize
@item @b{from} @i{(integer)} Timestamp marking the start of the interval for which to fetch data. Data is only available going back one week.
@item @b{to} @i{(integer)} End of data interval to be fetched.
@end itemize
@subsection Fields
@itemize
@item @b{id} @i{(string)} ID of vital sign.
@item @b{description} @i{(string)} Description of vital sign.
@item @b{units} @i{(string)} Measurement unit of vital sign.
@item @b{timestamp} @i{(integer)} Timestamp of the last received data point.
@item @b{values} @i{(array of [ t, y ], where t is the sample timestamp)} Vital sign data. 
@end itemize

@section /api/promise
@subsection Supported Operations
@b{GET}

@section /api/promise/:promise-id
@subsection Supported Operations
@b{GET}
@subsection Fields
@itemize
@item @b{id} @i{(string)} Promise handle.
@item @b{type} @i{(string)} Promise type.
@item @b{promiser} @i{(string)} Promiser of the promise.
@item @b{promisees} @i{(array of strings)} A list of promisees of the promise.
@item @b{bundle} @i{(string)} The bundle this promise belongs to
@item @b{comment} @i{(string)} Associated comment for the promise.
@end itemize

@section /api/query
@subsection Supported Operations
@b{POST}
@subsection Fields
@itemize
@item @b{query} @i{(string)} SQL query string.
@item @b{sortColumn} @i{(string)} Column on which to sort results. This is applied to the result of the SQL query and can be considered post processing. The Mission Portal uses this to sort cached reports.
@item @b{sortDescending} @i{(bool)} Apply post-sorting descendingly.
@item @b{skip} @i{(integer)} Number of results to skip for the processed query. The Mission Portal uses this for pagination on cached results.
@item @b{limit} @i{(integer)} Limit the number of results in the processed query.
@end itemize

@section /api/query/async
@subsection Supported Operations
@b{POST}
@subsection Fields
@itemize
@item @b{query} @i{(string)} SQL query string.
@item @b{id} @i{(string)} ID of the query job.
@item @b{error} @i{(string)} Error if anything went wrong.
@end itemize

@section /api/query/async/:async-query-id
@subsection Supported Operations
@b{GET}, @b{DELETE}
@subsection Fields
@itemize
@item @b{id} @i{(string)} ID of the query job.
@item @b{percentageComplete} @i{(integer)} Processing status for the query.
@item @b{href} @i{(string)} Download link for the finished report.
@item @b{error} @i{(string)} Error if anything went wrong.
@end itemize


@bye
