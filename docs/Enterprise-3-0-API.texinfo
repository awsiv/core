\input texinfo-altfont
\input texinfo-logo
\input texinfo
@selectaltfont{cmbright}
@setlogo{CFEngineFrontPage} 

@c *********************************************************************
@c
@c  This is a TEXINFO file. It generates both TEX documentation and
@c  the "on line" documentation "info" files.
@c
@c  The file is structured like a programming language. Each chapter
@c  starts with a chapter comment.
@c
@c  Menus list the subsections so that an online info-reader can parse
@c  the file hierarchically.
@c
@c ***********************************************************************
@c %** start of header
@setfilename st-coredev.info
@settitle CFEngine Enterprise 3.0 API
@setchapternewpage odd
@c %** end of header

@titlepage
@title CFEngine Enterprise 3.0 API
@author CFEngine AS

@vskip 0pt plus 1filll
Copyright @copyright{} 2012 CFEngine AS

@end titlepage

@contents

@c **************************************************
@c CHAPTER
@c **************************************************

@menu
* Introduction::
* API Overview::
* Resources::
@end menu

@node Introduction::
@chapter Introduction

The CFEngine Enterprise API allows HTTP clients to interact with the Hub of a CFEngine Enterprise 3.0 installation. With the Enterprise API, you can..

@itemize
@item Check installation status
@item Manage users, groups and settings
@item Browse host (agent) information and policy
@item Issue flexible SQL queries against data collected by the Hub from agents
@item Schedule reports for email and later download
@end itemize

The Enterprise API is a REST API, but a central part of interacting with the API involves using SQL. This is new in 3.0 and was done to provide users with maximal flexibility for crafting custom reports based on the wealth of data residing on the Hub.

@subsection Basic Properties of the API

@subsubsection HTTP + JSON
The Enterprise API is a conventional REST API in the sense that it has a number of URI resources that support one or more GET, PUT, POST, or DELETE operations. While reporting is done using SQL, this query is always wrapped in a JSON request.

@subsubsection Requests
@b{GET} requests are one of @b{listing} or @b{getting}. @b{Listing} resources means that a number of results will be returned, but each entry may contain limited information. An example of a @b{listing} query is @i{/api/user} to list users. Notice that URI components are always non-plural. An exception to this is @i{/api/settings}, which returns the singleton resource for settings. @b{Getting} a resource specifies an individual resource to return, e.g. @i{/api/user/homer}. @b{PUT} request typically create a new resource, e.g. a user. @b{POST} requests typically updates an existing resource. @b{DELETE} requests are also supported in some cases.

@subsubsection Responses
3.0 responses are always of the following format, consisting of a @b{meta} object and a @b{data} array.
@verbatim
{
  ``meta'': {
    ``page'': 1,
    ``count'': 1,
    ``total'': 1,
    ``timestamp'': 1350922925
  },
  ``data'': [
     ... 
  ]
}
@end verbatim

@b{page} refers to the current page number of the request. @b{count} is the number of results in the current page, equaling the length of the @b{data} array. @b{total} is the number of results in all available pages combined. @b{timestamp} is the time the request was processed by the API. The @b{data} array is resource dependent, but will always contain objects. Response objects typically do not contain error codes. If the response is not @i{200 OK}, the appropriate HTTP error code returned along with a (possibly non-JSON) payload.

@subsubsection Pagination
Pagination is handled by @b{page} and @b{count} query parameters to a @b{GET} request, e.g. @i{/api/user?page=5&count=30} to get the 5th page of pages of 30 entries each. The default @b{page} is 1 and the default @b{count} is 50 if these are not specified explicitly.

@subsubsection Time
All timestamps are reported in @i{Unix Time}, i.e. seconds since 1970.

@subsubsection Authentication
The API supports both internal and external authentication. The internal users table will always be consulted first, followed by an external source specified in the settings. External sources are @i{OpenLDAP} or @i{Active Directory} servers configurable through @i{POST /api/settings}.

@subsubsection Authorization
Some resources require that the request user is a member of the @i{admin} role. Roles are managed with @i{/api/role}. @b{Role-Based Access Control (RBAC)} is configurable through settings. Users typically have permission to access their own resources, e.g. their own scheduled reports.

@subsection Differences between the CFEngine Nova 2.2 REST API and the CFEngine Enterprise 3.0 API.

@subsubsection Read vs. Read/Write
The 2.2 API was read-only and users, roles and settings was managed by the Mission Portal. By contrast, the 3.0 API is read/write and completely standalone from the Mission Portal. In the CFEngine Enterprise 3.0, users, roles and settings belong in the API, and the Mission Portal uses this to determine access to data. Additionally, some other resources support PUT, POST and DELETE, but most data collected from agents are read-only.

@subsubsection Built-in Reports vs. Reporting Engine
The 2.2 API provided an almost one-to-one correspondance between the reports in the Mission Portal and the API. One of the big changes in CFEngine Enterprise 3.0 is the advent of SQL reports. This is provided to the Mission Portal through the API, and you can use it too. You may issue both synchronous and asynchronous reporting requests, and optionally schedule reports to be received by email.

@subsubsection Content-Type
The 2.2 API has a HTTP content-type @code{application/vnd.cfengine.nova-v1+json}. In the 3.0 API the content-type is @code{application/vnd.cfengine.enterprise-v1+json}. This reflects a branding change away from Nova to Enterprise.

@subsubsection New Users
The 2.2 API used credentials from the Mission Portal database to authenticate and authorize users. These users have been moved into the Hub database and security has been strengthened. We are now using salted SHA256 passwords for the user table. Unfortunately, this means that internal users need to be recreated. The Mission Portal now relies on the API for authentication and authorization. This was partially done to support multi-hub installations.

@subsubsection Base Path
The 2.2 API had a base path @code{/rest}. In the 3.0 API the base path is @code{/api}.

@subsubsection Still available
In 3.0, the old 2.2 API is still available along side the new 3.0 API, so you can keep calling the old API if needed.

@subsubsection Mission Portal
Starting in 3.0, most of the API is exercised by the Mission Portal web-UI.

@chapter Checking Status
You can get basic info about the API by issuing @i{GET /api}. 




@chapter Managing Settings
Most of the settings configurable in the API relate to LDAP authentication of users. Settings support two operations, @b{GET} and @b{POST}.





@c *****************************************************
@c * CHAPTER
@c *****************************************************
@node API Overview::, Resources, Introduction
@chapter API Overview::

The API is composed of a set of HTTP resources available by issuing an HTTP GET request to the resource URI. The available resources at the top-level are:

@itemize -
@item @b{Status} @code{/rest/}: Version information and database connectivity status.
@item @b{Contexts} @code{/rest/context}: Occurrences of contexts (classes) at hosts
@item @b{Hosts} @code{/rest/host}: Host information and last seen records. 
@item @b{Promises} @code{/rest/promise}: Promise compliance, logs and log summaries.
@item @b{Setuid Programs} @code{/rest/setuid}: Programs running with the setuid flag.
@item @b{Software} @code{/rest/software}: Installed software.
@item @b{Variables} @code{/rest/variable}: Policy variables and their most recent values.
@item @b{File Changes} @code{/rest/file}: Host file changes and their diffs if available.
@end itemize

@section Response Codes
We have taken some care to return appropriate HTTP error codes and descriptive messages for responses. However, because the API is read-only, the set of codes a client should expect is limited. Some error codes an API should be able to handle are:

@itemize -
@item @b{200 OK}. This is the response you should normally expect when querying the API.
@item @b{400 Bad request}. Usually indicates that query parameters where not accepted or malformed.
@item @b{401 Unauthorized}. Client credentials did not authenticate.
@item @b{403 Forbidden}. Client requested a specific resource that was denied by RBAC.
@item @b{404 Not found}. A non-existing resource was requested.
@item @b{406 Not Acceptable}. Unable to accomodate the @code{Accept} header of the request.
@item @b{500 Internal Error}. Usually this means that there was a database connectivity problem. If not, it may indicate a bug.
@end itemize

@section Response Bodies
The response body always consists of two elements, @code{meta} and @code{data}. @code{meta} always contains the fields @code{total} (the total number of results matched by the query), @code{page} (the page index returned), @code{count} (the number of results on the returned page) and @code{timestamp}. @code{data} contains the result set. Here is an example.

@verbatim
{
  "meta": {
    "total": 1,
    "timestamp": 1329315702,
    "page": 1,
    "count": 1
  },
  "data": [{
    "apiName": "CFEngine Nova",
    "apiVersion": "v1",
    "hubVersion": "2.2.0.a1.rexported",
    "database": "connected"
  }]
}
@end verbatim

@b{Note}: For the remainder of this document we show only the contents of the @code{data} field for the sake of brevity.

@section Common Query Parameters
Each resource accept their own set of query parameters, but we have attempted to keep to keep this set uniform within reason across resources. Moreover, a common set of query parameters will be accepted for all resources (and observed where it makes sense).

@itemize -
@item @b{count}: The number of results to return per page. Default is 50.
@item @b{page}: The index of the results page to return: Default is 1.
@item @b{from}: Unix timestamp before which we discard records as too old. Default is 0.
@item @b{to}: Unix timestamp after which we discard records as too new. Default is current time.
@end itemize

@b{Note}: that Software and Setuid resources currently do not support time ranges.

@section Time
Unless otherwise specified, all timestamps or durations are in seconds. Timestamps are reported in Unix time, i.e. seconds since 1970.

@section Versioning and Content-Types
Clients may specify the version of the API to use by appending an @code{Accept} header to a request with an appropriate content-type. The server responds in turn by appending a @code{Content-Type} header to the response, encoding the API version employed. The content-type is a vendor MIME-type of the form @code{application/vnd.cfengine.nova-v<N>+<format>}. We only support JSON in this first release of the API, so the content-type header will be @code{application/vnd.cfengine.nova-v1+json}. If no @code{Accept} header is specified by the client, the server will always return the most recent version available. It is the responsibility of the client to request the desired version and condition on the type of response. In the future, the version will only be bumped in the event of breaking backward-compatibility, not merely adding new resources or options.

@section Authentication
The REST API uses HTTP basic authentication. Unauthenticated requests will receive a @code{401} response with a @code{WWW-Authenticate} header. Clients are required to append an @code{Authorization: Basic <key>} header to each request (since REST is stateless, there is no notion of session state). The key is a Base64 encoded string of the format @code{<username>:<password>}. (Note that clients such as web-browsers and @code{curl} handle basic authentication seamlessly). This means that the username and password is transmitted effectively as plaintext. Encryption is commonly handled through SSL at the HTTP server.

@subsection Role-based Access Control
The user table is the same as for the Mission Portal and is stored either in the database or delegated to LDAP. The REST API also works in conjunction with Role-based Access Control (RBAC). Most requests are effectively searches across multiple dimensions, and RBAC may render the result set empty without providing an authorization error. However, when requesting specific resources a client should be prepared for a @b{403 Forbidden}.




@c *****************************************************
@c * CHAPTER
@c *****************************************************
@node Resources,  , API Overview::
@chapter Resources


@section Status

@itemize -
@item @b{URI Path}: @code{/rest/}
@item @b{Query Parameters}: (common only)
@end itemize

The Status resource serves as a simple way to to see if the API is alive and to check which version of Nova it is running. Note that the Nova database (MongoDB) needs to be running in order to authenticate. The Status resource serves as a good starting point to demonstrate simple usage. Here we use @code{curl}, a command-line client. The @code{-v} flag shows the full HTTP request and response returned.

@verbatim
curl --user admin:admin -v http://localhost:8888/rest

* About to connect() to localhost port 8888 (#0)
*   Trying 127.0.0.1... connected
* Connected to localhost (127.0.0.1) port 8888 (#0)
* Server auth using Basic with user 'admin'
> GET /rest HTTP/1.1
> Authorization: Basic YWRtaW46YWRtaW4=
> User-Agent: curl/7.21.6 (x86_64-pc-linux-gnu) libcurl/7.21.6 OpenSSL/1.0.0e zlib/1.2.3.4 libidn/1.22 librtmp/2.3
> Host: localhost:8888
> Accept: */*
> 
< HTTP/1.1 200 OK
< Server: nginx/1.0.5
< Date: Mon, 13 Feb 2012 17:23:39 GMT
< Content-Type: application/vnd.cfengine.nova-v1+json
< Transfer-Encoding: chunked
< Connection: keep-alive
< X-Powered-By: PHP/5.3.6-13ubuntu3.5
< Allow: GET
< X-Resource: Base
< 
{"status":"ok","timestamp":1329316866,"page":1,"count":50,"total":1,"result":
 {"apiName":"CFEngine Nova","apiVersion":"v1","hubVersion":"2.2.0.a1.rexported",
  "database":"connected"}}
* Connection #0 to host localhost left intact
* Closing connection #0
@end verbatim

Note that the REST API compacts the JSON response rather than pretty-printing it. It is possible to pipe the response from curl into a json prettifier at the command-line. Another option is to use a plugin for a browser like Firefox (e.g. RESTClient).

@section Contexts

A context (previously class) resource describes the probability of occurrence of a context at a host. Contexts are either defined or not defined during a single run of agent execution.

@itemize -
@item @b{URI Path}: /rest/context
@item @b{Query Parameters}:

@itemize @bullet
@item @b{hostkey}: Host the context occurs at.
@item @b{context}: A regular expression to filter on contexts active at host.
@end itemize

@end itemize

Example of a typical body from a context response:

@verbatim
[
  {
    "hostkey": "SHA=33736d45041e2a9407be8cf449aeffa95114bef661c20deaca1bbcfbc2922856",
    "context": "entropy_udp_in_low",
    "average": 0.7000,
    "stdv": 0.8367,
    "lastseen": 1328194134
  },
  ...
]
@end verbatim

The average and standard deviation refer to the frequency with which the context is observed in agent runs at the host.

@section Hosts

Hosts are naturally fundamental to CFEngine, being the environment in which @code{cf-agent} runs. The REST API allows you to get at some basic information about hosts which agents have corresponded with the Hub. Hosts are universally identified by their @code{hostkey} - a SHA1 identifier. To list hosts visibile to the Hub, we can issue the following

@subsection Listing hosts
@itemize -
@item @b{URI Path}: @code{/rest/host}
@item @b{Query Parameters}:

      @itemize @bullet
      @item @b{hostname}: Name of host.
      @item @b{ip}: IP-address of host.
      @item @b{context}: Context active at host (Regular Expression).
      @end itemize

@end itemize

The base host resource simply returns a list of matching keys.

@verbatim
[
  "SHA=305658693b94e003e765956f1609731419cbc0e5c9caa09e230df5e005f1f283",
  "SHA=33736d45041e2a9407be8cf449aeffa95114bef661c20deaca1bbcfbc2922856"
]
@end verbatim

@subsection Basic Host Information
Now, we can get the name and IP of a particular host, providing the hostkey.

@itemize -
@item @b{URI Path}: @code{/rest/host/:id}
@item @b{Query Parameters}: (common only)
@end itemize

@verbatim
{
  "hostkey": "SHA=305658693b94e003e765956f1609731419cbc0e5c9caa09e230df5e005f1f283",
  "name": "hostA",
  "ip": "10.0.0.150"
}
@end verbatim

Note that there are tons of other information we could have returned about the host, such as variables. You can get that by issuing requests like @code{/rest/variable?hostkey=SHA...}. As we need the capability of searching in variables by other properties than hostkey, we have opted to keep a separate variable resource, rather than a @code{/rest/host/:id/variable}.

@subsection Hosts Seen

Next, we can get information about which hosts a host has seen or has been seen by.

@itemize -
@item @b{URI Path}: @code{/rest/host/:id/seen}
@item @b{Query Parameters}: (common only)
@end itemize

@verbatim
[
  {
    "hostkey": "SHA=33736d45041e2a9407be8cf449aeffa95114bef661c20deaca1bbcfbc2922856",
    "lastseen": 108,
    "average": 108,
    "stdv": 180
  },
  ...
]

@end verbatim

We can also discover when agents at other hosts discovered a given host. The format of the body of the response is the same - only the URI path is different.

@itemize -
@item @b{URI Path}: @code{/rest/host/:id/seen-by}
@item @b{Query Parameters}: (common only)
@end itemize


@section Promises

Promises are the statements executed by CFEngine agents. We provide three views of promise execution results: Compliance, Log and Log Summary.

@subsection Promise Compliance

Promise Compliance is the current status of promises in the system and their aggregated statistics.

@itemize -
@item @b{URI Path}: @code{/rest/promise/compliance}
@item @b{Query Parameters}:

      @itemize @bullet
      @item @b{hostkey}: Host of agent executing the promise.
      @item @b{handle}: Handle of promise.
      @item @b{context}: Context of agent executing the promise (Regular Expression).
      @item @b{state}: Result state of promise, valid values are: @code{kept}, @code{notkept} and @code{repaired}.
      @end itemize

@end itemize

Here is an examplary response:

@verbatim
[
  {
    "handle": "cfengine_correct_cftwin_files_libtwin",
    "hostkey": "SHA=33736d45041e2a9407be8cf449aeffa95114bef661c20deaca1bbcfbc2922856",
    "state": "kept",
    "average": 100.0000,
    "stdv": 0.0000,
    "timestamp": 1328194134
  },
  ...
]
@end verbatim

@subsection Promise Log

A promise ends up in the promise log if the agent managed to repair a previously broken promise, or if a promise was broken. These are held as two separate logs by the Nova database, so we have opted to require the requestor to specify which log to look at, effectively specifying either state @code{repaired} or @code{notkept}. The results are the same for both states. 

@itemize -
@item @b{URI Path}: @code{/rest/promise/log/repaired} or @code{/rest/promise/log/notkept}
@item @b{Query Parameters}:

      @itemize @bullet
      @item @b{hostkey}: Host of agent executing the promise.
      @item @b{handle}: Handle of promise.
      @item @b{context}: Context of agent executing the promise (Regular Expression).
      @item @b{to}: In addition to the common @b{from} parameter, discards entries newer than this upper bound.
      @end itemize

@end itemize

Example response:

@verbatim
[
  {
    "handle": "garbage_collection_files_tidy_outputs",
    "hostkey": "SHA=305658693b94e003e765956f1609731419cbc0e5c9caa09e230df5e005f1f283",
    "description": " -> Deleted file /var/cfengine/outputs/cf_policy_test_cfengine_com__1326972365_Thu_Jan_19_12_26_05_2012_0x7ff1b940f700",
    "state": "repaired",
    "timestamp": 1327577464
  },
  ...
]
@end verbatim

Note that the description field is the collected output from the agent, in this case having repaired a promise.

@subsection Promise Log Summary

Promise log summaries provides an aggregated view of log messages by grouping similar agent reports and counting them up.

@itemize -
@item @b{URI Path}: @code{/rest/promise/log/repaired/summary} or @code{/rest/promise/log/notkept/summary}
@item @b{Query Parameters}:

      @itemize @bullet
      @item @b{hostkey}: Host of agent executing the promise.
      @item @b{handle}: Handle of promise.
      @item @b{context}: Context of agent executing the promise (Regular Expression).
      @item @b{to}: In addition to the common @b{from} parameter, discards entries newer than this upper bound.
      @end itemize

@end itemize

Example response:

@verbatim
[
  {
    "handle": "cfengine_correct_cftwin_files_libtwin",
    "description": "Can't stat /var/cfengine/lib in files.copyfrom promise",
    "count": 4,
    "state": "notkept"
  },
  ...
]
@end verbatim

From this response, we can deduce that the promise @code{cfengine_correct_cftwin_files_libtwin} failed four times across all hosts.

@section Setuid Programs

Setuid programs is a special report provided by agents about which programs are running with the setuid flag set.

@itemize -
@item @b{URI Path}: @code{/rest/setuid}
@item @b{Query Parameters}:

      @itemize @bullet
      @item @b{hostkey}: Host where the setuid program is running.
      @item @b{path}: Path of the setuid program (Regular Expression).
      @item @b{context}: Context active at host (Regular Expression).
      @end itemize

@end itemize

Example response:

@verbatim
[
  {
    "path": "/usr/sbin/pppd",
    "hostkeys": [
      "SHA=305658693b94e003e765956f1609731419cbc0e5c9caa09e230df5e005f1f283"
    ]
  },
  ...
]
@end verbatim

@section Software

The agent reports on which software is currently installed on the host.

@itemize -
@item @b{URI Path}: @code{/rest/software}
@item @b{Query Parameters}:

      @itemize @bullet
      @item @b{hostkey}: Host where the software is installed.
      @item @b{name}: Name of the software.
      @item @b{version}: Version of the software.
      @item @b{arch}: Architecture of the software.
      @item @b{context}: Context active at host (Regular Expression).
      @end itemize

@end itemize

Example response:

@verbatim
[
  {
    "name": "sed",
    "version": "4.1.5-5.fc6",
    "arch": "x86_64",
    "hostkeys": [
      "SHA=33736d45041e2a9407be8cf449aeffa95114bef661c20deaca1bbcfbc2922856"
    ]
  },
  ...
]
@end verbatim

@section Variables

Variables are similar to contexts in that they are either built-in (hard) or promises (soft). In contrast to contexts, variables may assume a range of value types, whereas contexts are either defined or not defined. The scope of the variable is the name of the bundle (container of promises) where it was defined. In the case of variables redefined during execution, the final value is reported.

@itemize -
@item @b{URI Path}: @code{/rest/variable}
@item @b{Query Parameters}:

      @itemize @bullet
      @item @b{hostkey}: Host where the variable promise was executed.
      @item @b{scope}: Name of the variable.
      @item @b{name}: Name of the variable.
      @item @b{value}: Value of the variable.
      @item @b{type}: Type of the variable (see Variable Types).
      @item @b{context}: Context active at host (Regular Expression).
      @end itemize

@end itemize

@subsection Variable Types

Variables are either lists of scalars, or scalars. The following are scalar types.

@itemize @bullet
@item @b{string}
@item @b{int}
@item @b{real}
@item @b{menu} (an enumerated value)
@end itemize

Correspondingly, the list types are @code{slist}, @code{ilist}, @code{rlist} and @code{mlist}.

Here is an example response to a variable request.

@verbatim
[
  {
    "hostkey": "SHA=33736d45041e2a9407be8cf449aeffa95114bef661c20deaca1bbcfbc2922856",
    "scope": "control_runagent",
    "name": "hosts",
    "type": "slist",
    "value": [
      "127.0.0.1"
    ]
  },
  {
    "hostkey": "SHA=33736d45041e2a9407be8cf449aeffa95114bef661c20deaca1bbcfbc2922856",
    "scope": "control_reporter",
    "name": "style_sheet",
    "type": "string",
    "value": "/cf_enterprise.css"
  },
  ...
]
@end verbatim

@section File Changes

The agent is able to monitor files for changes, and optionally produce a diff for the changes.

@itemize -
@item @b{URI Path}: @code{/rest/file}
@item @b{Query Parameters}:

      @itemize @bullet
      @item @b{hostkey}: Host where the software is installed.
      @item @b{path}: Path of file changed (Regular Expression)
      @item @b{context}: Context active at host (Regular Expression).
      @end itemize

@end itemize

Here is an example of a two file files, one for which a diff was also captured.

@verbatim
[
    {
        "hostkey": "SHA=305658693b94e003e765956f1609731419cbc0e5c9caa09e230df5e005f1f283",
        "path": "/etc/passwd",
        "timestamp": 1234567
    },
    {
        "hostkey": "SHA=305658693b94e003e765956f1609731419cbc0e5c9caa09e230df5e005f1f283",
        "path": "/etc/group",
        "timestamp": 1234567,
        "diff": {
            "type": "add",
            "line": 5,
            "value": "sambashare:x:124:a10021"
        }
    },
    ...
]

@end verbatim


@bye
