<html lang="en">
<head>
<title>Modularizing and Orchestrating System Policy</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Modularizing and Orchestrating System Policy">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
@font-face {
    font-family: 'CFE_FONT';
    src: url('fonts/eot/opensans-regular-webfont.eot');
    src: local('â˜º'),  url('fonts/ttf/opensans-regular-webfont.ttf') format('truetype'), url('fonts/svg/opensans-regular-webfont.svg') format('svg');
    font-weight: normal;
    font-style: normal;
}    
pre {
    background-color: #EEFFDD;
    border: 1px solid #CCCCCC;
    font-family: courier;
    margin-bottom: 10px;
    margin-top: 10px;
    padding: 5px;
    font-size: 90%;
    }
pre.display { font-family:inherit }
pre.format  { font-family:inherit }
pre.smallexample
pre.smalllisp,
pre.smallformat,
pre.smalldisplay {
  font-size: 90%;
} 

span.sc    { font-variant:small-caps }
span.roman { font-family:serif; font-weight:normal; } 
span.sansserif { font-family:sans-serif; font-weight:normal; } 

body {
    font:  90%  'CFE_FONT', arial, Helvetica,sans-serif; 
    color: #646464;
    padding: 10px 20px;
    width: 960px;
    margin: 0 auto;
}
.node
{
    text-align: right;
    padding: 2px;
    font-size: smaller;
}
.node hr {
    border: 0;
    width: 100%;
    color: #CCC;
    background-color: #CCC;
    height: 5px;
}
.section {
    padding-right: 0px;
    padding-bottom: 0px;
    padding-left: 0px;
}

h1 {
    font-size: 26px;
    font-weight: normal;
    line-height: 32px;
    margin: 32px 0 16px;
    text-align: left;
    text-transform: uppercase;
}

h2 {
    color: #9E9981 !important;
    font-size: 16px;
    line-height: 18px;
    font-weight: normal;
    margin: 16px 0 26px;
    text-align: left;
}
h3 {
    margin-top: 3px;
    margin-right: 0px;
    margin-bottom: 10px;
    margin-left: 0px;
    line-height: 20px;
    font-size: 16px;
    font-weight: normal;
}

.contents
{
    background-color: #CCC;
    padding-top: 2px;
    padding-right: 2px;
    padding-bottom: 2px;
    padding-left: 10px;
}

.index-cp
{  
background: #fff url(index-cp.png) right repeat-y;
}

.index-vr
{  
background: #fff url(index-vr.png) right repeat-y;
}

.index-mb
{  
background: #eee url(index-faq.png) right repeat-y;
}

table.border
{
	border-color: #666;
	border-width: 0px;
}

FONT.liten {font-size: 80%; }
 
.tynn {
    font-family: Arial, Helvetica, sans-serif;
    font-size: smaller;
    font-style: normal;
    font-weight: lighter;
    margin-bottom: 0em;
    font-size: 11pt;
}
.verbatim {
    color: #000;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 20px;
    margin-left: 0px;
}
.example {
    color: #000;
    width: 100%;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 20px;
    margin-left: 0px;
}
.smallexample {
    color: #000;
    padding-top: 10px;
    padding-right: 30px;
    padding-bottom: 5px;
    padding-left: 30px;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 0px;
    margin-left: 0px;
}
.cartouche {
    padding: 5px;
    font-style: italic;
    font-size: 85%;
}

table.cartouche {
    border: none !important;
}

 .cartouche td  {
    background-color: #ddd;
    border: 1px solid #ccc;
    padding: 5px;
}

A:link { color: #2c2e70 }
A:visited { color: black }
A:active { color: #600041 }
dt em {font-weight: bold}
/* don't change this rule */    
pre.sp {
    background: none !important;   
    border:none !important
}
/* --- */
/*code hightlight*/
.red { color: #b80047; font-weight: bold; }

.blue { color: blue;  /*font-weight: bold;*/ }

.green { color: darkgreen; }

.comment { font-style: italic; }
--></style>
</head>
<body>
<h1 class="settitle">Modularizing and Orchestrating System Policy</h1>
<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-is-modularity_003f">What is modularity?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">Orchestration</h2>

<ul class="menu">
<li><a accesskey="1" href="#What-is-modularity_003f">What is modularity?</a>
<li><a accesskey="2" href="#What-is-orchestration_003f">What is orchestration?</a>
<li><a accesskey="3" href="#How-does-CFEngine-deal-with-modularity-and-orchestration_003f">How does CFEngine deal with modularity and orchestration?</a>
<li><a accesskey="4" href="#Levels-of-policy-abstraction">Levels of policy abstraction</a>
<li><a accesskey="5" href="#Is-CFEngine-patch-or-package-oriented_003f">Is CFEngine patch or package oriented?</a>
<li><a accesskey="6" href="#High-level-services-in-CFEngine">High level services in CFEngine</a>
<li><a accesskey="7" href="#Hiding-details">Hiding details</a>
<li><a accesskey="8" href="#Black">Black</a>
<li><a accesskey="9" href="#Bulk-operations-are-handled-by-repeating-patterns-over-lists">Bulk operations are handled by repeating patterns over lists</a>
<li><a href="#Ordering-operations-in-CFEngine">Ordering operations in CFEngine</a>
<li><a href="#Bundle-ordering">Bundle ordering</a>
<li><a href="#Overriding-order">Overriding order</a>
<li><a href="#Distributing-Ordering-between-hosts-with-CFEngine-Nova">Distributing Ordering between hosts with CFEngine Nova</a>
</ul>

   <p><a href="#Contents"><h1>COMPLETE TABLE OF CONTENTS</h1></a>
<h2>Summary of contents</h2>

<div class="node">
<a name="What-is-modularity%3f"></a>
<a name="What-is-modularity_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-is-orchestration_003f">What is orchestration?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">What is modularity?</h3>

<pre class="sp">

</pre>
Modularity is the ability to separate concerns within a total process, and hide
the details of the different concerns in different containers. In CFEngine, this is a
<i>service oriented view</i>, in which different aspects of a problem are
separated and turned into generic components that offer a service.  We
often talk about black boxes, grey boxes or white boxes depending on
the extent to which the user of a service can see the details within
the containers.

<div class="node">
<a name="What-is-orchestration%3f"></a>
<a name="What-is-orchestration_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-does-CFEngine-deal-with-modularity-and-orchestration_003f">How does CFEngine deal with modularity and orchestration?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-is-modularity_003f">What is modularity?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">What is orchestration?</h3>

<pre class="sp">

</pre>
Orchestration is the ability to coordinate many different processes in
a system so that the sum of those processes yields a harmonious result. 
Orchestration is not about centralized control, though this is common
misperception.

   <p>An orchestra does not manage to play a symphony because the conductor
pulls every player's strings or blows every trumpet in person, but
rather because each <i>autonomous</i> player has a copy of the script,
knows what to do, and can use just the little additional information
from the conductor to access a viewpoint that is not available to an
individual. An orchestra is a weakly coupled expert system in which
the management (conductor) provides a service to the players.

   <p>CFEngine works like an orchestra &ndash; this is why is scales so well. 
Each computer is an autonomous entity, getting its script and a few
occasional pieces of information from the policy server (conductor). 
The coupling between the agents is weak &ndash; there is slack that makes
the behaviour robust to minor errors in communication or timing.

<div class="node">
<a name="How-does-CFEngine-deal-with-modularity-and-orchestration%3f"></a>
<a name="How-does-CFEngine-deal-with-modularity-and-orchestration_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Levels-of-policy-abstraction">Levels of policy abstraction</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-is-orchestration_003f">What is orchestration?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">How does CFEngine deal with modularity and orchestration?</h3>

<p>Promise Theory provides simple principles for hiding details: agents are
considered to reveal a kind of <i>service interface</i> to peers, that is
advertised by making a promise to someone.  We assume an agent exerts
best effort in keeping its promises. Orchestration requires a promise
to coordinate and the promise to use that coordination service. 
These basic ideas are built into CFEngine.

   <p>CFEngine provides containers called <i>bundles</i> for creating modular
parts. Bundles can be independent (and therefore parallelizable)
or they can be dependent (in which case the sequence in which they
verify their promises matters).

   <p>In a computer centre with many different machines, there is an
additional dimension to orchestration &ndash; multiple orchestras. Each
machine has a number of resources that need to be orchestrated, and
the different machines themselves might also need to cooperate because
they provide services to one another. The principles are the same in
both cases, but the confusion between them is typically the reason why
large systems do not scale well.

<div class="node">
<a name="Levels-of-policy-abstraction"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Is-CFEngine-patch-or-package-oriented_003f">Is CFEngine patch or package oriented?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-does-CFEngine-deal-with-modularity-and-orchestration_003f">How does CFEngine deal with modularity and orchestration?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Levels of policy abstraction</h3>

<p>CFEngine offers a number of layers of abstraction. The most fundamental atom
in CFEngine is the promise. Promises can be made about many system issues,
and you described in what context promises are to be kept.

     <dl>
<dt><i>Menu level</i><dd>At this high level, a user `selects' from a set of pre-defined `services' (or bundles in CFEngine parlance). 
In commercial editions, users may view the set of services as a Service Catalogue, from which each
host selects its roles. The selection is not made by every host, rather one places hosts into roles that
will keep certain promises, just as different voices in an orchestra are assigned certain parts to play.

     <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
     <pre class="smallexample">          bundle agent service_catalogue # menu
          {
          methods:
            any:: # selected by everyone
               "everyone" usebundle =&gt; <b>time_management</b>,
                          comment =&gt; "Ensure clocks are synchronized";
               "everyone" usebundle =&gt; garbage_collection,
                          comment =&gt; "Clear junk and rotate logs";
          
            mailservers:: # selected by hosts in class
              "mail server"  -&gt; { "goal_3", "goal_1", "goal_2" }
                            usebundle =&gt; <b>app_mail_postfix</b>,
                              comment =&gt; "The mail delivery agent";
              "mail server"  -&gt; goal_3,
                            usebundle =&gt; <b>app_mail_imap</b>,
                              comment =&gt; "The mail reading service";
              "mail server"  -&gt; goal_3,
                            usebundle =&gt; <b>app_mail_mailman</b>,
                              comment =&gt; "The mailing list handler";
          }
</pre>
     </td></tr></table>

     <p>The resulting menu of services can be browsed in the Mission Portal interface. 
<div class="float">
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="service_catalogue.png" alt="iso"></div>
     <div align="center">A human-readable Service Catalogue generated from technical specifications</div>
     <div align="center">shows what goals are being attended to automatically</div>
     <pre class="sp">
     
     </pre>
     <p><strong class="float-caption"></strong></p></div>

        <br><dt><i>Bundle level</i><dd>At this level, users can switch on and off predefined features, or re-use
standard methods, e.g. for editing files:

        <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="verbatim">     body agent control 
     { 
     bundlesequence => {
                       webserver("on"),
                       dns("on"),
                       security_set("on"),
                       ftp("off")
                       };
     }
</pre>
</td></tr></table>
        The set of bundles that can be selected from is extensible by the user.

        <br><dt><i>Promise level</i><dd>This is the most detailed level of configuration, and gives full
<i>convergent</i> promise behaviour to the user.  At this promise level,
you can specificy every detail of promise-keeping behaviour, and
combine promises together, reusing bundles and methods from standard
libraries, or creating your own.

        <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
     <pre class="smallexample">          bundle agent addpasswd
          {
          vars:
          
            # want to set these values by the names of their array keys
          
            "pwd[mark]" string =&gt; "mark:x:1000:100:Mark B:/home/mark:/bin/bash";
            "pwd[fred]" string =&gt; "fred:x:1001:100:Right Said:/home/fred:/bin/bash";
            "pwd[jane]" string =&gt; "jane:x:1002:100:Jane Doe:/home/jane:/bin/bash";
          
          files:
          
            "/etc/passwd"           # Use standard library functions
                  create =&gt; "true",
                 comment =&gt; "Ensure listed users are present",
                   perms =&gt; mog("644","root","root"),
               edit_line =&gt; append_users_starting("addpasswd.pwd");
          
          }
</pre>
        </td></tr></table>

        <br><dt><i>Spread-sheet level</i><dd>
CFEngine commercial editions support a spreadsheet
In a spreadsheet approach, you create only the data to be inserted into predefined
promises. The data are entered in tabular form, and may be browsed in the web interface. 
This form of entry is preferred in some environments, especially on the Windows platform.

     <div align="center"><img src="cdp_services_report.png" alt="The Content-Driven Policy services report"></div>
     <div align="center">Content-Driven Policies</div>

   </dl>

<div class="node">
<a name="Is-CFEngine-patch-or-package-oriented%3f"></a>
<a name="Is-CFEngine-patch-or-package-oriented_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#High-level-services-in-CFEngine">High level services in CFEngine</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Levels-of-policy-abstraction">Levels of policy abstraction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Is CFEngine patch-oriented or package-oriented?</h3>

<p>Some system management products are patching systems. They package lumps
of software and configuration along with scripts. If something goes wrong
they simply update or replace the package with a new one. This is a patching
model of system installation, but it is not a good model for repair as it nearly
always leads to interruption of service or even requires a reboot.

   <p>Installation of packages overwrites too much data in one go to be an effective model
of simple repair<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>. It can be both ineffecient and destructive. CFEngine manages addressable
entities at the lowest possible level so that ultra-fine-grained repair can be
performed with no interruption of service, e.g. altering a field within a line in a file,
or restarting one process, or altering one bit of a flag in each file in a set of directories. 
The power to express sophisticated patterns is what makes CFEngine's approach both
non-intrusive and robust.

<div class="node">
<a name="High-level-services-in-CFEngine"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Hiding-details">Hiding details</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Is-CFEngine-patch-or-package-oriented_003f">Is CFEngine patch or package oriented?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">High level services in CFEngine</h3>

<p>CFEngine is designed to handle high level simplicity (without
sacrificing low level capability) by working with configuration
<i>patterns</i>, after all configuration is all about promising
consistent patterns of system <i>state</i> in the resources of the
system. Lists, for instance, are a particularly common kind of
pattern: <i>for each of the following... make a similar promise</i>. 
There are several ways to organize patterns, using containers, lists
and associative arrays. Let's look at how to configure a number of
application services.

   <p>At the simplest or highest level, we can turn services into "genes"
to switch on and off on your basic "stem cell" machines.

<pre class="verbatim">body agent control 
{ 
bundlesequence => {
                  webserver("on"),
                  dns("on"),
                  security_set("on"),
                  ftp("off")
                  };
}
</pre>

   <p>This obviously looks simple, but this kind of simplicity is cheating
as we are hiding <i>all</i> the details of what is going to happen &ndash; we
don't know if they are hard-coded, or whether we can decide
ourselves. Anyone can play that game! The true test is whether we can
retain the power to decide the low-level details without having to
program in a low level language like Ruby, Python or Perl. Let's peel
back some of the layers, knowing that we can hide as many of the
details as we like.

   <p>A simple, but low level approach to deploying a service, that veteran
users will recognize, is the following. This is a simple example of
orchestration between a promise to raise a signal about a missing process and
another promise to restart said process once its absence has been
discovered and signalled.

<pre class="verbatim">bundle agent application_services
{
processes:

  "sshd"  restart_class => "start_ssh";
  "httpd" restart_class => "start_spache";

commands:

 start_ssh::
   "/etc/init.d/sshd restart";

 start_apache::
   "/etc/init.d/apache restart";

}
</pre>

   <p>But the first thing we see is that there is a repeated pattern, so we could
rewrite this as a single promise for a list of services, at the cost of a loss
of transparency. However, this is the power of abstraction.

<pre class="verbatim">bundle agent application_services
{
vars:

  "service" slist => { "ssh", "apache", "mysql" };

 #
 # Apply the following promises to this list...
 #

processes:

  "$(daemon[$(service)])" restart_class => canonify("start_$(service)");

commands:

   "$(start[$(service)])"
       ifvarclass => canonify("start_$(service)");

}
</pre>

   <p>This assumes that we can define the necessary information about these
services in array variables of the form <code>$(array[index])</code>. 
This is what other tools refer to as a <i>resource abstraction layer</i>,
though in some other tools this layer has to be partially hard-coded. 
We can see some more approaches below, but let's look at this abstraction for a moment.

<div class="node">
<a name="Hiding-details"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Black">Black</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#High-level-services-in-CFEngine">High level services in CFEngine</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Hiding details</h3>

<p>Resource abstraction, or hiding system specific details inside a kind of
grey-box, is just another service as far as CFEngine is concerned &ndash; and we
generally map services to bundles.

   <p>Many system variables are discovered automatically by CFEngine and provided
"out of the box", e.g. the location of the filesystem table might be <code>/etc/fstab</code>,
or <code>/etc/vfstab</code> or even <code>/etc/filesystems</code>, but CFEngine allows you to
refer simply to <code>&lt;b&gt;$(sys.fstab)&lt;/b&gt;</code>. Soft-coded abstraction needs cannot
be discovered by the system however. 
So how do we create this mythical resource abstraction layer? It is
simple.  Elsewhere we have defined basic settings.

<pre class="verbatim">bundle common res # abstraction layer
{
vars:

  solaris::

   "cfg_file[ssh]" string => "/etc/sshd_config";
   "daemon[ssh] "  string => "sshd";
   "start[ssh] "   string => "/etc/init.d/sshd restart";

  linux.SuSE::

   "cfg_file[ssh]" string => "/etc/ssh/sshd_config";
   "daemon[ssh] "  string => "sshd";
   "start[ssh] "   string => "/etc/init.d/sshd restart";

  default::

   "cfg_file[ssh]" string => "/etc/sshd_config";
   "daemon[ssh] "  string => "sshd";
   "start[ssh] "   string => "/etc/init.d/sshd restart";

classes:

  "default" and => { "!SuSE", "solaris" };
}
</pre>

   <p>Some of the attempts to recreate a CFEngine-like tool try to hard code
many decisions, meaning that minor changes in operating system versions
require basic recoding of the software. CFEngine does not make decisions
for you without your permission.

<div class="node">
<a name="Black"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Bulk-operations-are-handled-by-repeating-patterns-over-lists">Bulk operations are handled by repeating patterns over lists</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Hiding-details">Hiding details</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Black, grey and white box encapsulation in CFEngine</h3>

<p>CFEngine's ability to abstract system decisions as promises also
applies to bundles of promises. After all, we can package promises
as bumper compendia for grouping together related matters in
a single package. Naturally, CFEngine never abandons its insistence
on &lt;b&gt;convergence&lt;/b&gt;, merely for the sake of making things look
simple. Using CFEngine, you can create convergent orchestration.

<pre class="verbatim">bundle agent services
{
vars:
 "service" slist => { "dhcp", "ntp", "sshd" };
methods:
 "any" usebundle => fix_service("$(service)"),
         comment => "Make sure the basic application services are running";
}
</pre>
The code above is all you really want to see. The rest can be hidden in libraries that
you rarely look at. In CFEngine, we want the intentions to shine forth and the
low level details to be clear on inspection, but hidden from view.

   <p>We can naturally modularize the packaged bundle of fully convergent
promises and keep it as library code for reuse. Notice that
CFEngine adds comments in the code that follow processes through
execution, allowing you to see the full intentions behind the
promises in logs and error messages. In commercial versions, you can
trace these comments to see your process details.

<pre class="verbatim">bundle agent fix_service(service)
{
files:

  "$(res.cfg_file[$(service)])"

 #
 # reserved_word => use std templates, e.g. cp(), p(), or roll your own
 #
     copy_from => cp("$(g.masterfiles)/$(service)","policy_host.mydomain"),
         perms => p("0600","root","root"),
       classes => define("$(service)_restart", "failed"),
       comment => "Copy a stock configuration file template from repository";

processes:

  "$(res.daemon[$(service)])"

     restart_class => canonify("$(service)_restart"),
           comment => "Check that the server process is running...";

commands:

  "$(res.start[$(service)])"

           comment => "Method for starting this service",
        ifvarclass => canonify("$(service)_restart");

}

</pre>

<div class="node">
<a name="Bulk-operations-are-handled-by-repeating-patterns-over-lists"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ordering-operations-in-CFEngine">Ordering operations in CFEngine</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Black">Black</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Bulk operations are handled by repeating patterns over lists</h3>

<p>The power of CFEngine is to be able to handle lists of similar
patterns in a powerful way.  You can also wrap the whole experience in
a method-bundle, and we can extend this kind of pattern to
implement other interfaces, all without low level programming.

<pre class="verbatim">#
# Remove certain services from xinetd - for system hardening
#

bundle agent linux_harden_methods
{
vars:

   "services" slist => {
                       "chargen",
                       "chargen-udp",
                       "cups-lpd",
                       "finger",
                       "rlogin",
                       "rsh",
                       "talk",
                       "telnet",
                       "tftp"
                       };
methods:

    #
    # for each $(services) in @(services) do disable_xinetd($(services))
    #

   "any"  usebundle => disable_xinetd("$(services)");
}
</pre>

   <p>In the library of generic templates, we may keep one or more methods for implementing
service disablement. For example, this simple interface to Linux's <code>chkconfig</code>
is one approach, which need not be hard-coded in Ruby using Cfeninge.

<pre class="verbatim">#
# For the standard library
#

bundle agent disable_xinetd(name)
{
vars:
   "status" 

     string => execresult("/sbin/chkconfig --list $(name)", "useshell");

classes:
   "on"  expression => regcmp(".*on","$(status)");
   "off" expression => regcmp(".*off","$(status)");
   
commands:
   on::
      "/sbin/chkconfig $(name) off",
          comment => "disable $(name) service";

reports:
   on::
      "disable $(name) service.";
   off::
      "$(name) has been already disabled. Don't need to perform the action.";
   
}
</pre>

<div class="node">
<a name="Ordering-operations-in-CFEngine"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Bundle-ordering">Bundle ordering</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Bulk-operations-are-handled-by-repeating-patterns-over-lists">Bulk operations are handled by repeating patterns over lists</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Ordering operations in CFEngine</h3>

<p>Ordering of operations is less important than you probably
think. We are taught to think of computing as an linear sequence of
steps, but this ignores a crucial fact about distributed systems: that
many parts are independent of each other and exist in parallel.

   <p>Nevertheless there are sometimes cases of strong inter-dependency
(that we strive to avoid, as they lead to most of the difficulties of
system management) where order <i>is</i> important. In re-designing
CFEngine, we have taken a pragmatic approach to ordering. Essentially,
CFEngine takes care of ordering for you for most cases &ndash; and you can
override the order in three ways:

     <ul>
<li>CFEngine checks promises of the same type in the order in which they are defined, unless overridden
<li>Bulk ordering of composite promises (called bundles) is handled using an overall list using the bundlesequence (replaces the actionsequence in previous CFEngines)
<li>Dependency coupling through dynamic classes, may be used to guarantee ordering in the few cases
where this is required,  as in the example below:
</ul>

<div class="node">
<a name="Bundle-ordering"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Overriding-order">Overriding order</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ordering-operations-in-CFEngine">Ordering operations in CFEngine</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Bundle ordering</h3>

<p>There are two methods, working at different levels. 
At the top-most level there is the master <code>bundlesequence</code>

   <pre class="sp">

</pre>
<pre class="verbatim">body common control
{
bundlesequence => { "bundle_one", "bundle_two", "bundle_three" };
}
</pre>
   <pre class="sp">

</pre>
For simple cases this is good enough, but the main
purpose of the bundlesequence is to easily be able to switch on
or off bundles by commenting them out.

   <p>A more flexible way of ordering bundles is to wrap the ordered process
in a master-bundle.  Then you can create new sequences of bundles
(parameterized in more sophisticated ways) using <code>methods</code>
promises. Methods promises are simply promises to re-use bundles,
possibly with different parameters.

   <p>The default behaviour is to retain the order of these promises; the effect
is to `execute' these bundles in the assumed order:
   <pre class="sp">

</pre>
<pre class="verbatim">bundle agent a_bundle_subsequence
{
methods:
  classes::
   "any" usebundle => bundle_one("something");
   "any" usebundle => bundle_two("something");
   "any" usebundle => bundle_three("something");

}
</pre>
   <pre class="sp">

</pre>
Alternatively, the same effect can be achieved as follows.
   <pre class="sp">

</pre>
<pre class="verbatim">bundle agent a_bundle_subsequence
{
methods:
  classes::
   "any" usebundle => generic_bundle("something","one");
   "any" usebundle => generic_bundle("something","two");
   "any" usebundle => generic_bundle("something","three");

}
</pre>
   <pre class="sp">

</pre>
Or ultimately:
   <pre class="sp">

</pre>
<pre class="verbatim">bundle agent a_bundle_subsequence
{
vars:
  "list" slist => { "one", "two", "three"};

methods:
  classes::
   "any" usebundle => generic_bundle("something","$(list)");

}
</pre>

<div class="node">
<a name="Overriding-order"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Distributing-Ordering-between-hosts-with-CFEngine-Nova">Distributing Ordering between hosts with CFEngine Nova</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Bundle-ordering">Bundle ordering</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Overriding order</h3>

<p>CFEngine is designed to handle non-deterministic events, such as
anomalies and unexpected changes to system state, so it needs to
adapt. For this, there is no deterministic solution and approximate
methods are required. Nevertheless, it is possible to make CFEngine
sort out dependent orderings, even when confounded by humans, as in
this example:

<pre class="verbatim">bundle agent order

{
vars:

 "list" slist => { "three", "four" };

commands:

 ok_later::
   "/bin/echo five";

 any::

  "/bin/echo one"     classes => define("ok_later");
  "/bin/echo two";
  "/bin/echo $(list)";

}

</pre>

<p class="noindent">The output of which becomes:
<pre class="verbatim">Q: ".../bin/echo one": one
Q: ".../bin/echo two": two
Q: ".../bin/echo three": three
Q: ".../bin/echo four": four
Q: ".../bin/echo five": five
</pre>

<div class="node">
<a name="Distributing-Ordering-between-hosts-with-CFEngine-Nova"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Overriding-order">Overriding order</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Distributing Ordering between hosts with CFEngine Nova</h3>

<p>CFEngine Nova adds many powerful features to CFEngine, including
a decentralized approach to coordinating activities across multiple
hosts. Some tools try to approach this by centralizing data from the
network in a single location, but this has two problems:

     <ul>
<li>It leads to a bottleneck by design that throttles performance seriously. 
<li>It relies on the network being available. 
</ul>

   <p>With CFEngine Nova there are are both decentralized network approaches
to this problem, and probabilistic methods that do not require the network
at all.

   <p><a name="Contents">
   <div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">Orchestration</a>
<ul>
<li><a href="#What-is-modularity_003f">What is modularity?</a>
<li><a href="#What-is-orchestration_003f">What is orchestration?</a>
<li><a href="#How-does-CFEngine-deal-with-modularity-and-orchestration_003f">How does CFEngine deal with modularity and orchestration?</a>
<li><a href="#Levels-of-policy-abstraction">Levels of policy abstraction</a>
<li><a href="#Is-CFEngine-patch-or-package-oriented_003f">Is CFEngine patch-oriented or package-oriented?</a>
<li><a href="#High-level-services-in-CFEngine">High level services in CFEngine</a>
<li><a href="#Hiding-details">Hiding details</a>
<li><a href="#Black">Black, grey and white box encapsulation in CFEngine</a>
<li><a href="#Bulk-operations-are-handled-by-repeating-patterns-over-lists">Bulk operations are handled by repeating patterns over lists</a>
<li><a href="#Ordering-operations-in-CFEngine">Ordering operations in CFEngine</a>
<li><a href="#Bundle-ordering">Bundle ordering</a>
<li><a href="#Overriding-order">Overriding order</a>
<li><a href="#Distributing-Ordering-between-hosts-with-CFEngine-Nova">Distributing Ordering between hosts with CFEngine Nova</a>
</li></ul>
</li></ul>
</div>



   <p><script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://
ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-
analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2576171-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

   <div class="footnote">
<hr>
<a name="texinfo-footnotes-in-document"></a><h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> Sometimes it is desirable to reinstall an entire package, but normally this is only true
for software upgrades. CFEngine has an interface for working in concert with local
package managers (RPM,DEB,MSI, etc).</p>

   <hr></div>

</body></html>

