<html lang="en">
<head>
<title>Security Scanning and Tripwires with CFEngine</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Security Scanning and Tripwires with CFEngine">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
@font-face {
    font-family: 'CFE_FONT';
    src: url('fonts/eot/opensans-regular-webfont.eot');
    src: local('â˜º'),  url('fonts/ttf/opensans-regular-webfont.ttf') format('truetype'), url('fonts/svg/opensans-regular-webfont.svg') format('svg');
    font-weight: normal;
    font-style: normal;
}    
pre {
    background-color: #EEFFDD;
    border: 1px solid #CCCCCC;
    font-family: courier;
    margin-bottom: 10px;
    margin-top: 10px;
    padding: 5px;
    font-size: 90%;
    }
pre.display { font-family:inherit }
pre.format  { font-family:inherit }
pre.smallexample
pre.smalllisp,
pre.smallformat,
pre.smalldisplay {
  font-size: 90%;
} 

span.sc    { font-variant:small-caps }
span.roman { font-family:serif; font-weight:normal; } 
span.sansserif { font-family:sans-serif; font-weight:normal; } 

body {
    font:  90%  'CFE_FONT', arial, Helvetica,sans-serif; 
    color: #646464;
    padding: 10px 20px;
    width: 960px;
    margin: 0 auto;
}
.node
{
    text-align: right;
    padding: 2px;
    font-size: smaller;
}
.node hr {
    border: 0;
    width: 100%;
    color: #CCC;
    background-color: #CCC;
    height: 5px;
}
.section {
    padding-right: 0px;
    padding-bottom: 0px;
    padding-left: 0px;
}

h1 {
    font-size: 26px;
    font-weight: normal;
    line-height: 32px;
    margin: 32px 0 16px;
    text-align: left;
    text-transform: uppercase;
}

h2 {
    color: #9E9981 !important;
    font-size: 16px;
    line-height: 18px;
    font-weight: normal;
    margin: 16px 0 26px;
    text-align: left;
}
h3 {
    margin-top: 3px;
    margin-right: 0px;
    margin-bottom: 10px;
    margin-left: 0px;
    line-height: 20px;
    font-size: 16px;
    font-weight: normal;
}

.contents
{
    background-color: #CCC;
    padding-top: 2px;
    padding-right: 2px;
    padding-bottom: 2px;
    padding-left: 10px;
}

.index-cp
{  
background: #fff url(index-cp.png) right repeat-y;
}

.index-vr
{  
background: #fff url(index-vr.png) right repeat-y;
}

.index-mb
{  
background: #eee url(index-faq.png) right repeat-y;
}

table.border
{
	border-color: #666;
	border-width: 0px;
}

FONT.liten {font-size: 80%; }
 
.tynn {
    font-family: Arial, Helvetica, sans-serif;
    font-size: smaller;
    font-style: normal;
    font-weight: lighter;
    margin-bottom: 0em;
    font-size: 11pt;
}
.verbatim {
    color: #000;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 20px;
    margin-left: 0px;
}
.example {
    color: #000;
    width: 100%;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 20px;
    margin-left: 0px;
}
.smallexample {
    color: #000;
    padding-top: 10px;
    padding-right: 30px;
    padding-bottom: 5px;
    padding-left: 30px;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 0px;
    margin-left: 0px;
}
.cartouche {
    padding: 5px;
    font-style: italic;
    font-size: 85%;
}

table.cartouche {
    border: none !important;
}

 .cartouche td  {
    background-color: #ddd;
    border: 1px solid #ccc;
    padding: 5px;
}

A:link { color: #2c2e70 }
A:visited { color: black }
A:active { color: #600041 }
dt em {font-weight: bold}
/* don't change this rule */    
pre.sp {
    background: none !important;   
    border:none !important
}
/* --- */
/*code hightlight*/
.red { color: #b80047; font-weight: bold; }

.blue { color: blue;  /*font-weight: bold;*/ }

.green { color: darkgreen; }

.comment { font-style: italic; }
--></style>
</head>
<body>
<h1 class="settitle">Security Scanning and Tripwires with CFEngine</h1>
<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#File-scanning">File scanning</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">Security scanning and tripwires with CFEngine</h2>

<ul class="menu">
<li><a accesskey="1" href="#File-scanning">File scanning</a>
<li><a accesskey="2" href="#Process-and-network-scanning">Process and network scanning</a>
<li><a accesskey="3" href="#Log-scanning">Log scanning</a>
<li><a accesskey="4" href="#Intrusion-detection">Intrusion detection</a>
</ul>

<div class="node">
<a name="File-scanning"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Process-and-network-scanning">Process and network scanning</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 File scanning</h2>

<p>CFEngine has sophisticated functionality for scanning hosts to find
anomalous content, for looking through log messages and detecting unauthorized file
changes. This can form the basis of a host based intrusion shield,
either alone or in conjunction with other tools.

   <p>This document describes how to scan systems for potential security
incidents and vulnerabilities, and view reports across your system
using the Mission Portal.

<ul class="menu">
<li><a accesskey="1" href="#File-change-detection-and-tripwires">File change detection and tripwires</a>
<li><a accesskey="2" href="#Example-change-management">Example change management</a>
<li><a accesskey="3" href="#file_005fchange_002elog">file_change.log</a>
<li><a accesskey="4" href="#File-change-reports-in-Nova-and-Constellation">File change reports in Nova and Constellation</a>
<li><a accesskey="5" href="#Tamperproof-data">Tamperproof data</a>
<li><a accesskey="6" href="#Change-detection-bundle-summary">Change detection bundle summary</a>
<li><a accesskey="7" href="#Reversion-of-file-changes-from-a-trusted-source">Reversion of file changes from a trusted source</a>
</ul>

<div class="node">
<a name="File-change-detection-and-tripwires"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Example-change-management">Example change management</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#File-scanning">File scanning</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#File-scanning">File scanning</a>

</div>

<h3 class="section">1.1 File change detection: tripwires</h3>

<p>File change monitoring is about detecting when file information on a
computer system changes. You might or might not know that files
are going to change. Expected changes are not usually a problem,
but unexpected change can be problematic or even sinister.

   <p>The bulk of information on a computer is its file data. Change
detection for filesystems uses a technique made famous in the original
open source program Tripwire, which collects a snapshot of the system
in the form of a database of file checksums (cryptographic hashes) and
then periodically rechecks the system against this database to see
what has changed. Using cryptographic hashes is an efficient way of
detecting change as it reduces file contents to a unique number, just
a few bytes long, which can be stored for later comparison to detect change.

   <p>If as much as a single bit of information changes, the file hash will
change by a noticable amount.  This is a very simple (even simplistic)
view of change, but it is effective at warning about potential
incursions to the system.

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
A cryptographic hash (also called a digest) is an algorithm that reads
(digests) a file and computes a single number (the hash value)
based on its contents. If so much as a single bit in the file changes
then the value of the hash will change. You can compute hash values
manually, for example:

<pre class="verbatim">
host$ openssl md5 /etc/passwd
MD5(/etc/passwd)= 1fbd82252c441d0e9539f8f7271ec2fe

</pre>

   <p>There are several kinds of hash function. The most common ones are MD5
and SHA1. Recently both of these algorithms
have been superceded by the newer SHA2 set.

   <pre class="sp">

</pre>
Note that the FIPS 140-2 US government standard for encryption does not recognize
the MD5 hash algorithm. The default algorithm for enterprise grade
CFEngine is now SHA256. 
</td></tr></table>

   <pre class="sp">

</pre>

To use hash based change detection we use <samp><span class="file">files</span></samp> promises
and the <code>changes</code> feature; first we ask CFEengine to
compute file hashes for specified files and enter them into a
database. Then, the same promise on subsequent runs will re-collect
the data and compare the result to what has been stored in the database.

   <p>Here is a simple CFEngine promise that checks for changes in
<samp><span class="file">/usr/local</span></samp>:

<pre class="verbatim">files:
  "/usr/local"
<span class="red">     changes      </span>=><span class="blue"> detect_all_change,</span>
<span class="red">     depth_search </span>=><span class="blue"> recurse("inf");</span>
</pre>

<p class="noindent">This example uses the standard library template &lsquo;<samp><span class="samp">detect_all_change</span></samp>&rsquo;.

   <p>The first time this promise is kept, CFEngine collects data and treats
all files as <i>unchanged</i>. It builds a database of the checksums. The
next time the rule is checked, cfagent recomputes the checksums and
compares the new values to the `reference' values stored in the
database. If no change has occurred, the two should match. If they
differ, then the file as changed and a warning is issued either on the
command line (if you are testing manually) or by email.

<pre class="verbatim">   cf3: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<span class="red">   cf3: SECURITY ALERT: Checksum (sha256) for /etc/passwd changed!
</span><span class="red">   cf3: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
</span></pre>

   <p>This message is designed to be visible. If you do not want the
embracing rows of `!' characters, then this control directive turns
them off:

<pre class="verbatim">body agent control
{
<span class="red">exclamation </span>=><span class="green"> "false";</span>
}
</pre>

<div class="node">
<a name="Example-change-management"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#file_005fchange_002elog">file_change.log</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#File-change-detection-and-tripwires">File change detection and tripwires</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#File-scanning">File scanning</a>

</div>

<h3 class="section">1.2 Example change management</h3>

<p>Try the following complete example. 
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="verbatim">body common control
{
<span class="red">bundlesequence </span>=> { "test_change" };
<span class="red">inputs </span>=> { "LapTop/cfengine/copbl/cfengine_stdlib.cf" };
}

<span class="red">bundle agent</span> <span class="blue">test_change</span>
{
<span class="red">files:
</span>
  "/tmp"
<span class="red">       changes </span>=><span class="blue"> detect_all_change,</span>
<span class="red">   depth_search </span>=><span class="blue"> recurse("inf");</span>
}
</pre>
</td></tr></table>

   <pre class="sp">

</pre>
This example shows how we use standard library templates to
scan a directory and (recursively) all of its sub-directories and their
contents.

   <p>The first time we run this, we get a lot of messages about new files being detected. 
This learns and defines the baseline for future comparisons:
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="smallexample">     host$ ~/LapTop/cfengine/core/src/cf-agent -f ~/test.cf -K
     
      !! File /tmp/.X0-lock was not in sha512 database - new file found
     I: Made in version 'not specified' of '/home/a10004/test.cf' near line 14
      !! File /tmp/pulse-5weilfdGWBDj/pid was not in sha512 database - new file found
     I: Made in version 'not specified' of '/home/a10004/test.cf' near line 14
</pre>
   </td></tr></table>
   Next we can create a new file in the directory:
<pre class="verbatim">host$ touch /tmp/blablabla
host$ ~/LapTop/cfengine/core/src/cf-agent -f ~/test.cf -K

 !! File /tmp/blablabla was not in sha512 database - new file found
<span class="red">I: Made in version 'not specified' of '/home/a10004/test.cf' near line 14
</span></pre>

<p class="noindent">Next we edit the contents of the file
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="smallexample">     host$ echo sldjfkdsf &gt; /tmp/blablabla
     host$ ~/LapTop/cfengine/core/src/cf-agent -f ~/test.cf -K
     
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     ALERT: Hash (sha512) for /tmp/blablabla changed!
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      -&gt; Updating hash for /tmp/blablabla to SHA=63fc10a0c57dc8cbd2c259b4d0bb81e1b4e5cf23f1fdc8b8
     I: Made in version 'not specified' of '/home/a10004/test.cf' near line 14
     
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     ALERT: Last modified time for /tmp/blablabla changed Thu Oct 20 08:46:58 2011 -&gt; Thu Oct 20
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
</pre>
   </td></tr></table>
   Note the different messages here. The first message notes that the contents of the file
have changed. The second indicates that the database has been updated with the new hash of the
file so that this message will not be regenerated on every subsequent run of CFEngine. Finally,
it notes that the modification time on the file changed. These messages reflect the default settings
in the &lsquo;<samp><span class="samp">detect_all_change</span></samp>&rsquo; template (see below).

   <p>Finally, if we remove a file from a monitored directory, we see the following:
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="smallexample">     host$ rm /tmp/blablabla
     host$ ~/LapTop/cfengine/core/src/cf-agent -f ~/test.cf -K
     
     ALERT: /tmp/blablabla file no longer exists!
     I: Made in version 'not specified' of '/home/a10004/test.cf' near line 14
</pre>
   </td></tr></table>
   In this example, we used the standard library template &lsquo;<samp><span class="samp">detect_all_change</span></samp>&rsquo;,
which is defined as follows:
<pre class="verbatim">body changes detect_all_change
{
<span class="red">hash           </span>=><span class="green"> "best";</span>
<span class="red">report_changes </span>=><span class="green"> "all";</span>
<span class="red">update_hashes  </span>=><span class="green"> "yes";</span>
}
</pre>

   <p>This is the most exacting option, but it costs CPU time to compute two different hashes
for cross-referencing as well as for reading
disk files and it costs disk space in storing both content hashes and additional
file attribute information. Moreover, it resets its learned database each time a change
is made.

   <p>There are several alternatives. To save CPU and disk, we can just monitor content:
<pre class="verbatim">body changes detect_content
{
<span class="red">hash           </span>=><span class="green"> "md5";</span>
<span class="red">report_changes </span>=><span class="green"> "content";</span>
<span class="red">update_hashes  </span>=><span class="green"> "yes";</span>
}
</pre>
To prevent the database being updated, we can use:
<pre class="verbatim">body changes noupdate
{
<span class="red">hash           </span>=><span class="green"> "sha256";</span>
<span class="red">report_changes </span>=><span class="green"> "content";</span>
<span class="red">update_hashes  </span>=><span class="green"> "no";</span>
}
</pre>

   <p>Finally, commercially supported versions of CFEngine will support
detection of file difference reports in the Mission Portal, if enabled
in policy:
<pre class="verbatim">body changes diff # Generates diff report (Nova and above)
{
<span class="red">hash           </span>=><span class="green"> "sha256";</span>
<span class="red">report_changes </span>=><span class="green"> "content";</span>
<span class="red">report_diffs   </span>=><span class="green"> "true";</span>
<span class="red">update_hashes  </span>=><span class="green"> "yes";</span>
}
</pre>

<div class="node">
<a name="file_change.log"></a>
<a name="file_005fchange_002elog"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#File-change-reports-in-Nova-and-Constellation">File change reports in Nova and Constellation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Example-change-management">Example change management</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#File-scanning">File scanning</a>

</div>

<h3 class="section">1.3 file_change.log</h3>

<p>The file file_hash_event_history contains a separate text log of file
changes.

<pre class="verbatim">host$ sudo more /var/cfengine/state/file_change.log 
<span class="red">[sudo] password for you: 
</span>1308904847,/etc/passwd
1308904847,/etc/shadow
</pre>
The first column is a time stamp. If you are using one of the commercial versions
of CFEngine, you can see a more user friendly report for the entire enterprise or
for a single host in the next section.

<div class="node">
<a name="File-change-reports-in-Nova-and-Constellation"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Tamperproof-data">Tamperproof data</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#file_005fchange_002elog">file_change.log</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#File-scanning">File scanning</a>

</div>

<h3 class="section">1.4 File change reports in Nova and Constellation</h3>

<p>In the commercially supported editions of CFEngine, users have access
to a number of reports about file changes. A report of file changes and the
times at which the changes were detected is available in the file change report:

   <pre class="sp">

</pre>
<img src="file_change_diffs.png" alt="file_change_diffs.png">
   <pre class="sp">

</pre>

CFEngine does not record the actual changes unless you mention files
explicitly by name, and the report is mostly useful if the file is a text file. 
In that case, you will see a change report:

   <pre class="sp">

</pre>
<img src="file_change_log.png" alt="file_change_log.png">
   <pre class="sp">

</pre>

<div class="node">
<a name="Tamperproof-data"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Change-detection-bundle-summary">Change detection bundle summary</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#File-change-reports-in-Nova-and-Constellation">File change reports in Nova and Constellation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#File-scanning">File scanning</a>

</div>

<h3 class="section">1.5 Tamperproof data</h3>

<p>Message digests are supposed to be unbreakable, tamperproof
technologies, but of course everything can be broken by a sufficiently
determined attacker. Suppose someone wanted to edit a file and alter
the cfengine checksum database to cover their tracks. If they had
broken into your system, this is potentially doable, though not easy. How can we
detect whether this has happened or not?

   <p>A simple solution to this is to exploit the fact that CFEngine is a
distributed system, and to make neighbouring hosts work together to
watch over one another. We can use the same idea for change detection,
but now remotely across networked hosts: we
use another checksum-based
operation to copy the database to a completely different host. By
using a copy operation based on a checksum value, we can also remotely
detect a change in the checksum database itself.

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="verbatim">bundle agent neighbourhood_watch
{
<span class="red">vars:
</span>
  "neighbours"<span class="red"> slist </span>=> peers("/var/cfengine/inputs/hostlist","#.*",4),
<span class="red">             comment </span>=><span class="green"> "Get my neighbours from a list of all hosts";</span>

<span class="red">files:
</span>
<span class="comment">  # Redundant cross monitoring .......................................
</span>

  "$(sys.workdir)/nw/$(neighbours)_checksum_digests.db"

<span class="red">     comment </span>=><span class="green"> "Watch our peers remote hash tables!",</span>
<span class="red">    copy_from </span>=><span class="blue"> </span>
           remote_cp("$(sys.workdir)/checksum_digests.db",$(neighbours)),
<span class="red">  depends_on </span>=> { "grant_hash_tables" };

<span class="comment">  # Define the actual children to watch over .........................
</span>

   "/usr/bin"         
<span class="red">      comment     </span>=><span class="green"> "Watch over the system binaries",</span>
<span class="red">      changes      </span>=><span class="blue"> detect_all_change,</span>
<span class="red">      depth_search </span>=><span class="blue"> recurse("inf"),</span>
<span class="red">      action       </span>=><span class="blue"> measure;</span>

}
</pre>
</td></tr></table>

   <p>We must have a file <samp><span class="file">hostlist</span></samp> containing a list of all participating hosts; it is
best to list IP addresses, one per line, but host names will also do. 
This works as follows.

   <p>Each host extracts from the host lists a list of (in this case three) neighbours,
since we have set a neighbourhood size of 4. The CFEngine built-in function
&lsquo;<samp><span class="samp">peers()</span></samp>&rsquo; can be used for this. Each host in
the network takes on the responsibility to watch over its
neighbours by promising to copy the change databases for its neighbours
only if they have changed. Any changes are then logged as alerts.

   <p>The copy rule attempts to copy the database to some file in a
safekeeping directory <code>$(sys.workdir)/nw</code>. 
In theory, all four neigbours should signal this change. If an
attacker had detailed knowledge of the system, he or she might be able
to subvert one of these before the change was detected, but it
is unlikely that all four could be covered up. At any rate, this
approach maximizes the chances of change detection.

   <p>Finally, in order to make this copy, you must, of course, grant access to the database in
by granting access to the database in a bundle of server promises:

<pre class="verbatim">bundle server access_rules()
{
<span class="red">vars:
</span>
<span class="comment">  # List here the IP masks that we grant access to on the server
</span>

    "acl"<span class="red"> slist </span>=> { 
                   "$(sys.policy_hub)/24",
                   "128.39.89.233", 
<span class="red">                   "2001:700:700:3.*"
</span>                   },
<span class="red">       comment </span>=><span class="green"> "Define an acl for the machines to be granted accesses",</span>
<span class="red">        handle </span>=><span class="green"> "common_def_vars_acl"; </span>

<span class="red">access:
</span>
  "/var/cfengine/checksum_digests.tcdb"

<span class="red">     handle </span>=><span class="green"> "grant_hash_tables",</span>
<span class="red">    admit   </span>=> { @(acl) },
<span class="red">    maproot </span>=> { @(acl) };

</pre>

   <p>Let us now consider what happens if an attacker changes a file an
edits the checksum database. Each of the four hosts that has been
designated a neighbour will attempt to update their own copy of the
database. If the database has been tampered with, they will detect a
change in the hashes of the remote copy versus the original. The file
will therefore be copied.

   <p>It is not a big problem that others have a copy of your checksum
database. They cannot see the contents of your files from this. A
potentially greater problem is that this configuration will unleash an
avalanche of messages if a change is detected. This does make messages
visible however.

<div class="node">
<a name="Change-detection-bundle-summary"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Reversion-of-file-changes-from-a-trusted-source">Reversion of file changes from a trusted source</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tamperproof-data">Tamperproof data</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#File-scanning">File scanning</a>

</div>

<h3 class="section">1.6 Change detection bundle summary</h3>

<p>A typical promise structure for doing change management.

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="verbatim">
<span class="red">bundle agent</span> <span class="blue">change_management</span>
{
<span class="red">vars:
</span>
  "watch_files"<span class="red"> slist </span>=>  {
                          "/etc/passwd", 
                          "/etc/shadow", 
                          "/etc/group", 
                          "/etc/services" 
                          };

  "watch_dirs"<span class="red"> slist </span>=>   {
                          "/usr"
                          };

  "neighbours"<span class="red">   slist </span>=> peers("/var/cfengine/inputs/hostlist","#.*",4),
<span class="red">               comment </span>=><span class="green"> "Partition the network into groups";</span>

<span class="red">files:
</span>   "$(watch_dirs)"
<span class="red">      comment      </span>=><span class="green"> "Change detection on the directories",</span>
<span class="red">      changes      </span>=><span class="blue"> detect_all_change,</span>
<span class="red">      depth_search </span>=><span class="blue"> recurse("inf");</span>

   "$(watch_files)" 
<span class="red">      comment      </span>=><span class="green"> "Change detection on important files",</span>
<span class="red">      changes      </span>=><span class="blue"> diff;  # diff_noupdate</span>

<span class="comment">  # Redundant cross monitoring ... neighbourhood watch
</span>

  "$(sys.workdir)/nw/$(neighbours)_checksum_digests.db"

<span class="red">     comment </span>=><span class="green"> "Watching our peers remote hashes  - cross check",</span>
<span class="red">   copy_from </span>=><span class="blue"> </span>
           remote_dcp("$(sys.workdir)/checksum_digests.db","$(neighbours)"),
<span class="red">  depends_on </span>=> { "grant_hash_tables" },
<span class="red">      action </span>=> neighbourwatch("File changes observed on $(neighbours)");
}

<span class="comment">#######################################################
</span>

<span class="red">body action</span> <span class="blue">neighbourwatch(s)</span>
{
<span class="red">ifelapsed    </span>=><span class="green"> "30";</span>
<span class="red">log_string   </span>=><span class="green"> "$(s)";</span>
<span class="red">log_repaired </span>=><span class="green"> "stdout";</span>
}

</pre>
</td></tr></table>
   Note that the <samp><span class="file">remote_dcp</span></samp> template uses a digest-comparison when comparing
the files.

   <p>With this promise in place, you will not merely be warned about file
changes, but you will immediately remediate the erroneous file
change. By default, CFEngine backs up files when they are replaced by
appending a suffix <samp><span class="file">.cfbackup</span></samp>, or timestamp. If you want to go
and look at the erroneous file for forensic evaluation, this backup
contains the evidence of changes.

<div class="node">
<a name="Reversion-of-file-changes-from-a-trusted-source"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Change-detection-bundle-summary">Change detection bundle summary</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#File-scanning">File scanning</a>

</div>

<h3 class="section">1.7 Reversion of file changes from a trusted source</h3>

<p>Detecting changes to files is only half of battle against unauthorized
change.  In most cases you will also want to revert back to a trusted
version. A recommended approach here is to maintain a trusted
repository of source files, and to ask CFEngine to compare the current
version of the file to master version using a cryptographic hash.

   <p>Suppose we want to manage a particular file (of any type or for any purpose)
called <samp><span class="file">fileX</span></samp>, which is to be located in some directory
<samp><span class="file">/destination</span></samp> of a host. We arrange for some other host
(that is considered `secure') to have a trusted version the file
in some directory called <samp><span class="file">/mastersources</span></samp><a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>. A promise that synchronized the

<pre class="verbatim">  "/destination/fileX"

<span class="red">     comment </span>=><span class="green"> "Copy fileX from a trusted source",</span>
<span class="red">   copy_from </span>=><span class="blue"> </span>
           remote_dcp("/mastersources/fileX","masterhost"),
<span class="red">  depends_on </span>=> { "grant_fileX" },
<span class="red">      action </span>=> neighbourwatch("File changes observed on fileX");

</pre>
We assume here that access to the masterfile has been granted to the
host.

<div class="node">
<a name="Process-and-network-scanning"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Log-scanning">Log scanning</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#File-scanning">File scanning</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Process and network scanning</h2>

<p>Looking at file changes is a very static view of system change &ndash; basically you assume that
the system should not change from some initial snaphot, or at the very least you warn about
every change. However, many aspects of a system change all the time, e.g. the network connections
to and from the host, the processes running on the system.

   <p>The system might attain some kind of <i>statistical</i> normalcy, which can be learnt
over time, but it that is based on a kind of equilibrium with its environment, not
of locking down the system completely.

   <p>CFEngine's <code>cf-montord</code> has the ability to learn the trends and
behaviour of any countable or measurable value on the system. Over
time, it employs machine-learning methods from artificial intelligence
to build a normalcy profile for the system. Any significant deviations from
these profiles can be reported and responded to in policy.

   <pre class="sp">

</pre>
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
In the Special Topics Guide <i>Monitoring with CFEngine</i>, you will find more information about
about how to use CFEngine's monitoring daemon <code>cf-monitord</code> to watch over changes
to the system that are dynamical. 
</td></tr></table>

<ul class="menu">
<li><a accesskey="1" href="#Watching-processes">Watching processes</a>
<li><a accesskey="2" href="#Watching-other-system-variables">Watching other system variables</a>
<li><a accesskey="3" href="#Threshold-monitoring">Threshold monitoring</a>
</ul>

<div class="node">
<a name="Watching-processes"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Watching-other-system-variables">Watching other system variables</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Process-and-network-scanning">Process and network scanning</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Process-and-network-scanning">Process and network scanning</a>

</div>

<h3 class="section">2.1 Watching processes</h3>

<p>CFEngine does not encourage the watching of systems without repair,
i.e.  simply informing humans about changes without fixing
problems. After all, if you have a chance to repair something that is
already encoded into policy, why wouldn't you simply do it? However,
in certain mission critical environments you might want a specific
alert about changes even though a repair was made. If certain
conditions are not supposed to happen, it is good to know that they did.

   <p>In the following example, we look for a number of very specific
processes in the process table, using our own promise-bdy template. 
Then we use a standard library template <code>check_range</code> to
set policy for an acceptable range of such processes on the system.

   <p>This combines two kinds of checks: how many of a particular process
is acceptable at any given moment, and the precise parameters
satsified: in this case, the amount of memory used by the process.

   <pre class="sp">

</pre>
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="verbatim">bundle agent count_important_processes
{
<span class="red">processes:
</span>
 ".*"

<span class="red">    process_select  </span>=><span class="blue"> my_proc_finder("myprocess"),</span>
<span class="red">    process_count   </span>=><span class="blue"> check_range("myprocess",1,10);</span>
}

<span class="comment">########################################################
</span>

<span class="red">body process_select</span> <span class="blue">my_proc_finder(p)</span>

{
<span class="red">process_owner  </span>=> { "root", "bin" };
<span class="red">command        </span>=><span class="green"> "$(p)";</span>
<span class="red">pid            </span>=><span class="green"> "100,199";</span>
<span class="red">vsize          </span>=><span class="green"> "0,1000";</span>
<span class="red">process_result </span>=><span class="green"> "command.(process_owner|vsize)";</span>
}

</pre>
</td></tr></table>
   This example therefore searches for processes called &lsquo;<samp><span class="samp">myprocess</span></samp>&rsquo;
running as root or bin that use between 0 and 1000 KB of virtual memory
and have a process ID between 100 and 199. 
Although this example is a little contrived, it shows how different
criteria can be combined to watch for very specific promises.

<div class="node">
<a name="Watching-other-system-variables"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Threshold-monitoring">Threshold monitoring</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Watching-processes">Watching processes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Process-and-network-scanning">Process and network scanning</a>

</div>

<h3 class="section">2.2 Watching other system variables</h3>

<p>When <code>cf-monitord</code> is running, it collects information about a
running processes and network connections to well-known ports. There
is a list of standard ports and system attributes examined by
CFEngine, and you can extend this using <code>measurements</code> promises.

   <pre class="sp">

</pre>
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
In the Special Topics Guide <i>Monitoring with CFEngine</i>, you will find more information about
about how to use CFEngine's monitoring daemon <code>cf-monitord</code> to watch over changes
to the system that are dynamical. 
</td></tr></table>

   <pre class="sp">

</pre>

The information learnt by the monitoring daemon is stored in an
embedded database so that CFEngine can learn the normal behaviour of
the system. It does this by gathering statistics using a very
lightweight, smart algorithm that avoids storing large amounts
of data. The result is that every monitored value can be characterized
by an expectation value and an estimate of the standard-deviation
of the values measured.

   <p>CFEngine is smart enough to realize that what us normal at one time of
day is not necessarily normal all the time, so it learns what is
normal within each five minute interval of the days of the week. Based
on this published model, it is possible to detect anomalies in
behaviour quite accurately, provided enough data are available.

   <pre class="sp">

</pre>
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
Looking for statistical anomalies on little-used hosts is a waste of time. 
If it is normal that nothing happens, then everything that happens
in anomalous. 
</td></tr></table>

   <pre class="sp">

</pre>

You do not need to provide any special configuration in the monitor
daemon to be able to
use the basic anomaly measures, however if you want to interface with
a packet analyser, you will need to configure that as it is resource
intensive.

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
If you have <code>tcpdump</code> available on your system, it is also possible
to get CFEngine to interface to it an measure general packet types
travelling on the local network.

<pre class="verbatim">body monitor control
{
<span class="red">tcpdump </span>=><span class="green"> "false";</span>
<span class="red">tcpdumpcommand </span>=><span class="green"> "/usr/sbin/tcpdump -t -n -v";</span>
}
</pre>
</td></tr></table>

   <pre class="sp">

</pre>

CFEngine monitoring is normally very lightweight, but occupying
the network interface for packet analysis is quite the opposite!

   <p>The following example bundle shows we can use the classes set the by
monitoring daemon simply to warn about anomalous statistical
states. Notice that we define what anomalous means in the policy
itself, by setting a class based on the current state in relation to
the learnt state, e.g. <code>rootprocs_high_dev1</code>, meaning that the
current state is between zero and one standard deviation above the
expectation value, or average. An `anomaly' is defined syntactically
to be more than two standard deviations above or below average.

   <p>Entropy measures can also be used to see how much entropy (variation)
there is in the source IP addresses from which the connections arise. 
This allows us to distinguish between focused traffic from a single source, and
traffic arriving from many sources.

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="verbatim">bundle agent anomalies
{
<span class="red">reports:
</span>
rootprocs_high_dev1::

  "RootProc anomaly high 1 dev on $(sys.host) at $(mon.env_time) 
   measured value $(mon.value_rootprocs) with
   average $(mon.av_rootprocs) pm $(mon.dev_rootprocs)"

<span class="red">   showstate </span>=> { "rootprocs" };

 entropy_www_in_high.www_in_high_anomaly::

   "HIGH ENTROPY Incoming www anomaly high anomaly dev!! on 
   $(sys.host) at $(mon.env_time) - measured value $(mon.value_www_in)    
   av $(mon.av_www_in) pm $(mon.dev_www_in)"
   
<span class="red">      showstate </span>=> { "incoming.www" };

 entropy_www_in_low.anomaly_hosts.www_in_high_anomaly::

   "LOW ENTROPY Incoming www anomaly high anomaly dev!! on 
   $(sys.host) at $(mon.env_time) - measured value $(svalue_www_in) 
   av $(av_www_in) pm $(dev_www_in)"

<span class="red">     showstate </span>=> { "incoming.www" };

 entropy_tcpsyn_in_low.anomaly_hosts.tcpsyn_in_high_dev2::

   "Anomalous number of new TCP connections on $(sys.host) at 
   $(mon.env_time)  - measured value $(mon.value_tcpsyn_in) av 
     $(mon.av_tcpsyn_in) pm $(mon.dev_tcpsyn_in)"

<span class="red">     showstate </span>=> { "incoming.tcpsyn" };

 entropy_dns_in_low.anomaly_hosts.dns_in_high_anomaly::

   "Anomalous (3dev) incoming DNS packets on $(sys.host) 
     at $(mon.env_time) - measured value $(mon.value_dns_in) 
      av $(av_dns_in) pm $(mon.dev_dns_in)"
   
<span class="red">     showstate </span>=> { "incoming.dns" };

 anomaly_hosts.icmp_in_high_anomaly.!entropy_icmp_in_high::

   "Anomalous low entropy (3dev) incoming ICMP traffic on $(sys.host) 
    at $(mon.env_time) - measured value $(mon.value_icmp_in) 
    av $(mon.av_icmp_in) pm $(mon.dev_icmp_in)"
   
<span class="red">     showstate </span>=> { "incoming.icmp" };

}
</pre>
</td></tr></table>

<div class="node">
<a name="Threshold-monitoring"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Watching-other-system-variables">Watching other system variables</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Process-and-network-scanning">Process and network scanning</a>

</div>

<h3 class="section">2.3 Threshold monitoring</h3>

<p>The values learned by the monitoring daemon are made available to the
agent as variables in the system context &lsquo;<samp><span class="samp">mon</span></samp>&rsquo;, e.g. &lsquo;<samp><span class="samp">$(mon.www_in)</span></samp>&rsquo;. 
We can use these values at any time to set policy, either for alerting or
fixing the system.

<pre class="verbatim">vars:

 "probes"<span class="red"> slist </span>=> { "www", "smtp", "ssh" };

<span class="red">classes:
</span>
 "$(probes)_threshold"<span class="red"> expression </span>=> isgreaterthan("$(mon.$(probes)_in)","50");

<span class="red">reports:
</span>
  "Help me $(probes)!"<span class="red"> ifvarclass </span>=><span class="green"> "$(probes)_threshold";</span>

</pre>

<p class="noindent">The value of the CFEngine's component integration is to have transparent
access to the detailed running state of the system at all times. It is possible to
defined quite complex policies, and to respond to incidents based on the specific
data discovered.

<div class="node">
<a name="Log-scanning"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Intrusion-detection">Intrusion detection</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Process-and-network-scanning">Process and network scanning</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 Log scanning</h2>

<p>In CFEngine Nova and above, you can extract data from the
system in sophisticated ways from files or pipes, using Perl
Compatible Regular Expressions to match text. The <code>cf-monitord</code>
agent is responsible for processing measurement promises.

   <p>In this example, we count lines matching a pattern in a file. 
You might want to scan a log for instances of a particular
message and trace this number over time.

<ul class="menu">
<li><a accesskey="1" href="#Scanning-log-files-for-patterns">Scanning log files for patterns</a>
<li><a accesskey="2" href="#FTP">FTP</a>
<li><a accesskey="3" href="#DNS">DNS</a>
<li><a accesskey="4" href="#Email">Email</a>
<li><a accesskey="5" href="#Milter">Milter</a>
<li><a accesskey="6" href="#Breakin">Breakin</a>
</ul>

<div class="node">
<a name="Scanning-log-files-for-patterns"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#FTP">FTP</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Log-scanning">Log scanning</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Log-scanning">Log scanning</a>

</div>

<h3 class="section">3.1 Scanning log files for patterns</h3>

<pre class="sp">

</pre>

You will have to scan the log file for each separate summary
you want to keep, so you win a lot of efficiency by lumping
together mulitple patterns in a longer regular expressions.

   <p>Be careful however about the trade-off. Disk access is certainly the
most expensive computing resource, but a smart filesystem might do good caching.

   <p>Regular expression processing, on the other hand, is CPU expensive, so
if you have very long or complex patterns to match, you will begin
to eat up CPU time too.

   <p>At the end of the day, you should probably do some tests to find a good
balance.  One goal of CFEngine is to minimally impact your system performance,
but it is possible to write promises that have the opposite effect.  Check
your work!

<pre class="verbatim">
<span class="red">bundle monitor</span> <span class="blue">watch</span>
{
<span class="red">measurements:
</span>
   "/home/mark/tmp/file"

<span class="red">         handle </span>=><span class="green"> "line_counter",</span>
<span class="red">    stream_type </span>=><span class="green"> "file",</span>
<span class="red">      data_type </span>=><span class="green"> "counter",</span>
<span class="red">    match_value </span>=><span class="blue"> scan_log("MYLINE.*"),</span>
<span class="red">   history_type </span>=><span class="green"> "log",</span>
<span class="red">         action </span>=><span class="blue"> sample_rate("0");</span>

}

<span class="comment">##########################################################
</span>

<span class="red">body match_value</span> <span class="blue">scan_log(line)</span>
{
<span class="red">select_line_matching </span>=><span class="green"> "$(line)";</span>
<span class="red">track_growing_file </span>=><span class="green"> "true";</span>
}

<span class="red">body action</span> <span class="blue">sample_rate(x)</span>
{
<span class="red">ifelapsed </span>=><span class="green"> "$(x)";</span>
<span class="red">expireafter </span>=><span class="green"> "10";</span>
}
</pre>

<div class="node">
<a name="FTP"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#DNS">DNS</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Scanning-log-files-for-patterns">Scanning log files for patterns</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Log-scanning">Log scanning</a>

</div>

<h3 class="section">3.2 Scanning syslog for FTP statistics</h3>

<pre class="sp">

</pre>

There are many things that you can set CFEngine at monitoring.  For example,
CFEngine can automtically collect information about the number of socket-level
connections made to the ftp server, but you might want more detailed
statistics.  For example, you might want to track the volume of data sent
and received, or the number of failed logins.  Here are a collection of
monitoring promises for doing just that.

   <p>Note that the ftp logs are maintained by syslog, so it is necessary to match
only those lines which correspond to the appropriate service.  We also assume
that the specific messages are sent to <samp><span class="file">/var/log/messages</span></samp>, while your
configuration may specify otherwise.  Likewise, your operating systems's
version of ftp may issue messages with a slightly different format than ours

<pre class="verbatim">
<span class="red">bundle monitor</span> <span class="blue">watch_ftp</span>
{
<span class="red">vars:
</span>   "dir"<span class="red"> slist </span>=> { "get", "put" };

<span class="red">measurements:
</span>
   "/var/log/messages"

<span class="red">	handle </span>=><span class="green"> "ftp_bytes_${dir}",</span>
<span class="red">   stream_type </span>=><span class="green"> "file",</span>
<span class="red">     data_type </span>=><span class="green"> "int",</span>
<span class="red">   match_value </span>=> extract_log(".*ftpd\[.*", ".*${dir} .* = (\d+) bytes.*"),
<span class="red">  history_type </span>=><span class="green"> "log",</span>
<span class="red">	action </span>=><span class="blue"> sample_rate("0");</span>

   "/var/log/messages"

<span class="red">	handle </span>=><span class="green"> "ftp_failed_login",</span>
<span class="red">   stream_type </span>=><span class="green"> "file",</span>
<span class="red">     data_type </span>=><span class="green"> "counter",</span>
<span class="red">   match_value </span>=><span class="blue"> scan_log(".*ftpd\[.*", ".*FTP LOGIN FAILED.*"),</span>
<span class="red">  history_type </span>=><span class="green"> "log",</span>
<span class="red">	action </span>=><span class="blue"> sample_rate("0");</span>

   "/var/log/messages"

<span class="red">	handle </span>=><span class="green"> "ftp_failed_anonymous_login",</span>
<span class="red">   stream_type </span>=><span class="green"> "file",</span>
<span class="red">     data_type </span>=><span class="green"> "counter",</span>
<span class="red">   match_value </span>=><span class="blue"> scan_log(".*ftpd\[.*", ".*ANONYMOUS FTP LOGIN REFUSED.*"),</span>
<span class="red">  history_type </span>=><span class="green"> "log",</span>
<span class="red">	action </span>=><span class="blue"> sample_rate("0");</span>

}

<span class="comment">##########################################################
</span>

<span class="red">body match_value</span> <span class="blue">scan_log(line)</span>
{
<span class="red">select_line_matching </span>=><span class="green"> "$(line)";</span>
<span class="red">track_growing_file </span>=><span class="green"> "true";</span>
}

<span class="red">body match_value</span> <span class="blue">extract_log(line,</span>
{
<span class="red">select_line_matching </span>=><span class="green"> "$(line)";</span>
<span class="red">extraction_regex </span>=><span class="green"> "$(extract)";</span>
<span class="red">track_growing_file </span>=><span class="green"> "true";</span>
}

<span class="red">body action</span> <span class="blue">sample_rate(x)</span>
{
<span class="red">ifelapsed </span>=><span class="green"> "$(x)";</span>
<span class="red">expireafter </span>=><span class="green"> "10";</span>
}
</pre>

<div class="node">
<a name="DNS"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Email">Email</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#FTP">FTP</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Log-scanning">Log scanning</a>

</div>

<h3 class="section">3.3 Scanning DNS logs for query statistics</h3>

<pre class="sp">

</pre>

Another thing you might want to do is monitor the types of queries that your
DNS server is being given.  One possible reason for this is to test for
unusual behavior.  For example, suddenly seeing a surge in &lsquo;<samp><span class="samp">MX</span></samp>&rsquo; requests
might indicate that your system is being targeted by spammers (or that one of
your users is sending spam).  If you are thinking of converting to IPv6, you
might want to compare the number of &lsquo;<samp><span class="samp">A</span></samp>&rsquo; requests to &lsquo;<samp><span class="samp">AAAA</span></samp>&rsquo; and
&lsquo;<samp><span class="samp">A6</span></samp>&rsquo; requests to see how effective your IPv6 implementation is.

   <p>Because DNS logs are directly maintained by &lsquo;<samp><span class="samp">bind</span></samp>&rsquo; or &lsquo;<samp><span class="samp">named</span></samp>&rsquo; (and
do not go through syslog), the parsing can be simpler.  However, you <i>do</i>
need to configure DNS to log query requests to the appropriate log file.  In
our case, we use <samp><span class="file">/var/log/named/queries</span></samp>.

<pre class="verbatim">
<span class="red">bundle monitor</span> <span class="blue">watch_dns</span>
{
<span class="red">vars:
</span>    "query_type"<span class="red"> slist </span>=> { "A", "AAAA", "A6", "CNAME", "MX", "NS",
                            "PTR", "SOA", "TXT", "SRV", "ANY" };
<span class="red">measurements:
</span>    "/var/log/named/queries"
<span class="red">        handle </span>=><span class="green"> "DNS_$(query_type)_counter",</span>
<span class="red">        stream_type </span>=><span class="green"> "file",</span>
<span class="red">        data_type </span>=><span class="green"> "counter",</span>
<span class="red">        match_value </span>=><span class="blue"> scan_log(".* IN $(query_type).*"),</span>
<span class="red">        history_type </span>=><span class="green"> "log",</span>
<span class="red">        action </span>=><span class="blue"> sample_rate("0");</span>
}

<span class="comment">##########################################################
</span>

<span class="red">body match_value</span> <span class="blue">scan_log(line)</span>
{
<span class="red">select_line_matching </span>=><span class="green"> "$(line)";</span>
<span class="red">track_growing_file </span>=><span class="green"> "true";</span>
}

<span class="red">body action</span> <span class="blue">sample_rate(x)</span>
{
<span class="red">ifelapsed </span>=><span class="green"> "$(x)";</span>
<span class="red">expireafter </span>=><span class="green"> "10";</span>
}
</pre>

<div class="node">
<a name="Email"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Milter">Milter</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#DNS">DNS</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Log-scanning">Log scanning</a>

</div>

<h3 class="section">3.4 Scanning syslog for email statistics</h3>

<pre class="sp">

</pre>

Email is another syslog-based facility that you may want to use CFEngine to
monitor.  There are a number of volumetric data that are of interest.  For
example, the number of messages sent and received, the number of messages
that have been deferred (a large number might indicate networking problems or
spam bounces), and the number of spam messages that have been
detected and removed by the assorted spam filters.

   <p>The samples below assume that there is a separate logfile for email (called
<samp><span class="file">/var/log/maillog</span></samp>) and that a few of the standard sendmail rulesets
have been enabled (see
&lsquo;<samp><span class="samp">http://www.sendmail.org/~ca/email/relayingdenied.html</span></samp>&rsquo; for details). 
As with any syslog-generated file, you need to check for the appropriate
service, and in this case we are lumping local messages (sent through
&lsquo;<samp><span class="samp">sm-mta</span></samp>&rsquo;) and remote messages (sent through &lsquo;<samp><span class="samp">sendmail</span></samp>&rsquo;) into a
single count.  Your mileage may of course vary.

   <p>If you use one or more sendmail "milters", each of these will also output
their own syslog messages, and you may choose to track the volume of
rejections on a per-filter basis.

<pre class="verbatim">
<span class="red">bundle monitor</span> <span class="blue">watch_email</span>
{
<span class="red">vars:
</span>    "sendmail"<span class="red"> string </span>=><span class="green"> ".*(sendmail|sm-mta)\[.*";</span>

    "action"<span class="red"> slist </span>=> { "Sent", "Deferred" };

<span class="red">measurements:
</span>
   "/var/log/maillog"

<span class="red">         handle </span>=><span class="green"> "spam_rejected",</span>
<span class="red">    stream_type </span>=><span class="green"> "file",</span>
<span class="red">      data_type </span>=><span class="green"> "counter",</span>
<span class="comment">                   # This matches 3 kinds of rulesets: check_mail,
</span>
<span class="comment">		   # check_rcpt, and check_relay
</span>
<span class="red">    match_value </span>=><span class="blue"> scan_log("$(sendmail)ruleset=check_(mail|rcpt|relay).*"),</span>
<span class="red">   history_type </span>=><span class="green"> "log",</span>
<span class="red">         action </span>=><span class="blue"> sample_rate("0");</span>

   "/var/log/maillog"

<span class="red">         handle </span>=> canonify("mail_$(action)",
<span class="red">    stream_type </span>=><span class="green"> "file",</span>
<span class="red">      data_type </span>=><span class="green"> "counter",</span>
<span class="red">    match_value </span>=> scan_log("$(sendmail)stat=$(action) .*"),
<span class="red">   history_type </span>=><span class="green"> "log",</span>
<span class="red">         action </span>=><span class="blue"> sample_rate("0");</span>

}

<span class="comment">##########################################################
</span>

<span class="red">body match_value</span> <span class="blue">scan_log(line)</span>
{
<span class="red">select_line_matching </span>=><span class="green"> "$(line)";</span>
<span class="red">track_growing_file </span>=><span class="green"> "true";</span>
}

<span class="red">body action</span> <span class="blue">sample_rate(x)</span>
{
<span class="red">ifelapsed </span>=><span class="green"> "$(x)";</span>
<span class="red">expireafter </span>=><span class="green"> "10";</span>
}
</pre>

<div class="node">
<a name="Milter"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Breakin">Breakin</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Email">Email</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Log-scanning">Log scanning</a>

</div>

<h3 class="section">3.5 Scanning syslog for email milter failures</h3>

<pre class="sp">

</pre>

Milters are relatively new in sendmail, and some have problems.  You can also
use monitoring to detect certain types of failure modes.  For example, if a
milter is running (that is, there is a process present) but it does not
respond correctly, sendmail will log an entry like this in syslog (where
&lsquo;<samp><span class="samp">xyzzy</span></samp>&rsquo; is the name of the milter in question):

<pre class="verbatim">Milter (xyzzy): to error state
</pre>

   <p>A small number of these messages is no big deal, since sometimes the milter
has temporary problems or simply encounters an email message that it finds
confounding.  But a larger value of these messages usually indicates that the
milter is in a broken state, and should be restarted.

   <p>You can use &lsquo;<samp><span class="samp">cf-monitord</span></samp>&rsquo; to check for the number of these kinds of
messages, and use the soft classes that it creates to change how
&lsquo;<samp><span class="samp">cf-agent</span></samp>&rsquo; operates.  For example, here we will restart any milter
which is showing a high number of failure-mode messages:

<pre class="verbatim">bundle monitor watch_milter
{
<span class="red">vars:
</span>   "milter"<span class="red"> slist </span>=> { "dcc", "bogom", "greylist" };

<span class="red">measurements:
</span>
   "/var/log/maillog"

<span class="red">         handle </span>=><span class="green"> "${milter}_errors",</span>
<span class="red">    stream_type </span>=><span class="green"> "file",</span>
<span class="red">      data_type </span>=><span class="green"> "counter",</span>
<span class="red">    match_value </span>=> scan_log(".*Milter (${milter}): to error state"),
<span class="red">   history_type </span>=><span class="green"> "log",</span>
<span class="red">         action </span>=><span class="blue"> sample_rate("0");</span>
}

<span class="red">bundle agent</span> <span class="blue">fix_milter</span>
{
<span class="red">vars:
</span>    "m[dcc]"<span class="red"> string      </span>=><span class="green"> "/var/dcc/libexec/start-dccm";</span>
    "m[bogom]"<span class="red"> string    </span>=><span class="green"> "/usr/local/etc/rc.d/milter-bogom.sh restart";</span>
    "m[greylist]"<span class="red"> string </span>=><span class="green"> "/usr/local/etc/rc.d/milter-greylist restart";</span>

<span class="red">commands:
</span>    "$(m[$(watch_milter.milter)])"
<span class="red">	ifvarclass </span>=><span class="green"> "$(watch_milter.milter)_high";</span>
}
</pre>

<div class="node">
<a name="Breakin"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Milter">Milter</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Log-scanning">Log scanning</a>

</div>

<h3 class="section">3.6 Scanning syslog for breakin attempts</h3>

<pre class="sp">

</pre>

A lot of script-kiddies will probe your site for vulnerabilities, using
dictionaries of account/password combinations, looking for unguarded accounts
or accouts with default passwords.  Most of these scans are harmless, because
a well-maintained site will not use the default passwords that these hackers
seek to exploit.

   <p>However, knowing that you are being scanned is a good thing, and CFEngine can
help you find that out.  Because &lsquo;<samp><span class="samp">sshd</span></samp>&rsquo; logs it's message through
&lsquo;<samp><span class="samp">syslog</span></samp>&rsquo;, we again need to filter lines based on the service name.  On
our system, authorization messages are routed to <samp><span class="file">/var/log/auth.log</span></samp>,
and we would monitor it like this:

<pre class="verbatim">bundle monitor watch_breakin_attempts
{
<span class="red">measurements:
</span>    "/var/log/auth.log"
<span class="comment">	 # This is likely what you'll see when a script kiddie probes
</span>
<span class="comment">	 # your system
</span>

<span class="red">         handle </span>=><span class="green"> "ssh_username_probe",</span>
<span class="red">    stream_type </span>=><span class="green"> "file",</span>
<span class="red">      data_type </span>=><span class="green"> "counter",</span>
<span class="red">    match_value </span>=><span class="blue"> scan_log(".*sshd\[.*Invalid user.*"),</span>
<span class="red">   history_type </span>=><span class="green"> "log",</span>
<span class="red">         action </span>=><span class="blue"> sample_rate("0");</span>

    "/var/log/auth.log"
<span class="comment">	 # As scary as this looks, it may just be because someone's DNS
</span>
<span class="comment">	 # records are misconfigured - but you should double check!
</span>

<span class="red">         handle </span>=><span class="green"> "ssh_reverse_map_problem",</span>
<span class="red">    stream_type </span>=><span class="green"> "file",</span>
<span class="red">      data_type </span>=><span class="green"> "counter",</span>
<span class="red">    match_value </span>=><span class="blue"> scan_log(".*sshd\[.*POSSIBLE BREAK-IN ATTEMPT!.*"),</span>
<span class="red">   history_type </span>=><span class="green"> "log",</span>
<span class="red">         action </span>=><span class="blue"> sample_rate("0");</span>

    "/var/log/auth.log"
<span class="comment">	 # Someone is trying to log in to an account that is locked
</span>
<span class="comment">	 # out in the sshd config file
</span>

<span class="red">         handle </span>=><span class="green"> "ssh_denygroups",</span>
<span class="red">    stream_type </span>=><span class="green"> "file",</span>
<span class="red">      data_type </span>=><span class="green"> "counter",</span>
<span class="red">    match_value </span>=><span class="blue"> scan_log(".*sshd\[.*group is listed in DenyGroups.*"),</span>
<span class="red">   history_type </span>=><span class="green"> "log",</span>
<span class="red">         action </span>=><span class="blue"> sample_rate("0");</span>

    "/var/log/auth.log"
<span class="comment">	 # This is more a configuration error in /etc/passwd than a
</span>
<span class="comment">	 # breakin attempt...
</span>

<span class="red">         handle </span>=><span class="green"> "ssh_no_shell",</span>
<span class="red">    stream_type </span>=><span class="green"> "file",</span>
<span class="red">      data_type </span>=><span class="green"> "counter",</span>
<span class="red">    match_value </span>=><span class="blue"> scan_log(".*sshd\[.*because shell \S+ does not exist.*"),</span>
<span class="red">   history_type </span>=><span class="green"> "log",</span>
<span class="red">         action </span>=><span class="blue"> sample_rate("0");</span>

    "/var/log/auth.log"
<span class="comment">	 # These errors usually indicate a problem authenticating to your
</span>
<span class="comment">	 # IMAP or POP3 server
</span>

<span class="red">         handle </span>=><span class="green"> "ssh_pam_error",</span>
<span class="red">    stream_type </span>=><span class="green"> "file",</span>
<span class="red">      data_type </span>=><span class="green"> "counter",</span>
<span class="red">    match_value </span>=> scan_log(".*sshd\[.*error: PAM: authentication error.*"),
<span class="red">   history_type </span>=><span class="green"> "log",</span>
<span class="red">         action </span>=><span class="blue"> sample_rate("0");</span>

    "/var/log/auth.log"
<span class="comment">	 # These errors usually indicate that you haven't rebuilt your
</span>
<span class="comment">	 # database after changing /etc/login.conf - maybe you should
</span>
<span class="comment">	 # include a rule to do this command: cap_mkdb /etc/login.conf
</span>

<span class="red">         handle </span>=><span class="green"> "ssh_pam_error",</span>
<span class="red">    stream_type </span>=><span class="green"> "file",</span>
<span class="red">      data_type </span>=><span class="green"> "counter",</span>
<span class="red">    match_value </span>=> scan_log(".*sshd\[.*login_getclass: unknown class.*"),
<span class="red">   history_type </span>=><span class="green"> "log",</span>
<span class="red">         action </span>=><span class="blue"> sample_rate("0");</span>
}

</pre>

   <p>See the CFEngine Nova documentation for more possibilities of measurement
promises.

<div class="node">
<a name="Intrusion-detection"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Log-scanning">Log scanning</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 Intrusion detection</h2>

<p>Intrusion detection is a highly specialized area.  CFEngine is not
designed specifically to be an intrusion detection or intrusion
prevention system, but it has many features that can be used as part
of an integrated stratey against intrusions.

   <p>What is an intrusion or an attempted intrusion? This can be difficult
to define. If someone tries to login as root once? If someone tries to
login at root fifty times? Is port scanning a sign, or perhaps a SATAN
or ISS scan? Someone trying a known security hole? There is no certain
way to identify the intentions behind activity we observe on a system.

   <p>The aim of an intrusion detection system is to detect events that can
be plausibly connected to incidents or break-ins, hopefully while they
are still in progress so that something can be done about them. 
One way of doing fault diagnosis is to compare a system to a working
specification continuously. This is essentially what CFEngine does
with systems.

   <div class="footnote">
<hr>
<a name="texinfo-footnotes-in-document"></a><h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> Perhaps this master source
has its own version control system for tracking intended changes in the master versions;
we shall not discuss that here.</p>

   <hr></div>

</body></html>


