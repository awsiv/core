<html lang="en">
<head>
<title>Architecture and Security</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Architecture and Security">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
@font-face {
    font-family: 'CFE_FONT';
    src: url('fonts/eot/opensans-regular-webfont.eot');
    src: local('â˜º'),  url('fonts/ttf/opensans-regular-webfont.ttf') format('truetype'), url('fonts/svg/opensans-regular-webfont.svg') format('svg');
    font-weight: normal;
    font-style: normal;
}    
pre {
    background-color: #EEFFDD;
    border: 1px solid #CCCCCC;
    font-family: courier;
    margin-bottom: 10px;
    margin-top: 10px;
    padding: 5px;
    font-size: 90%;
    }
pre.display { font-family:inherit }
pre.format  { font-family:inherit }
pre.smallexample
pre.smalllisp,
pre.smallformat,
pre.smalldisplay {
  font-size: 90%;
} 

span.sc    { font-variant:small-caps }
span.roman { font-family:serif; font-weight:normal; } 
span.sansserif { font-family:sans-serif; font-weight:normal; } 

body {
    font:  90%  'CFE_FONT', arial, Helvetica,sans-serif; 
    color: #646464;
    padding: 10px 20px;
    width: 960px;
    margin: 0 auto;
}
.node
{
    text-align: right;
    padding: 2px;
    font-size: smaller;
}
.node hr {
    border: 0;
    width: 100%;
    color: #CCC;
    background-color: #CCC;
    height: 5px;
}
.section {
    padding-right: 0px;
    padding-bottom: 0px;
    padding-left: 0px;
}

h1 {
    font-size: 26px;
    font-weight: normal;
    line-height: 32px;
    margin: 32px 0 16px;
    text-align: left;
    text-transform: uppercase;
}

h2 {
    color: #9E9981 !important;
    font-size: 16px;
    line-height: 18px;
    font-weight: normal;
    margin: 16px 0 26px;
    text-align: left;
}
h3 {
    margin-top: 3px;
    margin-right: 0px;
    margin-bottom: 10px;
    margin-left: 0px;
    line-height: 20px;
    font-size: 16px;
    font-weight: normal;
}

.contents
{
    background-color: #CCC;
    padding-top: 2px;
    padding-right: 2px;
    padding-bottom: 2px;
    padding-left: 10px;
}

.index-cp
{  
background: #fff url(index-cp.png) right repeat-y;
}

.index-vr
{  
background: #fff url(index-vr.png) right repeat-y;
}

.index-mb
{  
background: #eee url(index-faq.png) right repeat-y;
}

table.border
{
	border-color: #666;
	border-width: 0px;
}

FONT.liten {font-size: 80%; }
 
.tynn {
    font-family: Arial, Helvetica, sans-serif;
    font-size: smaller;
    font-style: normal;
    font-weight: lighter;
    margin-bottom: 0em;
    font-size: 11pt;
}
.verbatim {
    color: #000;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 20px;
    margin-left: 0px;
}
.example {
    color: #000;
    width: 100%;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 20px;
    margin-left: 0px;
}
.smallexample {
    color: #000;
    padding-top: 10px;
    padding-right: 30px;
    padding-bottom: 5px;
    padding-left: 30px;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 0px;
    margin-left: 0px;
}
.cartouche {
    padding: 5px;
    font-style: italic;
    font-size: 85%;
}

table.cartouche {
    border: none !important;
}

 .cartouche td  {
    background-color: #ddd;
    border: 1px solid #ccc;
    padding: 5px;
}

A:link { color: #2c2e70 }
A:visited { color: black }
A:active { color: #600041 }
dt em {font-weight: bold}
/* don't change this rule */    
pre.sp {
    background: none !important;   
    border:none !important
}
/* --- */
/*code hightlight*/
.red { color: #b80047; font-weight: bold; }

.blue { color: blue;  /*font-weight: bold;*/ }

.green { color: darkgreen; }

.comment { font-style: italic; }
--></style>
</head>
<body>
<h1 class="settitle">Architecture and Security</h1>
<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Architecture-Principles">Architecture Principles</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">Security</h2>

<ul class="menu">
<li><a accesskey="1" href="#Architecture-Principles">Architecture Principles</a>
<li><a accesskey="2" href="#Security-Principles">Security Principles</a>
<li><a accesskey="3" href="#Communication-Security">Communication Security</a>
</ul>

<div class="node">
<a name="Architecture-Principles"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Security-Principles">Security Principles</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Architecture Principles</h2>

<p>CFEngine is agent based software. It resides on and runs processes on
each individual computer under its management. That means you do not
need to grant any security credentials for login to CFEngine. Instead, for
normal operation, CFEngine runs in privileged `root' or
`Administrator' mode to get access to system resources and makes these
available safely to authorized enquiries.

   <p>A CFEngine installation is thus required on every machine you want to
manage: client and server, desktop or blade.  Typically, you will
single out one machine to be a <i>policy server</i> or <i>hub</i>. In very
large networks of many thousands of machines, you might need several
policy servers, i.e. several hubs.

   <p>Any piece of software has two different architectures, which should not be confused:

     <ul>
<li>The information flow that results in decisions (weak coupling). 
<li>The software or service dependence graph (strong coupling). 
</ul>

   <p>Information flow is about how users determine what promises the
software should keep; this is entirely informational and once
decisions are made they can be stored (cached) for an indefinite
time. The dependence graph explains what services or resources are
required by the software in order to keep its promises. This is a
strong dependency because the software is unable to function without
the availability of these resources at all times.  Systems are robust
if they are only weakly coupled. Strong dependence introduced
<i>fragility</i> of design.

   <p>In many software products these two separate models are identical in
design and implementation. However, Promise Theory maintains their
independence and CFEngine makes no assumptions about the kind of
information flows that should be set up.

   <pre class="sp">

</pre>
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
CFEngine takes host autonomy as its guiding
architectural principle.  Agents are functionally independent of one another
and only weak couplings can be promised. 
</td></tr></table>

   <pre class="sp">

</pre>
The implication of this principle is that CFEngine is robust to
failures of communication (e.g. network connectivity) and that each
host is responsible for maintaining its own state. This affects the
security and scalability of the solution.

<ul class="menu">
<li><a accesskey="1" href="#Single-point-of-coordination">Single point of coordination</a>
<li><a accesskey="2" href="#Policy-information-flow">Policy information flow</a>
<li><a accesskey="3" href="#Robustness-to-failure">Robustness to failure</a>
<li><a accesskey="4" href="#Distributed-execution-and-federation">Distributed execution and federation</a>
</ul>

<div class="node">
<a name="Single-point-of-coordination"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Policy-information-flow">Policy information flow</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Architecture-Principles">Architecture Principles</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Architecture-Principles">Architecture Principles</a>

</div>

<h3 class="section">1.1 Single point of coordination</h3>

<p>The default CFEngine Nova architecture uses a single hub or policy
server to publish changes of policy and to aggregate knowledge about
the environment, but you can set up as many as you like to manage
different parts of your organization independently.  The CFEngine
technology is not centralized by nature. Most users choose to
centralize updating of policy and report aggregation for convenience
however.

   <pre class="sp">

</pre>
<div align="center"><img src="hub.png" alt="The front page"></div>
<div align="center">Figure: A policy server or `hub' is implemented in CFEngine Nova</div>
<div align="center">as a simple solution that will scale for most sites `out of the box'.</div>
   <pre class="sp">

</pre>

If you operate CFEngine Nova in its default mode, the hub acts as a
server from which every other client machine can access policy
updates. It also acts as a collector, aggregating summary information
from each machine and weaving it into a knowledge map about the datacenter.

   <p>For a single hub configuration, the figure below shows a normal
process approach to managing policy. Policy is edited and developed at
a Policy Definition Point, outside of normal production
environment. This can be done using the specialized editor embedded
in CFEngine Nova, or it can be done using any text editor of your choice.

<div class="node">
<a name="Policy-information-flow"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Robustness-to-failure">Robustness to failure</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Single-point-of-coordination">Single point of coordination</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Architecture-Principles">Architecture Principles</a>

</div>

<h3 class="section">1.2 Policy information flow</h3>

<p>Edits are made in conjunction with a version control
repository<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>, which should be used to document the <i>reasons</i> for changes
to policy<a rel="footnote" href="#fn-2" name="fnd-2"><sup>2</sup></a>.  When a
change has been tested and approved, it will be copied manually to the
policy dispatch point on one or more distribution servers. All other
machines will then download policy updates from that single location according
to their own schedule.

   <pre class="sp">

</pre>
<img src="arch.png" alt="The front page">
<div align="center">Figure: Policy coordinated from a central root location</div>
<div align="center">is implemented in a distributed manner at every leaf node.</div>
   <pre class="sp">

</pre>

<div class="node">
<a name="Robustness-to-failure"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Distributed-execution-and-federation">Distributed execution and federation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Policy-information-flow">Policy information flow</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Architecture-Principles">Architecture Principles</a>

</div>

<h3 class="section">1.3 Robustness to failure</h3>

<p>If an agent receives a policy proposal that is badly formed or in some
way non-executable, it switches to a failover strategy to recover. It will
continue in this mode until a new policy proposal is available that can be
executed.

   <p>The CFEngine agent clones itself to avoid limitations of operating systems
like Windows, where programs and disk files cannot be altered while in use. 
When new software updates are available, CFEngine can update itself from
a suitable source, and restart its own services. Should the new version be corrupt,
the twin will still be the old working version, hence the software will be able
to recover as soon as a new valid version is available.

<div class="node">
<a name="Distributed-execution-and-federation"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Robustness-to-failure">Robustness to failure</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Architecture-Principles">Architecture Principles</a>

</div>

<h3 class="section">1.4 Distributed execution and federation</h3>

<p>Each agent runs independently of others, unless it promises to
acquire services from other hosts. Thus all processing capacity and
decision-making computation takes place on the end nodes of the
communication graph. There is no apriori need for agents to collect
data from any source outside themselves,  though this is a highly
convenient strategy. CFEngine's use of the network may be called opportunistic.

   <p>Each agent is the ultimate arbiter of whether or not to accept
information from external sources. This makes CFEngine ideal for use
in federated architectures, where attention to local requirements is
paramount for whatever reason.  Federation is typically a recommended
strategy when the cost of avoiding local specialization outweighs the
price of having local policy-makers. Universities and large companies
(e.g. formed through acquisition) are typical candidates for federated
management. Federation is facilitated by an essentially `service
oriented architecture'<a rel="footnote" href="#fn-3" name="fnd-3"><sup>3</sup></a>, i.e. a weak coupling.

<div class="node">
<a name="Security-Principles"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Communication-Security">Communication Security</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Architecture-Principles">Architecture Principles</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Security Principles</h2>

<ul class="menu">
<li><a accesskey="1" href="#What-is-security_003f">What is security?</a>
<li><a accesskey="2" href="#The-principles-of-CFEngine-security">The principles of CFEngine security</a>
<li><a accesskey="3" href="#Communications">Communications</a>
</ul>

<div class="node">
<a name="What-is-security%3f"></a>
<a name="What-is-security_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-principles-of-CFEngine-security">The principles of CFEngine security</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Security-Principles">Security Principles</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Security-Principles">Security Principles</a>

</div>

<h3 class="section">2.1 What is security?</h3>

<pre class="sp">

</pre>

The concept of security, while various in its interpretation and
intented use, is related to a feeling of safety.  No system is
completely safe from every threat, thus no system can promise complete
security.  Security is ultimately defined by a model, an attitude, and
a policy. It involves a set of compromises called a <i>trust model</i>
that determines where you draw the line in the sand between trusted
and risky.

<div class="node">
<a name="The-principles-of-CFEngine-security"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Communications">Communications</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-is-security_003f">What is security?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Security-Principles">Security Principles</a>

</div>

<h3 class="section">2.2 The principles of CFEngine security</h3>

<p>CFEngine adheres to the following design principles:

     <ol type=1 start=1>
<li>It shall be, by design, impossible to send policy-altering data to
a CFEngine agent. Each host shall retain its right to veto policy suggestions
at all times. This is called the Voluntary Cooperation Model.

     <li>CFEngine will support the encyrption of data transmitted over the network.

     <li>Each host shall continue to function, as
far as possible, without the need for communication with other hosts.

     <li>CFEngine will use a lightweight peer model for key trust (like
the Secure Shell). No centralized certificate authority shall be
used. SSL and TLS shall not be used.

     <li>CFEngine shall always provide safe defaults, that grant no access to other
hosts.
        </ol>

<div class="node">
<a name="Communications"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-principles-of-CFEngine-security">The principles of CFEngine security</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Security-Principles">Security Principles</a>

</div>

<h3 class="section">2.3 Communications</h3>

<p>CFEngine uses a simple, private protocol that is based on (but not
identical to) that used by OpenSSH (the free version of the Secure
Shel). It is based on mutual, bi-directional challenge-reponse using
an autonomous Public Key Infrastructure.

     <ul>
<li>Authentication by Public Key is mandatory. 
<li>Encryption of data transfer is optional. 
</ul>

<div class="node">
<a name="Communication-Security"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Security-Principles">Security Principles</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 Communication Security</h2>

<ul class="menu">
<li><a accesskey="1" href="#TCP-wrappers">TCP wrappers</a>
<li><a accesskey="2" href="#The-connection-sequence">The connection sequence</a>
<li><a accesskey="3" href="#Encyption-algorithms">Encyption algorithms</a>
<li><a accesskey="4" href="#Remote-communication">Remote communication</a>
<li><a accesskey="5" href="#Authentication">Authentication</a>
<li><a accesskey="6" href="#Security-FAQ">Security FAQ</a>
<li><a accesskey="7" href="#CFEngine-and-Firewalls">CFEngine and Firewalls</a>
<li><a accesskey="8" href="#Tamperproof-data-and-distributed-monitoring">Tamperproof data and distributed monitoring</a>
</ul>

<div class="node">
<a name="TCP-wrappers"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-connection-sequence">The connection sequence</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Communication-Security">Communication Security</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Communication-Security">Communication Security</a>

</div>

<h3 class="section">3.1 TCP wrappers</h3>

<p>The right to connect to the server is the first line of defence. 
CFEngine has built into it the equivalent of the `TCP wrappers'
software to deny non-authorized hosts the ability to connect to the
server at all.

<div class="node">
<a name="The-connection-sequence"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Encyption-algorithms">Encyption algorithms</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#TCP-wrappers">TCP wrappers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Communication-Security">Communication Security</a>

</div>

<h3 class="section">3.2 The connection sequence</h3>

     <ol type=1 start=1>

     <li>A client attempts to connect to port 5308
<li>Server examines IP address of connection and applies rules from
<pre class="verbatim">     allowconnects
     allowallconnects
     denyconnects
</pre>
<li>If host is allowed to connect, read max 2048 bytes to look for valid hail

     <li>Client sends its hostname, username and public key to server
<li>Server checks whether public key is known
          <ul>
<li>If known, host and user are confirmed, go to access control
<li>If unknown, use trustkeysfrom rules to check whether  we should accept the client's asserted identity
</ul>
     <li>If not in trustkeysfrom list, break connection
<li>If willing to trust, go to further checks

     <li>If skipverify is set, ignore reverse DNS lookup checks else check asserted identity by reverse DNS lookup
<li>If fails break off
<li>Check user ID is in allowusers
<li>If fails break off
<li>Go to file access control

     <li>Process admit first then deny
<li>Mapping of root privilege on server is governed by <code>maproot</code>. If this is false, only resources owned by the authenticated user name may be transmitted. 
<li>If <code>ifencrypted</code> is set, access is denied to non-encrypted connections. 
<li>Symbolic links to files are not honoured by the server when computing access. 
<li>Access control is evaluated by the rules:
          <ul>
<li>First admit rule that matches wins
<li>All other admit rules are ignored
<li>No admit rule means you're denied! 
<li>Then look at deny rules (overrides admit)
<li>First deny rule that matches wins
<li>All other deny rules are ignored
<li>No deny rule means you're admitted
</ul>
     </ol>

<div class="node">
<a name="Encyption-algorithms"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Remote-communication">Remote communication</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-connection-sequence">The connection sequence</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Communication-Security">Communication Security</a>

</div>

<h3 class="section">3.3 Encryption algorithms</h3>

<p>CFEngine Community Edition uses RSA 2048 public key encryption for
authentication. These are generated by the &lsquo;<samp><span class="samp">cf-key</span></samp>&rsquo; command. 
It generates a 128 bit random Blowfish encryption key for data
transmission. Challenge response is verified by an MD5 hash.

   <p>Commercial Editions of CFEngine use the same RSA 2048 key for
authentication, and then AES 256 with a 256 bit random key for data
transmission. The latter is validated for FIPS 140-2 government use in
the United States of America. Challenge response is verified by a SHA256
hash.

<div class="node">
<a name="Remote-communication"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Authentication">Authentication</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Encyption-algorithms">Encyption algorithms</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Communication-Security">Communication Security</a>

</div>

<h3 class="section">3.4 Remote communication</h3>

<p>The concept of voluntary cooperation used by CFEngine places restrictions
on how files can be copied between hosts.  CFEngine allows only `pull'
(download) but not `push' (upload). Users cannot force an agent to
perform an operation against local policy.

   <p>To allow remote copying between two systems each
of the system must explicitly grant access before the operation can
take place.

<!-- =========================================================================0 -->
<div class="node">
<a name="Authentication"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Security-FAQ">Security FAQ</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Remote-communication">Remote communication</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Communication-Security">Communication Security</a>

</div>

<h3 class="section">3.5 Authentication</h3>

<p>Authentication is about making sure users are who they say you
are. Traditionally, there are two approaches: the trusted third
party (arbiter of the truth) approach, and the challenge-response
approach. The Trust Third Party decides whether two individuals who
want to authenticate should trust each other. This is the model used
in the Web.

   <p>The challenge-response approach allows each individual to decide
personally whether to trust the other. This is the approach used by
CFEngine. Its model is based in the Secure Shell (OpenSSH).

   <p>Two machines authenticate each other in a <i>public key exchange</i>
process. For key exchange between client and server, the server has to
decide if it will trust the client by using the <code>trustkeysfrom</code>
directive. The <code>trustkeysfrom</code> directive allows the server to accept
keys from one or more machines.

   <p>On the client-side the client also has to specify if it will trust key
from the server by using the trustkey directive. The <code>trustkey</code>
directive in <code>copy_from</code> allows a client to decide whether to
accept keys from a server. The CFEngine authentication model is based
on the <code>ssh</code> scheme, however unlike <code>ssh</code>, CFEngine
authentication is not interactive and the keys are generated by
<code>cf-key</code> program instead of &lsquo;<samp><span class="samp">ssh key-gen</span></samp>&rsquo; program. Key
acceptance is accomplished in CFEngine using trust-key method. Once
the keys have been exchange the trust settings are irrelevant.

<div class="node">
<a name="Security-FAQ"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#CFEngine-and-Firewalls">CFEngine and Firewalls</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Authentication">Authentication</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Communication-Security">Communication Security</a>

</div>

<h3 class="section">3.6 Security FAQ</h3>

     <ul>
<li><i> Doesn't opening a port on a machine on the inside of the firewall make
it vulnerable to both Denial of Service and buffer overflow attacks?</i>

     <p>Buffer overflow attacks are extremely unlikely in CFEngine by
design. The likelihood of a bug in CFEngine should be compared to the
likelihood of a bug existing in the firewall itself.

     <p>Denial of Service attacks can be mitigated by careful
configuration. <code>cf-serverd</code> reads a fixed number of bytes from the
input stream before deciding whether to drop a connection from a
remote host, so it is not possible to buffer overflow attack before
rejection of an invalid host IP.

     <p>Another possibility is to use a standard VPN to the inside of the
firewall. That way one is concerned first and foremost with the
vulnerabilities of the VPN software.

     <li><i>Doesn't opening the firewall
compromise the integrity of the policy information by allowing an
attacker the chance to alter it?</i>

     <p>The CFEngine security model, as well
as the design of the server, disallows the uploading of
information. No message sent over the CFEngine channel can alter data
on the server. (This assumes that buffer overflows are impossible.)

     <li><i>Couldn't an IP spoofer gain access to data from the policy
server that it should not be able to access?</i>

     <p>Assuming that buffer overflow attacks and DOS attacks are highly
improbable, the main worry with opening a port is that intruders will
be able to gain access to unauthorized data. If the firewall is
configured to open only connections from the policy mirror, then an
attacker must spoof the IP of the policy attacker. This requires
access to another host in the DMZ and is non-trivial. However, suppose
the attacker succeeds then the worst he/she can do is to download
information that is available to the policy-mirror. But that
information is already available in the DMZ since the data have been
exported as part of the policy, thus there is no breach of
security. (Security must be understood to be a breach of the terms of
policy that has been decided.)

     <li><i> What happens if the policy mirror is invaded by an attacker?</i>

     <p>If an attacker gains root access to the mirror, he/she will be able to
affect the policy distributed to any host. The
policy-mirror has no access to alter any information on the policy
source host. Note that this is consistent with the firewall security
model of trusted/untrusted regions. The firewall does not mitigate the
responsibility of security every host in a network regardless of which
side of the firewall it is connected. 
</ul>

<!--  -->
<ul class="menu">
<li><a accesskey="1" href="#CFEngine-and-Firewalls">CFEngine and Firewalls</a>
</ul>

<div class="node">
<a name="CFEngine-and-Firewalls"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Tamperproof-data-and-distributed-monitoring">Tamperproof data and distributed monitoring</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Security-FAQ">Security FAQ</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Communication-Security">Communication Security</a>

</div>

<h3 class="section">3.7 CFEngine and Firewalls</h3>

<p>Some users want to use CFEngine's remote copying mechanism through a
firewall, in particular to update the CFEngine policy on hosts inside
a DMZ (so-called de-militarized zone). In making a risk assessment, it
is important to see the firewall security model together with the
CFEngine security model. CFEngine's security record is better than
most firewalls, but Firewalls are nearly always trusted because they
are `security products'.

   <p>Any piece of software that traverses a firewall can, in principle,
weaken the security of the barrier. On the other hand, a strong piece
or software might have better security than the firewall
itself. Consider the example in the figure;

   <div class="block-image"><img src="firewall.png" alt="A CFEngine host outside a firewall"></div>

   <p>We label the regions inside and outside of the firewall as the &ldquo;secure
area" and &ldquo;Demilitarized Zone" for convenience. It should be
understood that the areas inside a firewall is not necessarily secure
in any sense of the word unless the firewall configuration is
understood together with all other security measures.

   <p>Our problem is to copy files from the &ldquo;secure&rdquo; source machine to hosts
in the DMZ, in order to send them their configuration policy
updates. There are two ways of getting files through the firewall:

     <ul>
<li>An automated CFEngine solution, i.e., pull from outside to inside the secure area. 
<li>A manual push to the outside of the wall from the inside. 
</ul>

   <p>One of the
main aims of a firewall is to prevent hosts outside the secure area
from opening connections to hosts in the secure area. If we want
<code>cfagent</code> processes on the outside of the firewall to receive updated policies
from the inside of the firewall, information has to traverse the
firewall.

<!--  -->
<ul class="menu">
<li><a accesskey="1" href="#CFEngine-trust-model">CFEngine trust model</a>
<li><a accesskey="2" href="#Policy-Mirror-in-the-DMZ">Policy Mirror in the DMZ</a>
<li><a accesskey="3" href="#Pulling-through-a-wormhole">Pulling through a wormhole</a>
</ul>

<div class="node">
<a name="CFEngine-trust-model"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Policy-Mirror-in-the-DMZ">Policy Mirror in the DMZ</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#CFEngine-and-Firewalls">CFEngine and Firewalls</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#CFEngine-and-Firewalls">CFEngine and Firewalls</a>

</div>

<h4 class="subsection">3.7.1 CFEngine trust model</h4>

<p>CFEngine's trust model is fundamentally at odds with the external
firewall concept. CFEngine says: &ldquo;I am my own boss. I don't trust
anyone to push me data.&rdquo; The firewall says: &ldquo;I only trust things
that are behind me.&rdquo;  The firewall thinks it is being secure if it
pushes data from behind itself to the DMZ. CFEngine thinks it is being
secure if it makes the decision to pull the data autonomously, without
any orders from some potentially unknown machine. One of these
mechanisms has to give if firewalls are to co-exist with CFEngine.

   <p>From the firewall's viewpoint, push and pull are different: a push
requires only an outgoing connection from a trusted source to an
untrusted destination; a pull necessarily requires an untrusted
connection being opened to a trusted server within the secure area. 
For some firewall administrators, the latter is simply unacceptable
(because they are conditioned to trust their firewall). But it is
important to evaluate the actual risk. We have a few observations
about the latter to offer at this point:

     <ul>
<li>It is not the aim of this note to advocate any one method of
update. You must decide for yourself. The aim here is only to evaluate
the security implications. Exporting data from the secure area to the
DMZ automatically downgrades the privacy of the information.

     <li>The CFEngine security model assumes that the security of every host
will be taken seriously. A firewall should never be used as a
substitute for host security.

     <li>Knowing about CFEngine but not your firewall or your secure network, it is only possible
to say here that it seems, to us, safe to open a hole in a firewall to
download data from a host of our choice, but we would not accept data
from just any host on your company network on trust. It would be
ludicrous to suggest that an arbitrary employee's machine is more
secure than an inaccessible host in the DMZ. 
</ul>

<!--  -->
<div class="node">
<a name="Policy-Mirror-in-the-DMZ"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Pulling-through-a-wormhole">Pulling through a wormhole</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#CFEngine-trust-model">CFEngine trust model</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#CFEngine-and-Firewalls">CFEngine and Firewalls</a>

</div>

<h4 class="subsection">3.7.2 Policy Mirror in the DMZ</h4>

<p>By creating a policy mirror in the DMZ, these issues can be worked around. This is
the recommended way to copy files, so that normal CFEngine pull
methods can then be used by all other hosts in the DMZ, using the
mirror as their source. The policy mirror host should be as secure as
possible, with preferably few or no other services running that might
allow an attacker to compromise it. In this configuration, you are
using the mirror host as an envoi of the secure region in the DMZ.

   <p>Any method of pushing a new version of policy can be chosen in
principle: CVS, FTP, RSYNC, SCP. The security disadvantage of the push
method is that it opens a port on the policy-mirror, and therefore the
same vulnerability is now present on the mirror, except that now you
have to trust the security of another piece of software too. Since
this is not a CFEngine port, no guarantees can be made about what
access attackers will get to the mirror host.

<!--  -->
<div class="node">
<a name="Pulling-through-a-wormhole"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Policy-Mirror-in-the-DMZ">Policy Mirror in the DMZ</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#CFEngine-and-Firewalls">CFEngine and Firewalls</a>

</div>

<h4 class="subsection">3.7.3 Pulling through a wormhole</h4>

<p>Suppose you are allowed to open a hole in your firewall to a single
policy host on the inside.  To distribute files to hosts that are
outside the firewall it is only necessary to open a single tunnel
through the firewall from the policy-mirror to the CFEngine service
port on the source machine. Connections from any other host will still
be denied by the firewall. This minimizes the risk of any problems
caused by attackers.

   <p>To open a tunnel through the firewall, you need to alter
the filter rules. A firewall blocks access at the network
level. Configuring the opening of a single port is
straightforward. We present some sample rules below, but make sure
you seek the guidance of an expert if necessary.

   <p>Cisco IOS rules look like this
<pre class="smallexample">     ip access-group 100 in
     access-list     100 permit tcp mirror host source eq 5308
     access-list     100 deny   ip  any any
</pre>
   <p>Linux <code>iptables</code> rules might look something like this:
<pre class="smallexample">     iptables -N newchain
     iptables -A newchain -p tcp -s mirror-ip 5308 -j ACCEPT
     iptables -A newchain -j DENY
</pre>
   <p>Once a new copy of the policy is downloaded by CFEngine to the policy
mirror, other clients in the DMZ can download that copy from the
mirror. The security of other hosts in the DMZ is dependent on the
security of the policy mirror.

<div class="node">
<a name="Tamperproof-data-and-distributed-monitoring"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#CFEngine-and-Firewalls">CFEngine and Firewalls</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Communication-Security">Communication Security</a>

</div>

<h3 class="section">3.8 Tamperproof data and distributed monitoring</h3>

<p>Message digests are supposed to be unbreakable, tamperproof
technologies, but of course everything can be broken by a sufficiently
determined attacker. Suppose someone wanted to edit a file and alter
the CFEngine checksum database to cover their tracks. If they had
broken into your system, this is potentially easy to do. How can we
detect whether this has happened or not?

   <p>A simple solution to this problem is to use another checksum-based
operation to copy the database to a completely different host. By using
a copy operation based on a checksum value, we can also remotely detect
a change in the checksum database itself.

   <p>Consider the following code:

<pre class="verbatim">
bundle agent change_management
{
vars:

  "watch_files" slist =>  {
                          "/etc/passwd", 
                          "/etc/shadow", 
                          "/etc/group", 
                          "/etc/services" 
                          };

  "neighbours"   slist => peers("/var/cfengine/inputs/hostlist","#.*",4),
               comment => "Partition the network into groups";

files:

   "$(watch_files)"
 
      comment      => "Change detection on the above",
      changes      => detect_diff_content;

  #######################################################################
  # Redundant cross monitoring .......................................
  #######################################################################

  "$(sys.workdir)/nw/$(neighbours)_checksum_digests.db"

     comment => "Watching our peers remote hash tables for changes - cross check",
   copy_from => remote_cp("$(sys.workdir)/checksum_digests.db","$(neighbours)"),
  depends_on => { "grant_hash_tables" },
      action => neighbourwatch("File changes observed on $(neighbours)");

</pre>

   <p>It works by building a list of neighbours for each host. The function
<code>peers</code> can be used for this. Using a file which contains a list
of all hosts running CFEngine, we create a list of hosts to copy
databases . Each host in the network therefore takes on the
responsibility to watch over its neighbours.

   <p>In theory, all four neighbours should signal this change. If an
attacker had detailed knowledge of the system, he or she might be able
to subvert one or two of these before the change was detected, but it
is unlikely that all four could be covered up. At any rate, this
approach maximizes the chances of change detection.

   <p>Consider what happens if an attacker changes a file an
edits the checksum database. Each of the four hosts that has been
designated a neighbour will attempt to update their own copy of the
database. If the database has been tampered with, they will detect a
change in the checksums of the remote copy versus the
original. The file will therefore be copied.

   <p>It is not a big problem that others have a copy of your checksum
database.Â  They cannot see the contents of your files from this.Â  A
possibly greater problem is that this configuration will unleash an
avalanche of messages if a change is detected. This makes messages
visible at least.

   <div class="footnote">
<hr>
<a name="texinfo-footnotes-in-document"></a><h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> CFEngine supports integration with Subversion
through its Mission Portal, but any versioning system can of course be
used.</p>

   <p class="footnote"><small>[<a name="fn-2" href="#fnd-2">2</a>]</small> CFEngine and version control will document <i>what</i>
the changes are, but what is usually missing from user documentation
is an explanation of the reasonsing behind the change. This is most
valuable when trying to diagnose and debug changes later.</p>

   <p class="footnote"><small>[<a name="fn-3" href="#fnd-3">3</a>]</small> NB. CFEngine does not use web services
as part of its technology, so this should not be construed to mean SOA.</p>

   <hr></div>

</body></html>

