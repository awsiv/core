<html lang="en">
<head>
<title>Change Management and Incident Repair</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Change Management and Incident Repair">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
@font-face {
    font-family: 'CFE_FONT';
    src: url('fonts/eot/opensans-regular-webfont.eot');
    src: local('â˜º'),  url('fonts/ttf/opensans-regular-webfont.ttf') format('truetype'), url('fonts/svg/opensans-regular-webfont.svg') format('svg');
    font-weight: normal;
    font-style: normal;
}    
pre {
    background-color: #EEFFDD;
    border: 1px solid #CCCCCC;
    font-family: courier;
    margin-bottom: 10px;
    margin-top: 10px;
    padding: 5px;
    font-size: 90%;
    }
pre.display { font-family:inherit }
pre.format  { font-family:inherit }
pre.smallexample
pre.smalllisp,
pre.smallformat,
pre.smalldisplay {
  font-size: 90%;
} 

span.sc    { font-variant:small-caps }
span.roman { font-family:serif; font-weight:normal; } 
span.sansserif { font-family:sans-serif; font-weight:normal; } 

body {
    font:  90%  'CFE_FONT', arial, Helvetica,sans-serif; 
    color: #646464;
    padding: 10px 20px;
    width: 960px;
    margin: 0 auto;
}
.node
{
    text-align: right;
    padding: 2px;
    font-size: smaller;
}
.node hr {
    border: 0;
    width: 100%;
    color: #CCC;
    background-color: #CCC;
    height: 5px;
}
.section {
    padding-right: 0px;
    padding-bottom: 0px;
    padding-left: 0px;
}

h1 {
    font-size: 26px;
    font-weight: normal;
    line-height: 32px;
    margin: 32px 0 16px;
    text-align: left;
    text-transform: uppercase;
}

h2 {
    color: #9E9981 !important;
    font-size: 16px;
    line-height: 18px;
    font-weight: normal;
    margin: 16px 0 26px;
    text-align: left;
}
h3 {
    margin-top: 3px;
    margin-right: 0px;
    margin-bottom: 10px;
    margin-left: 0px;
    line-height: 20px;
    font-size: 16px;
    font-weight: normal;
}

.contents
{
    background-color: #CCC;
    padding-top: 2px;
    padding-right: 2px;
    padding-bottom: 2px;
    padding-left: 10px;
}

.index-cp
{  
background: #fff url(index-cp.png) right repeat-y;
}

.index-vr
{  
background: #fff url(index-vr.png) right repeat-y;
}

.index-mb
{  
background: #eee url(index-faq.png) right repeat-y;
}

table.border
{
	border-color: #666;
	border-width: 0px;
}

FONT.liten {font-size: 80%; }
 
.tynn {
    font-family: Arial, Helvetica, sans-serif;
    font-size: smaller;
    font-style: normal;
    font-weight: lighter;
    margin-bottom: 0em;
    font-size: 11pt;
}
.verbatim {
    color: #000;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 20px;
    margin-left: 0px;
}
.example {
    color: #000;
    width: 100%;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 20px;
    margin-left: 0px;
}
.smallexample {
    color: #000;
    padding-top: 10px;
    padding-right: 30px;
    padding-bottom: 5px;
    padding-left: 30px;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 0px;
    margin-left: 0px;
}
.cartouche {
    padding: 5px;
    font-style: italic;
    font-size: 85%;
}

table.cartouche {
    border: none !important;
}

 .cartouche td  {
    background-color: #ddd;
    border: 1px solid #ccc;
    padding: 5px;
}

A:link { color: #2c2e70 }
A:visited { color: black }
A:active { color: #600041 }
dt em {font-weight: bold}
/* don't change this rule */    
pre.sp {
    background: none !important;   
    border:none !important
}
/* --- */
/*code hightlight*/
.red { color: #b80047; font-weight: bold; }

.blue { color: blue;  /*font-weight: bold;*/ }

.green { color: darkgreen; }

.comment { font-style: italic; }
--></style>
</head>
<body>
<h1 class="settitle">Change Management and Incident Repair</h1>
<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-is-change-management_003f">What is change management?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">Change Management</h2>

<ul class="menu">
<li><a accesskey="1" href="#What-is-change-management_003f">What is change management?</a>
<li><a accesskey="2" href="#Regulation-_002d-authorized-and-unauthorized-change">Regulation - authorized and unauthorized change</a>
<li><a accesskey="3" href="#Intended-and-unintended-change">Intended and unintended change</a>
<li><a accesskey="4" href="#How-fast-should-changes-be-made_003f">How fast should changes be made?</a>
<li><a accesskey="5" href="#Partially-centralized-change">Partially centralized change</a>
<li><a accesskey="6" href="#The-decision-point">The decision point</a>
<li><a accesskey="7" href="#Promises-about-change-vs-state">Promises about change vs state</a>
<li><a accesskey="8" href="#Promises-about-change">Promises about change</a>
<li><a accesskey="9" href="#Change-management-and-knowledge-management">Change management and knowledge management</a>
<li><a href="#Non_002ddestructive-change">Non-destructive change</a>
<li><a href="#Change-and-convergence">Change and convergence</a>
<li><a href="#The-change-decision-process-or-release-management">The change decision process or release management</a>
<li><a href="#Deploying-policy-changes">Deploying policy changes</a>
</ul>

   <p><a href="#Contents"><h1>COMPLETE TABLE OF CONTENTS</h1></a>
<h2>Summary of contents</h2>

<div class="node">
<a name="What-is-change-management%3f"></a>
<a name="What-is-change-management_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Regulation-_002d-authorized-and-unauthorized-change">Regulation - authorized and unauthorized change</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">What is change management?</h3>

<pre class="sp">

</pre>
Change Management is about the planning and implementation
of intended changes to an IT system, as well as the detection,
documentation and possible repair of unintended changes. 
Change Management involves the assessment of current system state,
the planning, testing and quality assurance cycles, and
scheduling of improvements.

   <p>There are many accounts of change management in the industry. Often
these make assumptions about the management framework being used. In
the context of CFEngine automation, some of these approaches are
considered antiquated. This guide explains change management in the
framework of CFEngine's self-healing automation.

<div class="node">
<a name="Regulation---authorized-and-unauthorized-change"></a>
<a name="Regulation-_002d-authorized-and-unauthorized-change"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Intended-and-unintended-change">Intended and unintended change</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-is-change-management_003f">What is change management?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Regulation: authorized and unauthorized change</h3>

<pre class="sp">

</pre>

It is common to speak of <i>authorized</i> and <i>unauthorized</i> change in
the IT industry. Many organizations think in these authoritarian terms
and use management techniques designed for a slower-moving
world. Today's e-commerce companies usually have much more agile and
dynamical processes for change.

   <p>The purpose of change regulation is to minimize the risk of actions
taken by humans, i.e. to avoid human error. This approach makes sense
in low-tech companies that have environments where change is only
about long-term wear and tear or intended modifications to
infrastructure (like a adding new building, or fitting a new gasket on
a car). In today's IT-driven organizations, problems arise a thousand
or more times faster than that, and a new approach is needed.

   <p>Procedures for change, based on legacy regulative methods are incorporated
into popular frameworks for human management, such as ITIL. They begin
by making a formal Request For Change (RFC), which is processed by
management in order to secure permission to exercise a change during
an allocated time-window.  In some cases, an ordinary repair such as
restarting a server could take weeks to process, as mandatory Root
Cause Analysis (RCA) is undertaken. The Mean Time To Repair (MTTR) is
dominated by internal bureaucracy.

   <p>Today's IT-based organizations, experience unintended change too quickly
for such a process however, and there is a real risk of lost revenues
from not repairing issues quickly. As many organizations are fearful
of litigation or management reprisals, preferring to err on the side of
caution, it is necessary to evaluate the best strategy for avoiding
exposure to risk. 
To use automation effectively, it makes sense to separate change management
into two phases:
     <ul>
<li>Change of policy itself - which defines desired state.

     <p>Policy has a strategic impact, and its change deserves a process that includes
expert opinions, staged testing and ultimately a phased deployment
during a controllable time-window.

     <li>Change that brings systems into compliance with policy.

     <p>Once policy is frozen for a period of time, any unintended changes
must be considered infractions (non-compliance), and repairs should be made according
to what has already been decided.  This should happen without delay,
rather than starting a new process to delay action.  The ethical issue
is now turned on its head: execessive caution in fixing what has
already been decided may be seen as prevarication and even negligence.

   </ul>

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
The CFEngine way of managing change is to migrate systems through
states of <i>stable equilibrium</i>. One should not believe that systems
continue flawlessly because no intended changes are made. Change
management with CFEngine should be about planning one stable state
after another, but expecting run-time errors. The rate at which you
move through revisions of stable policy depends on your needs. 
The rate at which compliance is repaired should be `as soon as possible'.

   <p>To use an analogy: if policy changes are like take-off and landing,
then a period of stable operations is like a smooth flight, on course
to the correct destination.  If unintended changes happen to change
that, like the weather, immediate course corrections should be made to
avoid loss. 
</td></tr></table>

<div class="node">
<a name="Intended-and-unintended-change"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-fast-should-changes-be-made_003f">How fast should changes be made?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Regulation-_002d-authorized-and-unauthorized-change">Regulation - authorized and unauthorized change</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Intended and unintended change</h3>

<pre class="sp">

</pre>

To institue a rational approach to change management, i.e. one that is
suited to business's operational time-scales, we need to think about
separating change into two the categories implied above: change by
design and change by fate. It is desirable to exercise due diligence
in the design of a system's intended state, but we must be ready to
quickly repair faults that might disrupt business services.  We need
to distinguish:
     <ul>
<li>Purposeful change of an intended policy (planning). 
<li>Change in the actual system state and behaviour (implementation and maintenance). 
</ul>
   What is intended and what actually happens should not be confused. 
It is impossible to `lock down' or fully control changes made to
computer systems, without switching them off. A mandatory level of risk
must be anticipated.

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
It is by defining a desired operational state that one can avoid re-processing
every since repair to a system. 
</td></tr></table>

<div class="node">
<a name="How-fast-should-changes-be-made%3f"></a>
<a name="How-fast-should-changes-be-made_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Partially-centralized-change">Partially centralized change</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Intended-and-unintended-change">Intended and unintended change</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">How fast should changes be made?</h3>

<pre class="sp">

</pre>

Time scales are crucially important in engineering, and deserve equal
importance in IT management. Ask yourself: how do you know if
something is changing or not? You've probably heard catchetisms such
as:

     <ul>
<li>A watched kettle never boils. 
<li>Tempus fugit (time flies). 
</ul>

   <p>These phrases capture the idea that, if we expect to see change at a
certain rate, it is possible to miss changes that occur at either a
faster or slower rate. When we manage a <i>dynamical</i> process, we have
to attend to the system at the same rate as change takes place.

   <p>If there is a process changing the system once a day, then to keep the
system aligned with its desired state, there must be a corrective
process that repairs this once per day (the Mean Time To Repair or
MTTR should be the same as the Mean Time Before Failure MTBF), else
the system will experience significant deviations from policy. In the
worst case, this could result in security leaks or loss of
revenue. This is not the full story of course: there will always be
some delay between error and repair (actual time to repair). To
minimize the impact of lost compliance and deviations from intended
state, changes should be made before serious consequences can ensue
that require more significant repairs<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>.

   <p>Thus, mean time to repair is not a metric that should be used to
define ideal time to repair. The ideal time should be that which
minimizes the risk of losses to operations, and therefore revenues.

   <p>The advantage of CFEngine's two-phase approach to change is that
approved changes can be made a quickly as possible, without
significant use of resources. CFEngine's lightweight agents can
run every five minutes to achieve a tight alignment with operational
and business goals.

   <pre class="sp">

</pre>
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
In information theory, Nyquist's theorem says that, in order to properly
track (and potentially correct) a process that happens at rate R,
one must sample the system at twice this rate 2R. 
In CFEngine, we have chosen a repair resolution of 5 minutes for configuration
sampling, because measurements show that many system characteristics have
auto-correlations times of 10-20 minutes<a rel="footnote" href="#fn-2" name="fnd-2"><sup>2</sup></a>. 
</td></tr></table>

<div class="node">
<a name="Partially-centralized-change"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-decision-point">The decision point</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-fast-should-changes-be-made_003f">How fast should changes be made?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Partially centralized change</h3>

<pre class="sp">

</pre>

It is not necessary to assume a central model of authority to manage
change. Indeed, many CFEngine users have highly devolved organizations
with many decision makers.  Federated regions of an organization can
maintain independent policies, aligned with different cultures if
necessary.

   <pre class="sp">

</pre>
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
What may be problematic is to have teams that are not aligned, so that
there are <i>conficting intentions</i>. In this case, one individual
might instigate a change that conflicts with another. This often
happens in `hit'n'run system administration', where there is no concerted
plan or modus operandi. 
</td></tr></table>

   <pre class="sp">

</pre>
To keep federated teams aligned with common criteria for policy,
strong communication is required. For this we provide access to
information through the Mission Portal.  This shows the policy itself
in different regions, as well as reports about the compliance of
systems. Users can also exchange messages about their intentions,
through policy comments and personal logs in the system.

<div class="node">
<a name="The-decision-point"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Promises-about-change-vs-state">Promises about change vs state</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partially-centralized-change">Partially centralized change</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">The decision point</h3>

<pre class="sp">

</pre>

   <p>By making all changes through a single point of control and
verification, you avoid<a rel="footnote" href="#fn-3" name="fnd-3"><sup>3</sup></a> the
problem of multiple intentions, because all intentions will be
clear to see. CFEngine works with promises, because a promise
is simply the expression of an intention.

   <div class="block-image"><img src="arch.png" alt="The CFEngine architecture"></div>

   <p>If you work in a federated environment, then each distinct region of
policy can have its own policy server or hub. These will not conflict,
unless a host subscribes to updates from more than one hub.

<div class="node">
<a name="Promises-about-change-vs-state"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Promises-about-change">Promises about change</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-decision-point">The decision point</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Promises about change vs state</h3>

<pre class="sp">

</pre>

CFEngine works by keeping promises, so think about how promises
apply to change.

   <p>You could promise to <i>make</i> a change, but that is a very weak
promise because it would be kept by a single transitory event (the
moment at which the change is made) and then it would go away.  To
have control over your system at all times you need to make promises
about <i>state</i>, because state is something that persists for long
times, and thus the promise persists.

   <p>When we care about the state of a system, we make promises that describe
that state at all times, because we know that there might be other
forces for change that can bring about unintended states. If we intend the
state of the system to persist, we should promise that. 
Thinking always about periods of stable equilbrium will minimize issues
with non-compliance.

   <pre class="sp">

</pre>
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
To make a change of state, you should think about <i>changing the promises</i>
that describe your desired state, not about <i>promising to make a change</i> of state. 
</td></tr></table>

   <pre class="sp">

</pre>

An analogy: think of change management as navigation though a sea of possible
states. If you promise changes, you promise to alter course relative
to your current state, e.g. turn left, turn right, alter heading by 10
degrees to starboard, etc. However, you are now vulnerable to things
you don't know about.  Winds and currents blow you off course and can
lead to unintended changes that invalidate these course corrections,
if you have not promised to monitor and avoid them. That is why
modern navigators use <i>beacons</i>.

   <p>In CFEngine, a beacon is a promise of desired end-state (the end of
your journey). It's the place you want to be &ndash; and the journey
doesn't interest you.  Navigators used fixed stars, lighthouses and
now artificial radio signals to guide ships and planes on their
intended course at all times, because beacons promise absolute desired
location, not relative instructions to get there. CFEngine uses
promises in the same way, to guide systems to their desired outcomes,
not merely a script of relative corrections. So CFEngine works somewhat like a
system auto-pilot.

<div class="node">
<a name="Promises-about-change"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Change-management-and-knowledge-management">Change management and knowledge management</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Promises-about-change-vs-state">Promises about change vs state</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Promises about change</h3>

<pre class="sp">

</pre>

To help you think of change in terms of promises, consider the following
promises made during change management, with CFEngine examples.
     <dl>
<dt><i>You promise a desired state for your system (beacon).</i><dd>
<pre class="verbatim">     packages:
     
         "apache"
     
<span class="red">              comment </span>=><span class="green"> "Ensure Apache webserver installed",</span>
<span class="red">              package_policy </span>=><span class="green"> "add",</span>
<span class="red">              package_method </span>=><span class="blue"> yum;</span>
       
<span class="red">     processes:
</span>     
         "apache"
     
<span class="red">              comment </span>=><span class="green"> "Ensure apache webserver running",</span>
<span class="red">              restart_class </span>=><span class="blue"> restart_apache;</span>
     
</pre>

     <br><dt><i>You change a promise you have made about state to promise a new desired state.</i><dd>
You edit <samp><span class="file">promises.cf</span></samp> and track the changes using a change management repository
like Subversion or CVS.

     <br><dt><i>A third party promises a change and we promise to accept that change.</i><dd>
<pre class="verbatim">     packages:
     
         "apache"
     
<span class="red">              comment </span>=><span class="green"> "Ensure Apache webserver up to date",</span>
<span class="red">              package_policy </span>=><span class="green"> "update",</span>
<span class="red">              package_method </span>=><span class="blue"> yum;</span>
     
</pre>

     <br><dt><i>We promise to monitor unintended changes.</i><dd>
<pre class="verbatim">     
<span class="red">     files:
</span>     
       "/usr" -> "Security team"
     
<span class="red">            changes      </span>=><span class="blue"> detect_all_change,</span>
<span class="red">            depth_search </span>=><span class="blue"> recurse("inf");</span>
     
</pre>

     <br><dt><i>We promise two conflicting outcomes (a validation error to be corrected).</i><dd>
Conflicts of intention are easy to see when they are mediated by CFEngine. 
<pre class="verbatim">     
<span class="red">     files:
</span>     
       "/etc/passwd" -> "Security team"
<span class="red">               perms </span>=><span class="blue"> owner("root");</span>
     
       "/etc/passwd" -> "Security team"
<span class="red">               perms </span>=><span class="blue"> owner("mark");</span>
     
</pre>

   </dl>

   <p>Perhaps you can think of more promises for your own organization. CFEngine encourages
promise thinking because it promotes stable expectations about the system. Let us
underline what traditional approaches ignore about change management:

   <pre class="sp">

</pre>
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
If you have made no promise about your system state, you should not be
surprised by anything that happens there. You cannot assume that no
change will happen. 
</td></tr></table>

   <pre class="sp">

</pre>

<div class="node">
<a name="Change-management-and-knowledge-management"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Non_002ddestructive-change">Non-destructive change</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Promises-about-change">Promises about change</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Change management and knowledge management</h3>

<pre class="sp">

</pre>

The decision to manage change is an economic trade-off. The more
promises we make about state, the higher the cost of keeping them. You
have to decide how much you are willing to spend on navigating change.

   <p>CFEngine makes desired state cheap, but the true cost of change
management is not implementation but the cost of <i>changing
knowledge</i>, i.e. losing track of your place within your intentions. If
your system behaviour is dominated by changing external currents that
you ignore, you will constantly be fighting to steer reactively.

   <p>Knowledge Management is necessary to maintain a guidance system that
makes course programming reliable and effective. CFEngine allows you
to document all of your intentions as promises to be kept.  CFEngine
Nova additionally provides a continuously updated knowledge map as
part of its `auto-pilot navigation' facilities, based on what we
promise and what it discovers about the environment impacting on
systems. Hence, it tracks both promised state, and unintended changes.

   <p>Lack of knowledge about your system is the cause of unexpected
side-effects and unpleasant surprises. The key to predictability in
system operations is CFEngine's core principle of <i>convergence</i>. 
CFEngine Missions Specialists always think <i>convergence</i>.

<div class="node">
<a name="Non-destructive-change"></a>
<a name="Non_002ddestructive-change"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Change-and-convergence">Change and convergence</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Change-management-and-knowledge-management">Change management and knowledge management</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Non-destructive change</h3>

<pre class="sp">

</pre>

The IT industry, for the most part, has not really progressed beyond
the idea of baselining systems. In the traditional conception of
change management you start by baselining, i.e. establishing a known
starting configuration. Then you generally assume that you are the
only source of change. If something goes wrong you do not try to
repair the fault, but merely start again, destroying and rebuilding.

   <p>In fact, all kinds of things change beyond our control all the
time. Bugs emerge, items are stolen, things get broken by accident and
external circumstances conspire to confound the order we would like to
preserve. The suggestion that only authorized people actually make
changes is simply wrong.

   <pre class="sp">

</pre>
<div align="center"><img src="demolish.png" alt="Rollback"></div>
<pre class="sp">

</pre>

In reality, circumstances are part of the picture, as well as changing
inventory and releases.  CFEngine uses the idea of &ldquo;convergence&rdquo;
(see figure below) to ensure desired state, independently of where you
start from. In this way of thinking, the configuration details might
be changing in a quite unpredictable way, and it is our job to
continuously monitor and repair this general dilapidation. Rather than
assuming a constant state in between changes, CFEngine assumes a
constant &ldquo;ideal state&rdquo; or <em>goal</em> to be achieved at all
times.

<div class="node">
<a name="Change-and-convergence"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-change-decision-process-or-release-management">The change decision process or release management</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Non_002ddestructive-change">Non-destructive change</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Change and convergence</h3>

<pre class="sp">

</pre>

Change requires action, and implementation is the most dangerous part
of change, as it leads to consquences that a difficult to predict, especially
if you have incomplete knowledge of your environment.

   <p>Reliabilty and dependability on promises requires you to think about
the convergence of all change operations. Many change procedures fail
because they are built in a highly fragile manner (left hand figure):
you require exact knowledge of where you start from, and you have a recipe
that (if applied once and only once) will take you to the desired end state.

   <pre class="sp">

</pre>
<div align="center"><img src="convergence.png" alt="Rollback"></div>
<pre class="sp">

</pre>
Such a procedure cannot maintain the desired state, without
demolishing it and rebuilding it from scratch. 
With CFEngine you focus on the end state (right hand figure), not
where you start from.  Every change, action or recipe may be
repeated a infinite number of times<a rel="footnote" href="#fn-4" name="fnd-4"><sup>4</sup></a> without adverse consquences,
because every action will only bring you to the desired state, no matter
where you start from.

<div class="node">
<a name="The-change-decision-process-or-release-management"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Deploying-policy-changes">Deploying policy changes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Change-and-convergence">Change and convergence</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">The change decision process or release management</h3>

<pre class="sp">

</pre>

The process of managing intended changes is often called <i>release
management</i>.  A <em>release</em> is a collection of authorized changes
to the promises of desired state for a system.

   <p>A release is traditionally a larger umbrella under which many smaller
changes are made. Changes are assembled into <em>releases</em> and then
they are `rolled out'.

   <pre class="sp">

</pre>
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
At CFEngine we encourage many small, incremental changes above
large risky changes, as every change has unexpected consequences,
and small changes minimize risk. (See the Special Topics Guide
on BDMA.) 
</td></tr></table>

   <pre class="sp">

</pre>

Release management is about the
designing, testing and scheduling the release, i.e. everything to do with
the release process except the explicit implementation of it.

   <p>New releases are usually made in response to the occurrence of
unintended changes, called <em>incidents</em> (incident management). An
incident is an event that leads to unintended behaviour. The root
cause of many incidents is often called a <em>problem</em> (problem
management).  One goal of CFEngine is to plan pro-actively to handle
incidents automatically, thus taking them off the list of things to
worry about.  Changes can introduce new incidents, so it is important
to test changes to promises in advance.

     <ol type=1 start=1>
<li>Formulate proposed intentions in the form of promises. 
<li>Discuss the impact of these in your team of CFEngine Mission Specialists (more than one pair of eyes). 
<li>Construct a test environment and examine the effect of these promises in practice. 
<li>Commit the changes to promises in version control, e.g. subversion. 
<li>Deploy promises changes into live environment on a small number of machines. 
<li>Finally deploy to all machines.
        </ol>
At each stage, we make careful, low-risk incursions on the system and
see how it responds. Note that some side-effects could take days to
emerge, so the schedule for change should account for the expected impact.

<div class="node">
<a name="Deploying-policy-changes"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-change-decision-process-or-release-management">The change decision process or release management</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Deploying policy changes</h3>

<pre class="sp">

</pre>

The following sequence forms a checklist for deploying successful policy change:
     <ol type=1 start=1>
<li>Discuss the impact of changes in the team. 
<li>Construct a test environment and examine the effect of these promises in practice. 
<li>Make a change in the CFEngine input files. 
<li>Run the configuration through &lsquo;<samp><span class="samp">cf-promises --inform</span></samp>&rsquo; to check for problems. 
<li>Commit the tested changes to promises in version control, e.g. subversion. 
<li>Move the policy to a test system. 
<li>Try running the configuration in dry-run model: &lsquo;<samp><span class="samp">cf-agent --dry-run</span></samp>&rsquo;
<li>Try running the policy once on a single system, being observant of unexpected behaviour. 
<li>Try running the policy on a small number of systems. 
<li>Move the policy to the production environment. 
<li>If possible, test on one or a few machines before releasing for general use.
        </ol>

<p class="noindent">Be aware of the differences in your environment. A decision will not necessarily work everywhere
in the same way.

   <p><a name="Contents">
   <div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">Change Management</a>
<ul>
<li><a href="#What-is-change-management_003f">What is change management?</a>
<li><a href="#Regulation-_002d-authorized-and-unauthorized-change">Regulation: authorized and unauthorized change</a>
<li><a href="#Intended-and-unintended-change">Intended and unintended change</a>
<li><a href="#How-fast-should-changes-be-made_003f">How fast should changes be made?</a>
<li><a href="#Partially-centralized-change">Partially centralized change</a>
<li><a href="#The-decision-point">The decision point</a>
<li><a href="#Promises-about-change-vs-state">Promises about change vs state</a>
<li><a href="#Promises-about-change">Promises about change</a>
<li><a href="#Change-management-and-knowledge-management">Change management and knowledge management</a>
<li><a href="#Non_002ddestructive-change">Non-destructive change</a>
<li><a href="#Change-and-convergence">Change and convergence</a>
<li><a href="#The-change-decision-process-or-release-management">The change decision process or release management</a>
<li><a href="#Deploying-policy-changes">Deploying policy changes</a>
</li></ul>
</li></ul>
</div>



   <p><script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://
ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-
analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2576171-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

   <div class="footnote">
<hr>
<a name="texinfo-footnotes-in-document"></a><h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> For example, suppose a
process runs out of control and starts filling up logs with error
messages &ndash; the disk might fill up and cause a much more serious
problem, such as a total system failure with crash, is this were left unattended.</p>

   <p class="footnote"><small>[<a name="fn-2" href="#fnd-2">2</a>]</small> Nyquist's
theorem is the main reason why CD-players sample at 44kHz in order to cover the
audible spectrum of 22kHz for most young people. Even though hearing deteriorates
with age, and most people cannot hear this well, it provides a quality margin.</p>

   <p class="footnote"><small>[<a name="fn-3" href="#fnd-3">3</a>]</small> Promise theory tells us that
coordination requires mutual agreement between all agents that work in
a coordinated way on common resources. Every decision necessarily
comes from a single point of origin (but there could be many of these,
making non-overlapping decisions); consistency only starts to go
wrong when intentions about common resources conflict.</p>

   <p class="footnote"><small>[<a name="fn-4" href="#fnd-4">4</a>]</small> Some writers like to call this
property idempotence.</p>

   <hr></div>

</body></html>


