bundle knowledge CfengineSiteConfiguration
{

topics:
references::
  "bundle reference";
  "used in promise";
  "has current exemplars";
  "is a promise of type";
  "occurs in bundle";
  "bundle contains promiser";
  "makes promise of type";
  "promises have been made by";
  "makes promises";
  "is a promise made by";
system_reports::
  "audit report";
  "all_locks report";
  "active_locks report";
  "classes report";
  "compliance report";
  "file_changes report";
  "hashes report";
  "installed software report";
  "lastseen report";
  "monitor now report";
  "monitor history report";
  "monitor summary report";
  "performance report";
  "setuid report";
  "software patches report";
  "variables report";
  # New assocs
  "classes report"
    association => a("is generated with","promise_types::classes","reported in");
  "lastseen report"
   association => a("is affected by","body_constraints::copy_from","reported in");
  "lastseen report"
   association => a("is affected by","promise_types::access","reported in");
  "compliance report"
    association => a("is based on","promises","reported in");
  "performance report"
    association => a("is based on","promises","reported in");
  "setuid report"
    association => a("is generated with","promise_types::files","reported in");
  "hashes report"
    association => a("is generated with","promise_types::files","reported in");
  "hashes report"
    association => a("is generated with","body_constraints::changes","reported in");
  "file_changes report"
    association => a("is generated with","promise_types::files","reported in");
  "file_changes report"
    association => a("is generated with","body_constraints::changes","reported in");
  "installed software report"
    association => a("is generated with","promise_types::packages","reported in");
  "software patches report"
    association => a("is generated with","promise_types::packages","reported in");
system_policy::
  "bundles" comment => "A modular collection of promises of different types";
  "bodies" comment => "A modular collection of body constraints for re-use";
  "contexts" comment => "Class expressions that say where or when a promise applies";
  "promisees" comment => "Recipients of a promise, i.e. promise handles, or persons";
  "promisers" comment => "The objects affected by a promise";
  "promises" comment => "Complete occurrences of promiser + promisee + promise-body";
  "promise types" comment => "The types of promise that cfengine can keep";
  "body constraints" comment => "The attributes that cfengine enables you to promise about the promiser";
"comments"
      association => a("see instances of","comment","is one of a number of");
"functions" comment => "In-built functions that may be used to set variables or classes"; "values"  comment => "Formal rvalues in constraint assignments and their legal ranges";
values::

"system signals"   comment =>"Should match the generic pattern hup,int,trap,kill,pipe,cont,abrt,stop,quit,term,child,usr1,usr2,bus,segv, i.e. a unix signal name";
"boolean"   comment =>"Should match the generic pattern true,false,yes,no,on,off, i.e. a positive or a negative";
"link type"   comment =>"Should match the generic pattern symlink,hardlink,relative,absolute,none, i.e. a support link type";
"a time range"   comment =>"Should match the generic pattern 0,2147483648, i.e. a value from zero to a maximum system time -- but you should use time functions to convert this";
"a positive integer"   comment =>"Should match the generic pattern 0,99999999999, i.e. a number between zero and the maximum value";
"integer"   comment =>"Should match the generic pattern -99999999999,9999999999, i.e. a number between the minus and positive maximum values";
"real number"   comment =>"Should match the generic pattern -9.99999E100,9.99999E100, i.e. a number between the minus and positive maximum values";
"a single character"   comment =>"Should match the generic pattern ^.$, i.e. one symbol";
"posix file mode or permission"   comment =>"Should match the generic pattern [0-7augorwxst,+-]+, i.e. something that you would give as an argument to chmod";
"a cfengine class expression"   comment =>"Should match the generic pattern [a-zA-Z0-9_!&|.()]+, i.e. an alphanumeric string with option underscores and logical operators";
"a cfengine identifier"   comment =>"Should match the generic pattern [a-zA-Z0-9_$.]+, i.e. an alphanumeric string with option underscores";
"a user/group id"   comment =>"Should match the generic pattern [a-zA-Z0-9_$.-]+, i.e. an alphanumeric string with option underscores and hyphens";
"a file path"   comment =>"Should match the generic pattern [cC]:\\.*|/.*, i.e. a system file path suitable for the target system";
"a syslog level"   comment =>"Should match the generic pattern LOG_USER,LOG_DAEMON,LOG_LOCAL0,LOG_LOCAL1,LOG_LOCAL2,LOG_LOCAL3,LOG_LOCAL4,LOG_LOCAL5,LOG_LOCAL6,LOG_LOCAL7, i.e. a syslog constant";
"An arbitrary string"   comment =>"Should match the generic pattern , i.e. unspecified characters";
"An arbitrary string"   comment =>"Should match the generic pattern .*, i.e. unspecified characters";
"boolean"   association => a("is a special case of","int","is the generic type for");
"a time range"   association => a("is a special case of","int","is the generic type for");
"a positive integer"   association => a("is a special case of","int","is the generic type for");
"integer"   association => a("is a special case of","int","is the generic type for");
"real number"   association => a("is a special case of","real","is the generic type for");
"a cfengine class expression"   association => a("is a special case of","class","is the generic type for");
"a cfengine identifier"   association => a("is a special case of","string","is the generic type for");
"a user/group id"   association => a("is a special case of","string","is the generic type for");
"a file path"   association => a("is a special case of","string","is the generic type for");
"a syslog level"   association => a("is a special case of","string","is the generic type for");
"An arbitrary string"   association => a("is a special case of","string","is the generic type for");
"An arbitrary string"   association => a("is a special case of","string","is the generic type for");
bundles::
"sys" comment => "cfengine's internal bundle of system specific values";
promise_types::
   "vars";
body_constraints::
   "string"
   comment => "A scalar string",
   association => a("is a possible body constraint for","promise_types::vars","can have body constraints");
body_constraints::
   "string" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "A scalar string";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","string","takes value");
promise_types::
   "vars";
body_constraints::
   "int"
   comment => "A scalar integer",
   association => a("is a possible body constraint for","promise_types::vars","can have body constraints");
body_constraints::
   "int" association => a("is a body constraint of type","integer","has possible body constraints"),
          comment => "A scalar integer";
values::

 "integer" comment => "Represent type int and should match -99999999999,9999999999",
    association => a("are used in constraint parameters","int","takes value");
promise_types::
   "vars";
body_constraints::
   "real"
   comment => "A scalar real number",
   association => a("is a possible body constraint for","promise_types::vars","can have body constraints");
body_constraints::
   "real" association => a("is a body constraint of type","real number","has possible body constraints"),
          comment => "A scalar real number";
values::

 "real number" comment => "Represent type real and should match -9.99999E100,9.99999E100",
    association => a("are used in constraint parameters","real","takes value");
promise_types::
   "vars";
body_constraints::
   "slist"
   comment => "A list of scalar strings",
   association => a("is a possible body constraint for","promise_types::vars","can have body constraints");
body_constraints::
   "slist" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "A list of scalar strings";
   "slist" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","slist","takes value");
promise_types::
   "vars";
body_constraints::
   "ilist"
   comment => "A list of integers",
   association => a("is a possible body constraint for","promise_types::vars","can have body constraints");
body_constraints::
   "ilist" association => a("is a body constraint of type","integer","has possible body constraints"),
          comment => "A list of integers";
   "ilist" association => a("is a list of type","integer","is used in");
values::

 "integer" comment => "Represent type ilist and should match -99999999999,9999999999",
    association => a("are used in constraint parameters","ilist","takes value");
promise_types::
   "vars";
body_constraints::
   "rlist"
   comment => "A list of real numbers",
   association => a("is a possible body constraint for","promise_types::vars","can have body constraints");
body_constraints::
   "rlist" association => a("is a body constraint of type","real number","has possible body constraints"),
          comment => "A list of real numbers";
   "rlist" association => a("is a list of type","real number","is used in");
values::

 "real number" comment => "Represent type rlist and should match -9.99999E100,9.99999E100",
    association => a("are used in constraint parameters","rlist","takes value");
promise_types::
   "vars";
body_constraints::
   "policy"
   comment => "The policy for (dis)allowing redefinition of variables",
   association => a("is a possible body constraint for","promise_types::vars","can have body constraints");
body_constraints::
   "policy" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "The policy for (dis)allowing redefinition of variables";
promise_types::
   "classes";
body_constraints::
   "or"
   comment => "Combine class sources with inclusive OR",
   association => a("is a possible body constraint for","promise_types::classes","can have body constraints");
body_constraints::
   "or" association => a("is a body constraint of type","clist","has possible body constraints"),
          comment => "Combine class sources with inclusive OR";
promise_types::
   "classes";
body_constraints::
   "and"
   comment => "Combine class sources with AND",
   association => a("is a possible body constraint for","promise_types::classes","can have body constraints");
body_constraints::
   "and" association => a("is a body constraint of type","clist","has possible body constraints"),
          comment => "Combine class sources with AND";
promise_types::
   "classes";
body_constraints::
   "xor"
   comment => "Combine class sources with XOR",
   association => a("is a possible body constraint for","promise_types::classes","can have body constraints");
body_constraints::
   "xor" association => a("is a body constraint of type","clist","has possible body constraints"),
          comment => "Combine class sources with XOR";
promise_types::
   "classes";
body_constraints::
   "dist"
   comment => "Generate a probabilistic class distribution (strategy in cfengine 2)",
   association => a("is a possible body constraint for","promise_types::classes","can have body constraints");
body_constraints::
   "dist" association => a("is a body constraint of type","real number","has possible body constraints"),
          comment => "Generate a probabilistic class distribution (strategy in cfengine 2)";
   "dist" association => a("is a list of type","real number","is used in");
values::

 "real number" comment => "Represent type rlist and should match -9.99999E100,9.99999E100",
    association => a("are used in constraint parameters","dist","takes value");
promise_types::
   "classes";
body_constraints::
   "expression"
   comment => "Evaluate string expression of classes in normal form",
   association => a("is a possible body constraint for","promise_types::classes","can have body constraints");
body_constraints::
   "expression" association => a("is a body constraint of type","class","has possible body constraints"),
          comment => "Evaluate string expression of classes in normal form";
promise_types::
   "classes";
body_constraints::
   "not"
   comment => "Evaluate the negation of string expression in normal form",
   association => a("is a possible body constraint for","promise_types::classes","can have body constraints");
body_constraints::
   "not" association => a("is a body constraint of type","class","has possible body constraints"),
          comment => "Evaluate the negation of string expression in normal form";
promise_types::
   "reports";
body_constraints::
   "lastseen"
   comment => "Integer time threshold in hours since current peers were last seen, report absence",
   association => a("is a possible body constraint for","promise_types::reports","can have body constraints");
body_constraints::
   "lastseen" association => a("is a body constraint of type","a positive integer","has possible body constraints"),
          comment => "Integer time threshold in hours since current peers were last seen, report absence";
values::

 "a positive integer" comment => "Represent type int and should match 0,99999999999",
    association => a("are used in constraint parameters","lastseen","takes value");
promise_types::
   "reports";
body_constraints::
   "intermittency"
   comment => "Real number threshold [0,1] of intermittency about current peers, report above",
   association => a("is a possible body constraint for","promise_types::reports","can have body constraints");
body_constraints::
   "intermittency" association => a("is a body constraint of type","real","has possible body constraints"),
          comment => "Real number threshold [0,1] of intermittency about current peers, report above";
promise_types::
   "reports";
body_constraints::
   "showstate"
   comment => "List of services about which status reports should be reported to standard output",
   association => a("is a possible body constraint for","promise_types::reports","can have body constraints");
body_constraints::
   "showstate" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "List of services about which status reports should be reported to standard output";
   "showstate" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","showstate","takes value");
promise_types::
   "reports";
body_constraints::
   "printfile"
   comment => "Quote part of a file to standard output",
   association => a("is a possible body constraint for","promise_types::reports","can have body constraints");
   "number_of_lines"
   comment => "Integer maximum number of lines to print from selected file",
   association => a("is a possible sub-body constraint for","printfile","may have sub-body constraints");
body_constraints::
   "number_of_lines" association => a("is a body constraint of type","a positive integer","has possible body constraints"),
          comment => "Integer maximum number of lines to print from selected file";
values::

 "a positive integer" comment => "Represent type int and should match 0,99999999999",
    association => a("are used in constraint parameters","number_of_lines","takes value");
   "file_to_print"
   comment => "Path name to the file that is to be sent to standard output",
   association => a("is a possible sub-body constraint for","printfile","may have sub-body constraints");
body_constraints::
   "file_to_print" association => a("is a body constraint of type","a file path","has possible body constraints"),
          comment => "Path name to the file that is to be sent to standard output";
values::

 "a file path" comment => "Represent type string and should match [cC]:\\.*|/.*",
    association => a("are used in constraint parameters","file_to_print","takes value");
promise_types::
   "reports";
body_constraints::
   "friend_pattern"
   comment => "Regular expression to keep selected hosts from the friends report list",
   association => a("is a possible body constraint for","promise_types::reports","can have body constraints");
body_constraints::
   "friend_pattern" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Regular expression to keep selected hosts from the friends report list";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","friend_pattern","takes value");
promise_types::
   "reports";
body_constraints::
   "report_to_file"
   comment => "The path and filename to which output should be appended",
   association => a("is a possible body constraint for","promise_types::reports","can have body constraints");
body_constraints::
   "report_to_file" association => a("is a body constraint of type","a file path","has possible body constraints"),
          comment => "The path and filename to which output should be appended";
values::

 "a file path" comment => "Represent type string and should match [cC]:\\.*|/.*",
    association => a("are used in constraint parameters","report_to_file","takes value");
promise_types::
   "*";
body_constraints::
   "action"
   comment => "Output behaviour",
   association => a("is a possible body constraint for","promise_types::*","can have body constraints");
   "action_policy"
   comment => "Whether to repair or report about non-kept promises",
   association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
body_constraints::
   "action_policy" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Whether to repair or report about non-kept promises";
   "ifelapsed"
   comment => "Number of minutes before next allowed assessment of promise",
   association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
body_constraints::
   "ifelapsed" association => a("is a body constraint of type","a positive integer","has possible body constraints"),
          comment => "Number of minutes before next allowed assessment of promise";
values::

 "a positive integer" comment => "Represent type int and should match 0,99999999999",
    association => a("are used in constraint parameters","ifelapsed","takes value");
   "expireafter"
   comment => "Number of minutes before a repair action is interrupted and retried",
   association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
body_constraints::
   "expireafter" association => a("is a body constraint of type","a positive integer","has possible body constraints"),
          comment => "Number of minutes before a repair action is interrupted and retried";
values::

 "a positive integer" comment => "Represent type int and should match 0,99999999999",
    association => a("are used in constraint parameters","expireafter","takes value");
   "log_string"
   comment => "A message to be written to the log when a promise verification leads to a repair",
   association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
body_constraints::
   "log_string" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "A message to be written to the log when a promise verification leads to a repair";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","log_string","takes value");
   "log_level"
   comment => "The reporting level sent to syslog",
   association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
body_constraints::
   "log_level" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "The reporting level sent to syslog";
   "log_kept"
   comment => "This should be filename of a file to which log_string will be saved, if undefined it goes to syslog",
   association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
body_constraints::
   "log_kept" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "This should be filename of a file to which log_string will be saved, if undefined it goes to syslog";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","log_kept","takes value");
   "log_repaired"
   comment => "This should be filename of a file to which log_string will be saved, if undefined it goes to syslog",
   association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
body_constraints::
   "log_repaired" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "This should be filename of a file to which log_string will be saved, if undefined it goes to syslog";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","log_repaired","takes value");
   "log_failed"
   comment => "This should be filename of a file to which log_string will be saved, if undefined it goes to syslog",
   association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
body_constraints::
   "log_failed" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "This should be filename of a file to which log_string will be saved, if undefined it goes to syslog";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","log_failed","takes value");
   "audit"
   comment => "true/false switch for detailed audit records of this promise",
   association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
body_constraints::
   "audit" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false switch for detailed audit records of this promise";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","audit","takes value");
   "background"
   comment => "true/false switch for parallelizing the promise repair",
   association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
body_constraints::
   "background" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false switch for parallelizing the promise repair";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","background","takes value");
   "report_level"
   comment => "The reporting level for standard output",
   association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
body_constraints::
   "report_level" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "The reporting level for standard output";
   "measurement_class"
   comment => "If set performance will be measured and recorded under this identifier",
   association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
body_constraints::
   "measurement_class" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "If set performance will be measured and recorded under this identifier";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","measurement_class","takes value");
promise_types::
   "*";
body_constraints::
   "classes"
   comment => "Signalling behaviour",
   association => a("is a possible body constraint for","promise_types::*","can have body constraints");
   "promise_repaired"
   comment => "A list of classes to be defined",
   association => a("is a possible sub-body constraint for","classes","may have sub-body constraints");
body_constraints::
   "promise_repaired" association => a("is a body constraint of type","a cfengine identifier","has possible body constraints"),
          comment => "A list of classes to be defined";
   "promise_repaired" association => a("is a list of type","a cfengine identifier","is used in");
values::

 "a cfengine identifier" comment => "Represent type slist and should match [a-zA-Z0-9_$.]+",
    association => a("are used in constraint parameters","promise_repaired","takes value");
   "repair_failed"
   comment => "A list of classes to be defined",
   association => a("is a possible sub-body constraint for","classes","may have sub-body constraints");
body_constraints::
   "repair_failed" association => a("is a body constraint of type","a cfengine identifier","has possible body constraints"),
          comment => "A list of classes to be defined";
   "repair_failed" association => a("is a list of type","a cfengine identifier","is used in");
values::

 "a cfengine identifier" comment => "Represent type slist and should match [a-zA-Z0-9_$.]+",
    association => a("are used in constraint parameters","repair_failed","takes value");
   "repair_denied"
   comment => "A list of classes to be defined",
   association => a("is a possible sub-body constraint for","classes","may have sub-body constraints");
body_constraints::
   "repair_denied" association => a("is a body constraint of type","a cfengine identifier","has possible body constraints"),
          comment => "A list of classes to be defined";
   "repair_denied" association => a("is a list of type","a cfengine identifier","is used in");
values::

 "a cfengine identifier" comment => "Represent type slist and should match [a-zA-Z0-9_$.]+",
    association => a("are used in constraint parameters","repair_denied","takes value");
   "repair_timeout"
   comment => "A list of classes to be defined",
   association => a("is a possible sub-body constraint for","classes","may have sub-body constraints");
body_constraints::
   "repair_timeout" association => a("is a body constraint of type","a cfengine identifier","has possible body constraints"),
          comment => "A list of classes to be defined";
   "repair_timeout" association => a("is a list of type","a cfengine identifier","is used in");
values::

 "a cfengine identifier" comment => "Represent type slist and should match [a-zA-Z0-9_$.]+",
    association => a("are used in constraint parameters","repair_timeout","takes value");
   "promise_kept"
   comment => "A list of classes to be defined",
   association => a("is a possible sub-body constraint for","classes","may have sub-body constraints");
body_constraints::
   "promise_kept" association => a("is a body constraint of type","a cfengine identifier","has possible body constraints"),
          comment => "A list of classes to be defined";
   "promise_kept" association => a("is a list of type","a cfengine identifier","is used in");
values::

 "a cfengine identifier" comment => "Represent type slist and should match [a-zA-Z0-9_$.]+",
    association => a("are used in constraint parameters","promise_kept","takes value");
   "persist_time"
   comment => "A number of minutes the specified classes should remain active",
   association => a("is a possible sub-body constraint for","classes","may have sub-body constraints");
body_constraints::
   "persist_time" association => a("is a body constraint of type","a positive integer","has possible body constraints"),
          comment => "A number of minutes the specified classes should remain active";
values::

 "a positive integer" comment => "Represent type int and should match 0,99999999999",
    association => a("are used in constraint parameters","persist_time","takes value");
   "timer_policy"
   comment => "Whether a persistent class restarts its counter when rediscovered",
   association => a("is a possible sub-body constraint for","classes","may have sub-body constraints");
body_constraints::
   "timer_policy" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Whether a persistent class restarts its counter when rediscovered";
promise_types::
   "*";
body_constraints::
   "ifvarclass"
   comment => "Extended classes ANDed with context",
   association => a("is a possible body constraint for","promise_types::*","can have body constraints");
body_constraints::
   "ifvarclass" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Extended classes ANDed with context";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","ifvarclass","takes value");
promise_types::
   "*";
body_constraints::
   "handle"
   comment => "A unique id-tag string for referring to this as a promisee elsewhere",
   association => a("is a possible body constraint for","promise_types::*","can have body constraints");
body_constraints::
   "handle" association => a("is a body constraint of type","a cfengine identifier","has possible body constraints"),
          comment => "A unique id-tag string for referring to this as a promisee elsewhere";
values::

 "a cfengine identifier" comment => "Represent type string and should match [a-zA-Z0-9_$.]+",
    association => a("are used in constraint parameters","handle","takes value");
promise_types::
   "*";
body_constraints::
   "depends_on"
   comment => "A list of promise handles that this promise builds on or depends on somehow (for knowledge management)",
   association => a("is a possible body constraint for","promise_types::*","can have body constraints");
body_constraints::
   "depends_on" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "A list of promise handles that this promise builds on or depends on somehow (for knowledge management)";
   "depends_on" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","depends_on","takes value");
promise_types::
   "*";
body_constraints::
   "comment"
   comment => "A comment about this promise's real intention that follows through the program",
   association => a("is a possible body constraint for","promise_types::*","can have body constraints");
body_constraints::
   "comment" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "A comment about this promise's real intention that follows through the program";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","comment","takes value");
promise_types::
   "*";
body_constraints::
   "select_region"
   comment => "Limit edits to a demarked region of the file",
   association => a("is a possible body constraint for","promise_types::*","can have body constraints");
   "select_start"
   comment => "Regular expression matching start of edit region",
   association => a("is a possible sub-body constraint for","select_region","may have sub-body constraints");
body_constraints::
   "select_start" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Regular expression matching start of edit region";
values::

 "An arbitrary string" comment => "Represent type string and should match .*",
    association => a("are used in constraint parameters","select_start","takes value");
   "select_end"
   comment => "Regular expression matches end of edit region from start",
   association => a("is a possible sub-body constraint for","select_region","may have sub-body constraints");
body_constraints::
   "select_end" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Regular expression matches end of edit region from start";
values::

 "An arbitrary string" comment => "Represent type string and should match .*",
    association => a("are used in constraint parameters","select_end","takes value");
promise_types::
   "commands";
body_constraints::
   "args"
   comment => "Alternative string of arguments for the command (concatenated with promiser string)",
   association => a("is a possible body constraint for","promise_types::commands","can have body constraints");
body_constraints::
   "args" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Alternative string of arguments for the command (concatenated with promiser string)";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","args","takes value");
promise_types::
   "commands";
body_constraints::
   "contain"
   comment => "Containment options for the execution process",
   association => a("is a possible body constraint for","promise_types::commands","can have body constraints");
   "useshell"
   comment => "true/false embed the command in a shell environment (true)",
   association => a("is a possible sub-body constraint for","contain","may have sub-body constraints");
body_constraints::
   "useshell" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false embed the command in a shell environment (true)";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","useshell","takes value");
   "umask"
   comment => "The umask value for the child process",
   association => a("is a possible sub-body constraint for","contain","may have sub-body constraints");
body_constraints::
   "umask" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "The umask value for the child process";
   "exec_owner"
   comment => "The user name or id under which to run the process",
   association => a("is a possible sub-body constraint for","contain","may have sub-body constraints");
body_constraints::
   "exec_owner" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "The user name or id under which to run the process";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","exec_owner","takes value");
   "exec_group"
   comment => "The group name or id under which to run the process",
   association => a("is a possible sub-body constraint for","contain","may have sub-body constraints");
body_constraints::
   "exec_group" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "The group name or id under which to run the process";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","exec_group","takes value");
   "exec_timeout"
   comment => "Timeout in seconds for command completion",
   association => a("is a possible sub-body constraint for","contain","may have sub-body constraints");
body_constraints::
   "exec_timeout" association => a("is a body constraint of type","int","has possible body constraints"),
          comment => "Timeout in seconds for command completion";
   "chdir"
   comment => "Directory for setting current/base directory for the process",
   association => a("is a possible sub-body constraint for","contain","may have sub-body constraints");
body_constraints::
   "chdir" association => a("is a body constraint of type","a file path","has possible body constraints"),
          comment => "Directory for setting current/base directory for the process";
values::

 "a file path" comment => "Represent type string and should match [cC]:\\.*|/.*",
    association => a("are used in constraint parameters","chdir","takes value");
   "chroot"
   comment => "Directory of root sandbox for process",
   association => a("is a possible sub-body constraint for","contain","may have sub-body constraints");
body_constraints::
   "chroot" association => a("is a body constraint of type","a file path","has possible body constraints"),
          comment => "Directory of root sandbox for process";
values::

 "a file path" comment => "Represent type string and should match [cC]:\\.*|/.*",
    association => a("are used in constraint parameters","chroot","takes value");
   "preview"
   comment => "true/false preview command when running in dry-run mode (with -n)",
   association => a("is a possible sub-body constraint for","contain","may have sub-body constraints");
body_constraints::
   "preview" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false preview command when running in dry-run mode (with -n)";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","preview","takes value");
   "no_output"
   comment => "true/false discard all output from the command",
   association => a("is a possible sub-body constraint for","contain","may have sub-body constraints");
body_constraints::
   "no_output" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false discard all output from the command";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","no_output","takes value");
promise_types::
   "commands";
body_constraints::
   "module"
   comment => "true/false whether to expect the cfengine module protocol",
   association => a("is a possible body constraint for","promise_types::commands","can have body constraints");
body_constraints::
   "module" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false whether to expect the cfengine module protocol";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","module","takes value");
promise_types::
   "databases";
body_constraints::
   "database_server"
   comment => "Credentials for connecting to a local/remote database server",
   association => a("is a possible body constraint for","promise_types::databases","can have body constraints");
   "db_server_owner"
   comment => "User name for database connection",
   association => a("is a possible sub-body constraint for","database_server","may have sub-body constraints");
body_constraints::
   "db_server_owner" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "User name for database connection";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","db_server_owner","takes value");
   "db_server_password"
   comment => "Clear text password for database connection",
   association => a("is a possible sub-body constraint for","database_server","may have sub-body constraints");
body_constraints::
   "db_server_password" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Clear text password for database connection";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","db_server_password","takes value");
   "db_server_host"
   comment => "Hostname or address for connection to database, blank means localhost",
   association => a("is a possible sub-body constraint for","database_server","may have sub-body constraints");
body_constraints::
   "db_server_host" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Hostname or address for connection to database, blank means localhost";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","db_server_host","takes value");
   "db_server_type"
   comment => "The dialect of the database server",
   association => a("is a possible sub-body constraint for","database_server","may have sub-body constraints");
body_constraints::
   "db_server_type" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "The dialect of the database server";
   "db_server_connection_db"
   comment => "The name of an existing database to connect to in order to create/manage other databases",
   association => a("is a possible sub-body constraint for","database_server","may have sub-body constraints");
body_constraints::
   "db_server_connection_db" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "The name of an existing database to connect to in order to create/manage other databases";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","db_server_connection_db","takes value");
promise_types::
   "databases";
body_constraints::
   "database_type"
   comment => "The type of database that is to be manipulated",
   association => a("is a possible body constraint for","promise_types::databases","can have body constraints");
body_constraints::
   "database_type" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "The type of database that is to be manipulated";
promise_types::
   "databases";
body_constraints::
   "database_operation"
   comment => "The nature of the promise - to be or not to be",
   association => a("is a possible body constraint for","promise_types::databases","can have body constraints");
body_constraints::
   "database_operation" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "The nature of the promise - to be or not to be";
promise_types::
   "databases";
body_constraints::
   "database_columns"
   comment => "A list of column definitions to be promised by SQL databases",
   association => a("is a possible body constraint for","promise_types::databases","can have body constraints");
body_constraints::
   "database_columns" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "A list of column definitions to be promised by SQL databases";
   "database_columns" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match .*",
    association => a("are used in constraint parameters","database_columns","takes value");
promise_types::
   "databases";
body_constraints::
   "database_rows"
   comment => "An ordered list of row values to be promised by SQL databases",
   association => a("is a possible body constraint for","promise_types::databases","can have body constraints");
body_constraints::
   "database_rows" association => a("is a body constraint of type","slist","has possible body constraints"),
          comment => "An ordered list of row values to be promised by SQL databases";
   "database_rows" association => a("is a list of type","slist","is used in");
promise_types::
   "databases";
body_constraints::
   "registry_exclude"
   comment => "A list of regular expressions to ignore in key/value verification",
   association => a("is a possible body constraint for","promise_types::databases","can have body constraints");
body_constraints::
   "registry_exclude" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "A list of regular expressions to ignore in key/value verification";
   "registry_exclude" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","registry_exclude","takes value");
promise_types::
   "files";
body_constraints::
   "file_select"
   comment => "Choose which files select in a search",
   association => a("is a possible body constraint for","promise_types::files","can have body constraints");
   "leaf_name"
   comment => "List of regexes that match an acceptable name",
   association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
body_constraints::
   "leaf_name" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "List of regexes that match an acceptable name";
   "leaf_name" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","leaf_name","takes value");
   "path_name"
   comment => "List of pathnames to match acceptable target",
   association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
body_constraints::
   "path_name" association => a("is a body constraint of type","a file path","has possible body constraints"),
          comment => "List of pathnames to match acceptable target";
   "path_name" association => a("is a list of type","a file path","is used in");
values::

 "a file path" comment => "Represent type slist and should match [cC]:\\.*|/.*",
    association => a("are used in constraint parameters","path_name","takes value");
   "search_mode"
   comment => "A list of mode masks for acceptable file permissions",
   association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
body_constraints::
   "search_mode" association => a("is a body constraint of type","posix file mode or permission","has possible body constraints"),
          comment => "A list of mode masks for acceptable file permissions";
   "search_mode" association => a("is a list of type","posix file mode or permission","is used in");
values::

 "posix file mode or permission" comment => "Represent type slist and should match [0-7augorwxst,+-]+",
    association => a("are used in constraint parameters","search_mode","takes value");
   "search_size"
   comment => "Integer range of file sizes",
   association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
body_constraints::
   "search_size" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
          comment => "Integer range of file sizes";
   "search_owners"
   comment => "List of acceptable user names or ids for the file, or regexes to match",
   association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
body_constraints::
   "search_owners" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "List of acceptable user names or ids for the file, or regexes to match";
   "search_owners" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","search_owners","takes value");
   "search_groups"
   comment => "List of acceptable group names or ids for the file, or regexes to match",
   association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
body_constraints::
   "search_groups" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "List of acceptable group names or ids for the file, or regexes to match";
   "search_groups" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","search_groups","takes value");
   "search_bsdflags"
   comment => "String of flags for bsd file system flags expected set",
   association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
body_constraints::
   "search_bsdflags" association => a("is a body constraint of type","string","has possible body constraints"),
          comment => "String of flags for bsd file system flags expected set";
   "ctime"
   comment => "Range of change times (ctime) for acceptable files",
   association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
body_constraints::
   "ctime" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
          comment => "Range of change times (ctime) for acceptable files";
   "mtime"
   comment => "Range of modification times (mtime) for acceptable files",
   association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
body_constraints::
   "mtime" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
          comment => "Range of modification times (mtime) for acceptable files";
   "atime"
   comment => "Range of access times (atime) for acceptable files",
   association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
body_constraints::
   "atime" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
          comment => "Range of access times (atime) for acceptable files";
   "exec_regex"
   comment => "Matches file if this regular expression matches any full line returned by the command",
   association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
body_constraints::
   "exec_regex" association => a("is a body constraint of type","a file path","has possible body constraints"),
          comment => "Matches file if this regular expression matches any full line returned by the command";
values::

 "a file path" comment => "Represent type string and should match [cC]:\\.*|/.*",
    association => a("are used in constraint parameters","exec_regex","takes value");
   "exec_program"
   comment => "Execute this command on each file and match if the exit status is zero",
   association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
body_constraints::
   "exec_program" association => a("is a body constraint of type","a file path","has possible body constraints"),
          comment => "Execute this command on each file and match if the exit status is zero";
values::

 "a file path" comment => "Represent type string and should match [cC]:\\.*|/.*",
    association => a("are used in constraint parameters","exec_program","takes value");
   "file_types"
   comment => "List of acceptable file types from menu choices",
   association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
body_constraints::
   "file_types" association => a("is a body constraint of type","(option list)","has possible body constraints"),
          comment => "List of acceptable file types from menu choices";
   "issymlinkto"
   comment => "List of regular expressions to match file objects",
   association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
body_constraints::
   "issymlinkto" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "List of regular expressions to match file objects";
   "issymlinkto" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","issymlinkto","takes value");
   "file_result"
   comment => "Logical expression combining classes defined by file search criteria",
   association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
body_constraints::
   "file_result" association => a("is a body constraint of type","string","has possible body constraints"),
          comment => "Logical expression combining classes defined by file search criteria";
promise_types::
   "files";
body_constraints::
   "copy_from"
   comment => "Criteria for copying file from a source",
   association => a("is a possible body constraint for","promise_types::files","can have body constraints");
   "source"
   comment => "Reference source file from which to copy",
   association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
body_constraints::
   "source" association => a("is a body constraint of type","a file path","has possible body constraints"),
          comment => "Reference source file from which to copy";
values::

 "a file path" comment => "Represent type string and should match [cC]:\\.*|/.*",
    association => a("are used in constraint parameters","source","takes value");
   "servers"
   comment => "List of servers in order of preference from which to copy",
   association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
body_constraints::
   "servers" association => a("is a body constraint of type","slist","has possible body constraints"),
          comment => "List of servers in order of preference from which to copy";
   "servers" association => a("is a list of type","slist","is used in");
   "portnumber"
   comment => "Port number to connect to on server host",
   association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
body_constraints::
   "portnumber" association => a("is a body constraint of type","int","has possible body constraints"),
          comment => "Port number to connect to on server host";
   "copy_backup"
   comment => "Menu option policy for file backup/version control",
   association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
body_constraints::
   "copy_backup" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Menu option policy for file backup/version control";
   "stealth"
   comment => "true/false whether to preserve time stamps on copied file",
   association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
body_constraints::
   "stealth" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false whether to preserve time stamps on copied file";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","stealth","takes value");
   "preserve"
   comment => "true/false whether to preserve file permissions on copied file",
   association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
body_constraints::
   "preserve" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false whether to preserve file permissions on copied file";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","preserve","takes value");
   "linkcopy_patterns"
   comment => "List of patterns matching symbolic links that should be replaced with copies",
   association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
body_constraints::
   "linkcopy_patterns" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "List of patterns matching symbolic links that should be replaced with copies";
   "linkcopy_patterns" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","linkcopy_patterns","takes value");
   "copylink_patterns"
   comment => "List of patterns matching files that should be linked instead of copied",
   association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
body_constraints::
   "copylink_patterns" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "List of patterns matching files that should be linked instead of copied";
   "copylink_patterns" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","copylink_patterns","takes value");
   "compare"
   comment => "Menu option policy for comparing source and image file attributes",
   association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
body_constraints::
   "compare" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Menu option policy for comparing source and image file attributes";
   "link_type"
   comment => "Menu option for type of links to use when copying",
   association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
body_constraints::
   "link_type" association => a("is a body constraint of type","link type","has possible body constraints"),
          comment => "Menu option for type of links to use when copying";
values::

 "link type" comment => "Represent type (menu option) and should match symlink,hardlink,relative,absolute,none",
    association => a("are used in constraint parameters","link_type","takes value");
   "type_check"
   comment => "true/false compare file types before copying and require match",
   association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
body_constraints::
   "type_check" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false compare file types before copying and require match";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","type_check","takes value");
   "force_update"
   comment => "true/false force copy update always",
   association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
body_constraints::
   "force_update" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false force copy update always";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","force_update","takes value");
   "force_ipv4"
   comment => "true/false force use of ipv4 on ipv6 enabled network",
   association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
body_constraints::
   "force_ipv4" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false force use of ipv4 on ipv6 enabled network";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","force_ipv4","takes value");
   "copy_size"
   comment => "Integer range of file sizes that may be copied",
   association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
body_constraints::
   "copy_size" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
          comment => "Integer range of file sizes that may be copied";
   "trustkey"
   comment => "true/false trust public keys from remote server if previously unknown",
   association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
body_constraints::
   "trustkey" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false trust public keys from remote server if previously unknown";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","trustkey","takes value");
   "encrypt"
   comment => "true/false use encrypted data stream to connect to remote host",
   association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
body_constraints::
   "encrypt" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false use encrypted data stream to connect to remote host";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","encrypt","takes value");
   "verify"
   comment => "true/false verify transferred file by hashing after copy (resource penalty)",
   association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
body_constraints::
   "verify" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false verify transferred file by hashing after copy (resource penalty)";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","verify","takes value");
   "purge"
   comment => "true/false purge files on client that do not match files on server when depth_search",
   association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
body_constraints::
   "purge" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false purge files on client that do not match files on server when depth_search";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","purge","takes value");
   "check_root"
   comment => "true/false check permissions on the root directory when depth_search",
   association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
body_constraints::
   "check_root" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false check permissions on the root directory when depth_search";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","check_root","takes value");
   "findertype"
   comment => "Menu option for default finder type on MacOSX",
   association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
body_constraints::
   "findertype" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Menu option for default finder type on MacOSX";
promise_types::
   "files";
body_constraints::
   "link_from"
   comment => "Criteria for linking file from a source",
   association => a("is a possible body constraint for","promise_types::files","can have body constraints");
   "source"
   comment => "The source file to which the link should point",
   association => a("is a possible sub-body constraint for","link_from","may have sub-body constraints");
body_constraints::
   "source" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "The source file to which the link should point";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","source","takes value");
   "link_type"
   comment => "The type of link used to alias the file",
   association => a("is a possible sub-body constraint for","link_from","may have sub-body constraints");
body_constraints::
   "link_type" association => a("is a body constraint of type","link type","has possible body constraints"),
          comment => "The type of link used to alias the file";
values::

 "link type" comment => "Represent type (menu option) and should match symlink,hardlink,relative,absolute,none",
    association => a("are used in constraint parameters","link_type","takes value");
   "copy_patterns"
   comment => "A set of patterns that should be copied ansd synchronized instead of linked",
   association => a("is a possible sub-body constraint for","link_from","may have sub-body constraints");
body_constraints::
   "copy_patterns" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "A set of patterns that should be copied ansd synchronized instead of linked";
   "copy_patterns" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","copy_patterns","takes value");
   "when_no_source"
   comment => "Behaviour when the source file to link to does not exist",
   association => a("is a possible sub-body constraint for","link_from","may have sub-body constraints");
body_constraints::
   "when_no_source" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Behaviour when the source file to link to does not exist";
   "link_children"
   comment => "true/false whether to link all directory's children to source originals",
   association => a("is a possible sub-body constraint for","link_from","may have sub-body constraints");
body_constraints::
   "link_children" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false whether to link all directory's children to source originals";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","link_children","takes value");
   "when_linking_children"
   comment => "Policy for overriding existing files when linking directories of children",
   association => a("is a possible sub-body constraint for","link_from","may have sub-body constraints");
body_constraints::
   "when_linking_children" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Policy for overriding existing files when linking directories of children";
promise_types::
   "files";
body_constraints::
   "perms"
   comment => "Criteria for setting permissions on a file",
   association => a("is a possible body constraint for","promise_types::files","can have body constraints");
   "mode"
   comment => "File permissions (like posix chmod)",
   association => a("is a possible sub-body constraint for","perms","may have sub-body constraints");
body_constraints::
   "mode" association => a("is a body constraint of type","posix file mode or permission","has possible body constraints"),
          comment => "File permissions (like posix chmod)";
values::

 "posix file mode or permission" comment => "Represent type string and should match [0-7augorwxst,+-]+",
    association => a("are used in constraint parameters","mode","takes value");
   "owners"
   comment => "List of acceptable owners or user ids, first is change target",
   association => a("is a possible sub-body constraint for","perms","may have sub-body constraints");
body_constraints::
   "owners" association => a("is a body constraint of type","a user/group id","has possible body constraints"),
          comment => "List of acceptable owners or user ids, first is change target";
   "owners" association => a("is a list of type","a user/group id","is used in");
values::

 "a user/group id" comment => "Represent type slist and should match [a-zA-Z0-9_$.-]+",
    association => a("are used in constraint parameters","owners","takes value");
   "groups"
   comment => "List of acceptable groups of group ids, first is change target",
   association => a("is a possible sub-body constraint for","perms","may have sub-body constraints");
body_constraints::
   "groups" association => a("is a body constraint of type","a user/group id","has possible body constraints"),
          comment => "List of acceptable groups of group ids, first is change target";
   "groups" association => a("is a list of type","a user/group id","is used in");
values::

 "a user/group id" comment => "Represent type slist and should match [a-zA-Z0-9_$.-]+",
    association => a("are used in constraint parameters","groups","takes value");
   "rxdirs"
   comment => "true/false add execute flag for directories if read flag is set",
   association => a("is a possible sub-body constraint for","perms","may have sub-body constraints");
body_constraints::
   "rxdirs" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false add execute flag for directories if read flag is set";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","rxdirs","takes value");
   "bsdflags"
   comment => "List of menu options for bsd file system flags to set",
   association => a("is a possible sub-body constraint for","perms","may have sub-body constraints");
body_constraints::
   "bsdflags" association => a("is a body constraint of type","(option list)","has possible body constraints"),
          comment => "List of menu options for bsd file system flags to set";
promise_types::
   "files";
body_constraints::
   "changes"
   comment => "Criteria for change management",
   association => a("is a possible body constraint for","promise_types::files","can have body constraints");
   "hash"
   comment => "Hash files for change detection",
   association => a("is a possible sub-body constraint for","changes","may have sub-body constraints");
body_constraints::
   "hash" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Hash files for change detection";
   "report_changes"
   comment => "Specify criteria for change warnings",
   association => a("is a possible sub-body constraint for","changes","may have sub-body constraints");
body_constraints::
   "report_changes" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Specify criteria for change warnings";
   "update_hashes"
   comment => "Update hash values immediately after change warning",
   association => a("is a possible sub-body constraint for","changes","may have sub-body constraints");
body_constraints::
   "update_hashes" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "Update hash values immediately after change warning";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","update_hashes","takes value");
promise_types::
   "files";
body_constraints::
   "delete"
   comment => "Criteria for deleting files",
   association => a("is a possible body constraint for","promise_types::files","can have body constraints");
   "dirlinks"
   comment => "Menu option policy for dealing with symbolic links to directories during deletion",
   association => a("is a possible sub-body constraint for","delete","may have sub-body constraints");
body_constraints::
   "dirlinks" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Menu option policy for dealing with symbolic links to directories during deletion";
   "rmdirs"
   comment => "true/false whether to delete empty directories during recursive deletion",
   association => a("is a possible sub-body constraint for","delete","may have sub-body constraints");
body_constraints::
   "rmdirs" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false whether to delete empty directories during recursive deletion";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","rmdirs","takes value");
promise_types::
   "files";
body_constraints::
   "rename"
   comment => "Criteria for renaming files",
   association => a("is a possible body constraint for","promise_types::files","can have body constraints");
   "newname"
   comment => "The desired name for the current file",
   association => a("is a possible sub-body constraint for","rename","may have sub-body constraints");
body_constraints::
   "newname" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "The desired name for the current file";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","newname","takes value");
   "disable_suffix"
   comment => "The suffix to add to files when disabling (.cfdisabled)",
   association => a("is a possible sub-body constraint for","rename","may have sub-body constraints");
body_constraints::
   "disable_suffix" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "The suffix to add to files when disabling (.cfdisabled)";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","disable_suffix","takes value");
   "disable"
   comment => "true/false automatically rename and remove permissions",
   association => a("is a possible sub-body constraint for","rename","may have sub-body constraints");
body_constraints::
   "disable" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false automatically rename and remove permissions";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","disable","takes value");
   "rotate"
   comment => "Maximum number of file rotations to keep",
   association => a("is a possible sub-body constraint for","rename","may have sub-body constraints");
body_constraints::
   "rotate" association => a("is a body constraint of type","int","has possible body constraints"),
          comment => "Maximum number of file rotations to keep";
   "disable_mode"
   comment => "The permissions to set when a file is disabled",
   association => a("is a possible sub-body constraint for","rename","may have sub-body constraints");
body_constraints::
   "disable_mode" association => a("is a body constraint of type","posix file mode or permission","has possible body constraints"),
          comment => "The permissions to set when a file is disabled";
values::

 "posix file mode or permission" comment => "Represent type string and should match [0-7augorwxst,+-]+",
    association => a("are used in constraint parameters","disable_mode","takes value");
promise_types::
   "files";
body_constraints::
   "repository"
   comment => "Name of a repository for versioning",
   association => a("is a possible body constraint for","promise_types::files","can have body constraints");
body_constraints::
   "repository" association => a("is a body constraint of type","a file path","has possible body constraints"),
          comment => "Name of a repository for versioning";
values::

 "a file path" comment => "Represent type string and should match [cC]:\\.*|/.*",
    association => a("are used in constraint parameters","repository","takes value");
promise_types::
   "files";
body_constraints::
   "edit_line"
   comment => "Line editing model for file",
   association => a("is a possible body constraint for","promise_types::files","can have body constraints");
body_constraints::
   "edit_line" association => a("is a body constraint of type","(ext bundle)","has possible body constraints"),
          comment => "Line editing model for file";
promise_types::
   "files";
body_constraints::
   "edit_xml"
   comment => "XML editing model for file",
   association => a("is a possible body constraint for","promise_types::files","can have body constraints");
body_constraints::
   "edit_xml" association => a("is a body constraint of type","(ext bundle)","has possible body constraints"),
          comment => "XML editing model for file";
promise_types::
   "files";
body_constraints::
   "edit_defaults"
   comment => "Default promise details for file edits",
   association => a("is a possible body constraint for","promise_types::files","can have body constraints");
   "edit_backup"
   comment => "Menu option for backup policy on edit changes",
   association => a("is a possible sub-body constraint for","edit_defaults","may have sub-body constraints");
body_constraints::
   "edit_backup" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Menu option for backup policy on edit changes";
   "max_file_size"
   comment => "Do not edit files bigger than this number of bytes",
   association => a("is a possible sub-body constraint for","edit_defaults","may have sub-body constraints");
body_constraints::
   "max_file_size" association => a("is a body constraint of type","a positive integer","has possible body constraints"),
          comment => "Do not edit files bigger than this number of bytes";
values::

 "a positive integer" comment => "Represent type int and should match 0,99999999999",
    association => a("are used in constraint parameters","max_file_size","takes value");
   "empty_file_before_editing"
   comment => "Baseline memory model of file to zero/empty before commencing promised edits",
   association => a("is a possible sub-body constraint for","edit_defaults","may have sub-body constraints");
body_constraints::
   "empty_file_before_editing" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "Baseline memory model of file to zero/empty before commencing promised edits";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","empty_file_before_editing","takes value");
promise_types::
   "files";
body_constraints::
   "depth_search"
   comment => "Criteria for file depth searches",
   association => a("is a possible body constraint for","promise_types::files","can have body constraints");
   "include_dirs"
   comment => "List of regexes of directory names to include in depth search",
   association => a("is a possible sub-body constraint for","depth_search","may have sub-body constraints");
body_constraints::
   "include_dirs" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "List of regexes of directory names to include in depth search";
   "include_dirs" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match .*",
    association => a("are used in constraint parameters","include_dirs","takes value");
   "exclude_dirs"
   comment => "List of regexes of directory names NOT to include in depth search",
   association => a("is a possible sub-body constraint for","depth_search","may have sub-body constraints");
body_constraints::
   "exclude_dirs" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "List of regexes of directory names NOT to include in depth search";
   "exclude_dirs" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match .*",
    association => a("are used in constraint parameters","exclude_dirs","takes value");
   "include_basedir"
   comment => "true/false include the start/root dir of the search results",
   association => a("is a possible sub-body constraint for","depth_search","may have sub-body constraints");
body_constraints::
   "include_basedir" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false include the start/root dir of the search results";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","include_basedir","takes value");
   "depth"
   comment => "Maximum depth level for search",
   association => a("is a possible sub-body constraint for","depth_search","may have sub-body constraints");
body_constraints::
   "depth" association => a("is a body constraint of type","a positive integer","has possible body constraints"),
          comment => "Maximum depth level for search";
values::

 "a positive integer" comment => "Represent type int and should match 0,99999999999",
    association => a("are used in constraint parameters","depth","takes value");
   "xdev"
   comment => "true/false exclude directories that are on different devices",
   association => a("is a possible sub-body constraint for","depth_search","may have sub-body constraints");
body_constraints::
   "xdev" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false exclude directories that are on different devices";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","xdev","takes value");
   "traverse_links"
   comment => "true/false traverse symbolic links to directories (false)",
   association => a("is a possible sub-body constraint for","depth_search","may have sub-body constraints");
body_constraints::
   "traverse_links" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false traverse symbolic links to directories (false)";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","traverse_links","takes value");
   "rmdeadlinks"
   comment => "true/false remove links that point to nowhere",
   association => a("is a possible sub-body constraint for","depth_search","may have sub-body constraints");
body_constraints::
   "rmdeadlinks" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false remove links that point to nowhere";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","rmdeadlinks","takes value");
promise_types::
   "files";
body_constraints::
   "touch"
   comment => "true/false whether to touch time stamps on file",
   association => a("is a possible body constraint for","promise_types::files","can have body constraints");
body_constraints::
   "touch" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false whether to touch time stamps on file";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","touch","takes value");
promise_types::
   "files";
body_constraints::
   "create"
   comment => "true/false whether to create non-existing file",
   association => a("is a possible body constraint for","promise_types::files","can have body constraints");
body_constraints::
   "create" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false whether to create non-existing file";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","create","takes value");
promise_types::
   "files";
body_constraints::
   "move_obstructions"
   comment => "true/false whether to move obstructions to file-object creation",
   association => a("is a possible body constraint for","promise_types::files","can have body constraints");
body_constraints::
   "move_obstructions" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false whether to move obstructions to file-object creation";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","move_obstructions","takes value");
promise_types::
   "files";
body_constraints::
   "transformer"
   comment => "Shell command (with full path) used to transform current file",
   association => a("is a possible body constraint for","promise_types::files","can have body constraints");
body_constraints::
   "transformer" association => a("is a body constraint of type","a file path","has possible body constraints"),
          comment => "Shell command (with full path) used to transform current file";
values::

 "a file path" comment => "Represent type string and should match [cC]:\\.*|/.*",
    association => a("are used in constraint parameters","transformer","takes value");
promise_types::
   "files";
body_constraints::
   "pathtype"
   comment => "Menu option for interpreting promiser file object",
   association => a("is a possible body constraint for","promise_types::files","can have body constraints");
body_constraints::
   "pathtype" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Menu option for interpreting promiser file object";
promise_types::
   "files";
body_constraints::
   "acl"
   comment => "Criteria for access control lists on file",
   association => a("is a possible body constraint for","promise_types::files","can have body constraints");
   "acl_method"
   comment => "Editing method for access control list",
   association => a("is a possible sub-body constraint for","acl","may have sub-body constraints");
body_constraints::
   "acl_method" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Editing method for access control list";
   "acl_type"
   comment => "Access control list type for the affected file system",
   association => a("is a possible sub-body constraint for","acl","may have sub-body constraints");
body_constraints::
   "acl_type" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Access control list type for the affected file system";
   "acl_directory_inherit"
   comment => "Access control list type for the affected file system",
   association => a("is a possible sub-body constraint for","acl","may have sub-body constraints");
body_constraints::
   "acl_directory_inherit" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Access control list type for the affected file system";
   "aces"
   comment => "Native settings for access control entry",
   association => a("is a possible sub-body constraint for","acl","may have sub-body constraints");
body_constraints::
   "aces" association => a("is a body constraint of type","slist","has possible body constraints"),
          comment => "Native settings for access control entry";
   "aces" association => a("is a list of type","slist","is used in");
   "specify_inherit_aces"
   comment => "Native settings for access control entry",
   association => a("is a possible sub-body constraint for","acl","may have sub-body constraints");
body_constraints::
   "specify_inherit_aces" association => a("is a body constraint of type","slist","has possible body constraints"),
          comment => "Native settings for access control entry";
   "specify_inherit_aces" association => a("is a list of type","slist","is used in");
promise_types::
   "insert_lines";
body_constraints::
   "location"
   comment => "Specify where in a file an insertion will be made",
   association => a("is a possible body constraint for","promise_types::insert_lines","can have body constraints");
   "select_line_matching"
   comment => "Regular expression for matching file line location",
   association => a("is a possible sub-body constraint for","location","may have sub-body constraints");
body_constraints::
   "select_line_matching" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Regular expression for matching file line location";
values::

 "An arbitrary string" comment => "Represent type string and should match .*",
    association => a("are used in constraint parameters","select_line_matching","takes value");
   "before_after"
   comment => "Menu option, point cursor before of after matched line",
   association => a("is a possible sub-body constraint for","location","may have sub-body constraints");
body_constraints::
   "before_after" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Menu option, point cursor before of after matched line";
   "first_last"
   comment => "Menu option, choose first or last occurrence of match in file",
   association => a("is a possible sub-body constraint for","location","may have sub-body constraints");
body_constraints::
   "first_last" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Menu option, choose first or last occurrence of match in file";
promise_types::
   "insert_lines";
body_constraints::
   "insert_type"
   comment => "Type of object the promiser string refers to (default literal)",
   association => a("is a possible body constraint for","promise_types::insert_lines","can have body constraints");
body_constraints::
   "insert_type" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Type of object the promiser string refers to (default literal)";
promise_types::
   "insert_lines";
body_constraints::
   "insert_select"
   comment => "Insert only if lines pass filter criteria",
   association => a("is a possible body constraint for","promise_types::insert_lines","can have body constraints");
   "insert_if_startwith_from_list"
   comment => "Insert line if it starts with a string in the list",
   association => a("is a possible sub-body constraint for","insert_select","may have sub-body constraints");
body_constraints::
   "insert_if_startwith_from_list" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Insert line if it starts with a string in the list";
   "insert_if_startwith_from_list" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match .*",
    association => a("are used in constraint parameters","insert_if_startwith_from_list","takes value");
   "insert_if_not_startwith_from_list"
   comment => "Insert line if it DOES NOT start with a string in the list",
   association => a("is a possible sub-body constraint for","insert_select","may have sub-body constraints");
body_constraints::
   "insert_if_not_startwith_from_list" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Insert line if it DOES NOT start with a string in the list";
   "insert_if_not_startwith_from_list" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match .*",
    association => a("are used in constraint parameters","insert_if_not_startwith_from_list","takes value");
   "insert_if_match_from_list"
   comment => "Insert line if it fully matches a regex in the list",
   association => a("is a possible sub-body constraint for","insert_select","may have sub-body constraints");
body_constraints::
   "insert_if_match_from_list" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Insert line if it fully matches a regex in the list";
   "insert_if_match_from_list" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match .*",
    association => a("are used in constraint parameters","insert_if_match_from_list","takes value");
   "insert_if_not_match_from_list"
   comment => "Insert line if it DOES NOT fully match a regex in the list",
   association => a("is a possible sub-body constraint for","insert_select","may have sub-body constraints");
body_constraints::
   "insert_if_not_match_from_list" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Insert line if it DOES NOT fully match a regex in the list";
   "insert_if_not_match_from_list" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match .*",
    association => a("are used in constraint parameters","insert_if_not_match_from_list","takes value");
   "insert_if_contains_from_list"
   comment => "Insert line if a regex in the list match a line fragment",
   association => a("is a possible sub-body constraint for","insert_select","may have sub-body constraints");
body_constraints::
   "insert_if_contains_from_list" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Insert line if a regex in the list match a line fragment";
   "insert_if_contains_from_list" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match .*",
    association => a("are used in constraint parameters","insert_if_contains_from_list","takes value");
   "insert_if_not_contains_from_list"
   comment => "Insert line if a regex in the list DOES NOT match a line fragment",
   association => a("is a possible sub-body constraint for","insert_select","may have sub-body constraints");
body_constraints::
   "insert_if_not_contains_from_list" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Insert line if a regex in the list DOES NOT match a line fragment";
   "insert_if_not_contains_from_list" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match .*",
    association => a("are used in constraint parameters","insert_if_not_contains_from_list","takes value");
promise_types::
   "insert_lines";
body_constraints::
   "expand_scalars"
   comment => "Expand any unexpanded variables",
   association => a("is a possible body constraint for","promise_types::insert_lines","can have body constraints");
body_constraints::
   "expand_scalars" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "Expand any unexpanded variables";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","expand_scalars","takes value");
promise_types::
   "field_edits";
body_constraints::
   "edit_field"
   comment => "Edit line-based file as matrix of fields",
   association => a("is a possible body constraint for","promise_types::field_edits","can have body constraints");
   "field_separator"
   comment => "The regular expression used to separate fields in a line",
   association => a("is a possible sub-body constraint for","edit_field","may have sub-body constraints");
body_constraints::
   "field_separator" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "The regular expression used to separate fields in a line";
values::

 "An arbitrary string" comment => "Represent type string and should match .*",
    association => a("are used in constraint parameters","field_separator","takes value");
   "select_field"
   comment => "Integer index of the field required 1..n",
   association => a("is a possible sub-body constraint for","edit_field","may have sub-body constraints");
body_constraints::
   "select_field" association => a("is a body constraint of type","a positive integer","has possible body constraints"),
          comment => "Integer index of the field required 1..n";
values::

 "a positive integer" comment => "Represent type int and should match 0,99999999999",
    association => a("are used in constraint parameters","select_field","takes value");
   "value_separator"
   comment => "Character separator for subfields inside the selected field",
   association => a("is a possible sub-body constraint for","edit_field","may have sub-body constraints");
body_constraints::
   "value_separator" association => a("is a body constraint of type","a single character","has possible body constraints"),
          comment => "Character separator for subfields inside the selected field";
values::

 "a single character" comment => "Represent type string and should match ^.$",
    association => a("are used in constraint parameters","value_separator","takes value");
   "field_value"
   comment => "Set field value to a fixed value",
   association => a("is a possible sub-body constraint for","edit_field","may have sub-body constraints");
body_constraints::
   "field_value" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Set field value to a fixed value";
values::

 "An arbitrary string" comment => "Represent type string and should match .*",
    association => a("are used in constraint parameters","field_value","takes value");
   "field_operation"
   comment => "Menu option policy for editing subfields",
   association => a("is a possible sub-body constraint for","edit_field","may have sub-body constraints");
body_constraints::
   "field_operation" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Menu option policy for editing subfields";
   "extend_fields"
   comment => "true/false add new fields at end of line if necessary to complete edit",
   association => a("is a possible sub-body constraint for","edit_field","may have sub-body constraints");
body_constraints::
   "extend_fields" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false add new fields at end of line if necessary to complete edit";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","extend_fields","takes value");
   "allow_blank_fields"
   comment => "true/false allow blank fields in a line (do not purge)",
   association => a("is a possible sub-body constraint for","edit_field","may have sub-body constraints");
body_constraints::
   "allow_blank_fields" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false allow blank fields in a line (do not purge)";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","allow_blank_fields","takes value");
promise_types::
   "replace_patterns";
body_constraints::
   "replace_with"
   comment => "Search-replace pattern",
   association => a("is a possible body constraint for","promise_types::replace_patterns","can have body constraints");
   "replace_value"
   comment => "Value used to replace regular expression matches in search",
   association => a("is a possible sub-body constraint for","replace_with","may have sub-body constraints");
body_constraints::
   "replace_value" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Value used to replace regular expression matches in search";
values::

 "An arbitrary string" comment => "Represent type string and should match .*",
    association => a("are used in constraint parameters","replace_value","takes value");
   "occurrences"
   comment => "Menu option to replace all occurrences or just first (NB the latter is non-convergent)",
   association => a("is a possible sub-body constraint for","replace_with","may have sub-body constraints");
body_constraints::
   "occurrences" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Menu option to replace all occurrences or just first (NB the latter is non-convergent)";
promise_types::
   "delete_lines";
body_constraints::
   "not_matching"
   comment => "true/false negate match criterion",
   association => a("is a possible body constraint for","promise_types::delete_lines","can have body constraints");
body_constraints::
   "not_matching" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false negate match criterion";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","not_matching","takes value");
promise_types::
   "delete_lines";
body_constraints::
   "delete_select"
   comment => "Delete only if lines pass filter criteria",
   association => a("is a possible body constraint for","promise_types::delete_lines","can have body constraints");
   "delete_if_startwith_from_list"
   comment => "Delete line if it starts with a string in the list",
   association => a("is a possible sub-body constraint for","delete_select","may have sub-body constraints");
body_constraints::
   "delete_if_startwith_from_list" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Delete line if it starts with a string in the list";
   "delete_if_startwith_from_list" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match .*",
    association => a("are used in constraint parameters","delete_if_startwith_from_list","takes value");
   "delete_if_not_startwith_from_list"
   comment => "Delete line if it DOES NOT start with a string in the list",
   association => a("is a possible sub-body constraint for","delete_select","may have sub-body constraints");
body_constraints::
   "delete_if_not_startwith_from_list" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Delete line if it DOES NOT start with a string in the list";
   "delete_if_not_startwith_from_list" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match .*",
    association => a("are used in constraint parameters","delete_if_not_startwith_from_list","takes value");
   "delete_if_match_from_list"
   comment => "Delete line if it fully matches a regex in the list",
   association => a("is a possible sub-body constraint for","delete_select","may have sub-body constraints");
body_constraints::
   "delete_if_match_from_list" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Delete line if it fully matches a regex in the list";
   "delete_if_match_from_list" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match .*",
    association => a("are used in constraint parameters","delete_if_match_from_list","takes value");
   "delete_if_not_match_from_list"
   comment => "Delete line if it DOES NOT fully match a regex in the list",
   association => a("is a possible sub-body constraint for","delete_select","may have sub-body constraints");
body_constraints::
   "delete_if_not_match_from_list" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Delete line if it DOES NOT fully match a regex in the list";
   "delete_if_not_match_from_list" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match .*",
    association => a("are used in constraint parameters","delete_if_not_match_from_list","takes value");
   "delete_if_contains_from_list"
   comment => "Delete line if a regex in the list match a line fragment",
   association => a("is a possible sub-body constraint for","delete_select","may have sub-body constraints");
body_constraints::
   "delete_if_contains_from_list" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Delete line if a regex in the list match a line fragment";
   "delete_if_contains_from_list" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match .*",
    association => a("are used in constraint parameters","delete_if_contains_from_list","takes value");
   "delete_if_not_contains_from_list"
   comment => "Delete line if a regex in the list DOES NOT match a line fragment",
   association => a("is a possible sub-body constraint for","delete_select","may have sub-body constraints");
body_constraints::
   "delete_if_not_contains_from_list" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Delete line if a regex in the list DOES NOT match a line fragment";
   "delete_if_not_contains_from_list" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match .*",
    association => a("are used in constraint parameters","delete_if_not_contains_from_list","takes value");
promise_types::
   "interfaces";
body_constraints::
   "tcp_ip"
   comment => "Interface tcp/ip properties",
   association => a("is a possible body constraint for","promise_types::interfaces","can have body constraints");
   "ipv4_address"
   comment => "IPv4 address for the interface",
   association => a("is a possible sub-body constraint for","tcp_ip","may have sub-body constraints");
body_constraints::
   "ipv4_address" association => a("is a body constraint of type","string","has possible body constraints"),
          comment => "IPv4 address for the interface";
   "ipv4_netmask"
   comment => "Netmask for the interface",
   association => a("is a possible sub-body constraint for","tcp_ip","may have sub-body constraints");
body_constraints::
   "ipv4_netmask" association => a("is a body constraint of type","string","has possible body constraints"),
          comment => "Netmask for the interface";
   "ipv6_address"
   comment => "IPv6 address for the interface",
   association => a("is a possible sub-body constraint for","tcp_ip","may have sub-body constraints");
body_constraints::
   "ipv6_address" association => a("is a body constraint of type","string","has possible body constraints"),
          comment => "IPv6 address for the interface";
promise_types::
   "methods";
body_constraints::
   "usebundle"
   comment => "Specify the name of a bundle to run as a parameterized method",
   association => a("is a possible body constraint for","promise_types::methods","can have body constraints");
body_constraints::
   "usebundle" association => a("is a body constraint of type","(ext bundle)","has possible body constraints"),
          comment => "Specify the name of a bundle to run as a parameterized method";
promise_types::
   "packages";
body_constraints::
   "package_policy"
   comment => "Criteria for package installation/upgrade on the current system",
   association => a("is a possible body constraint for","promise_types::packages","can have body constraints");
body_constraints::
   "package_policy" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Criteria for package installation/upgrade on the current system";
promise_types::
   "packages";
body_constraints::
   "package_method"
   comment => "Criteria for installation and verification",
   association => a("is a possible body constraint for","promise_types::packages","can have body constraints");
   "package_changes"
   comment => "Menu option - whether to group packages into a single aggregate command",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_changes" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Menu option - whether to group packages into a single aggregate command";
   "package_file_repositories"
   comment => "A list of machine-local directories to search for packages",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_file_repositories" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "A list of machine-local directories to search for packages";
   "package_file_repositories" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","package_file_repositories","takes value");
   "package_list_command"
   comment => "Command to obtain a list of installed packages",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_list_command" association => a("is a body constraint of type","a file path","has possible body constraints"),
          comment => "Command to obtain a list of installed packages";
values::

 "a file path" comment => "Represent type string and should match [cC]:\\.*|/.*",
    association => a("are used in constraint parameters","package_list_command","takes value");
   "package_list_version_regex"
   comment => "Regular expression with one backreference to extract package version string",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_list_version_regex" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Regular expression with one backreference to extract package version string";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","package_list_version_regex","takes value");
   "package_list_name_regex"
   comment => "Regular expression with one backreference to extract package name string",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_list_name_regex" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Regular expression with one backreference to extract package name string";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","package_list_name_regex","takes value");
   "package_list_arch_regex"
   comment => "Regular expression with one backreference to extract package architecture string",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_list_arch_regex" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Regular expression with one backreference to extract package architecture string";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","package_list_arch_regex","takes value");
   "package_patch_list_command"
   comment => "Command to obtain a list of available patches or updates",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_patch_list_command" association => a("is a body constraint of type","a file path","has possible body constraints"),
          comment => "Command to obtain a list of available patches or updates";
values::

 "a file path" comment => "Represent type string and should match [cC]:\\.*|/.*",
    association => a("are used in constraint parameters","package_patch_list_command","takes value");
   "package_patch_version_regex"
   comment => "Regular expression with one backreference to extract update version string",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_patch_version_regex" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Regular expression with one backreference to extract update version string";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","package_patch_version_regex","takes value");
   "package_patch_name_regex"
   comment => "Regular expression with one backreference to extract update name string",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_patch_name_regex" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Regular expression with one backreference to extract update name string";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","package_patch_name_regex","takes value");
   "package_patch_arch_regex"
   comment => "Regular expression with one backreference to extract update architecture string",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_patch_arch_regex" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Regular expression with one backreference to extract update architecture string";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","package_patch_arch_regex","takes value");
   "package_patch_installed_regex"
   comment => "Regular expression which matches packages that are already installed",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_patch_installed_regex" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Regular expression which matches packages that are already installed";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","package_patch_installed_regex","takes value");
   "package_version_regex"
   comment => "Regular expression with one backreference to extract package version string",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_version_regex" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Regular expression with one backreference to extract package version string";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","package_version_regex","takes value");
   "package_name_regex"
   comment => "Regular expression with one backreference to extract package name string",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_name_regex" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Regular expression with one backreference to extract package name string";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","package_name_regex","takes value");
   "package_arch_regex"
   comment => "Regular expression with one backreference to extract package architecture string",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_arch_regex" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Regular expression with one backreference to extract package architecture string";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","package_arch_regex","takes value");
   "package_installed_regex"
   comment => "Regular expression which matches packages that are already installed",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_installed_regex" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Regular expression which matches packages that are already installed";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","package_installed_regex","takes value");
   "package_add_command"
   comment => "Command to install a package to the system",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_add_command" association => a("is a body constraint of type","a file path","has possible body constraints"),
          comment => "Command to install a package to the system";
values::

 "a file path" comment => "Represent type string and should match [cC]:\\.*|/.*",
    association => a("are used in constraint parameters","package_add_command","takes value");
   "package_delete_command"
   comment => "Command to remove a package from the system",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_delete_command" association => a("is a body constraint of type","a file path","has possible body constraints"),
          comment => "Command to remove a package from the system";
values::

 "a file path" comment => "Represent type string and should match [cC]:\\.*|/.*",
    association => a("are used in constraint parameters","package_delete_command","takes value");
   "package_update_command"
   comment => "Command to update to the latest version a currently installed package",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_update_command" association => a("is a body constraint of type","a file path","has possible body constraints"),
          comment => "Command to update to the latest version a currently installed package";
values::

 "a file path" comment => "Represent type string and should match [cC]:\\.*|/.*",
    association => a("are used in constraint parameters","package_update_command","takes value");
   "package_patch_command"
   comment => "Command to update to the latest patch release of an installed package",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_patch_command" association => a("is a body constraint of type","a file path","has possible body constraints"),
          comment => "Command to update to the latest patch release of an installed package";
values::

 "a file path" comment => "Represent type string and should match [cC]:\\.*|/.*",
    association => a("are used in constraint parameters","package_patch_command","takes value");
   "package_verify_command"
   comment => "Command to verify the correctness of an installed package",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_verify_command" association => a("is a body constraint of type","a file path","has possible body constraints"),
          comment => "Command to verify the correctness of an installed package";
values::

 "a file path" comment => "Represent type string and should match [cC]:\\.*|/.*",
    association => a("are used in constraint parameters","package_verify_command","takes value");
   "package_noverify_regex"
   comment => "Regular expression to match verification failure output",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_noverify_regex" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Regular expression to match verification failure output";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","package_noverify_regex","takes value");
   "package_noverify_returncode"
   comment => "Integer return code indicating package verification failure",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_noverify_returncode" association => a("is a body constraint of type","integer","has possible body constraints"),
          comment => "Integer return code indicating package verification failure";
values::

 "integer" comment => "Represent type int and should match -99999999999,9999999999",
    association => a("are used in constraint parameters","package_noverify_returncode","takes value");
   "package_name_convention"
   comment => "This is how the package manager expects the file to be referred to, e.g. $(name).$(arch)",
   association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
body_constraints::
   "package_name_convention" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "This is how the package manager expects the file to be referred to, e.g. $(name).$(arch)";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","package_name_convention","takes value");
promise_types::
   "packages";
body_constraints::
   "package_version"
   comment => "Version reference point for determining promised version",
   association => a("is a possible body constraint for","promise_types::packages","can have body constraints");
body_constraints::
   "package_version" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Version reference point for determining promised version";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","package_version","takes value");
promise_types::
   "packages";
body_constraints::
   "package_architectures"
   comment => "Select the architecture for package selection",
   association => a("is a possible body constraint for","promise_types::packages","can have body constraints");
body_constraints::
   "package_architectures" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Select the architecture for package selection";
   "package_architectures" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","package_architectures","takes value");
promise_types::
   "packages";
body_constraints::
   "package_select"
   comment => "A criterion for first acceptable match relative to \"package_version\"",
   association => a("is a possible body constraint for","promise_types::packages","can have body constraints");
body_constraints::
   "package_select" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "A criterion for first acceptable match relative to \"package_version\"";
promise_types::
   "processes";
body_constraints::
   "signals"
   comment => "A list of menu options representing signals to be sent to a process",
   association => a("is a possible body constraint for","promise_types::processes","can have body constraints");
body_constraints::
   "signals" association => a("is a body constraint of type","system signals","has possible body constraints"),
          comment => "A list of menu options representing signals to be sent to a process";
values::

 "system signals" comment => "Represent type (option list) and should match hup,int,trap,kill,pipe,cont,abrt,stop,quit,term,child,usr1,usr2,bus,segv",
    association => a("are used in constraint parameters","signals","takes value");
promise_types::
   "processes";
body_constraints::
   "process_stop"
   comment => "A command used to stop a running process",
   association => a("is a possible body constraint for","promise_types::processes","can have body constraints");
body_constraints::
   "process_stop" association => a("is a body constraint of type","a file path","has possible body constraints"),
          comment => "A command used to stop a running process";
values::

 "a file path" comment => "Represent type string and should match [cC]:\\.*|/.*",
    association => a("are used in constraint parameters","process_stop","takes value");
promise_types::
   "processes";
body_constraints::
   "process_count"
   comment => "Criteria for constraining the number of processes matching other criteria",
   association => a("is a possible body constraint for","promise_types::processes","can have body constraints");
   "match_range"
   comment => "Integer range for acceptable number of matches for this process",
   association => a("is a possible sub-body constraint for","process_count","may have sub-body constraints");
body_constraints::
   "match_range" association => a("is a body constraint of type","a positive integer","has possible body constraints"),
          comment => "Integer range for acceptable number of matches for this process";
values::

 "a positive integer" comment => "Represent type irange [int,int] and should match 0,99999999999",
    association => a("are used in constraint parameters","match_range","takes value");
   "in_range_define"
   comment => "List of classes to define if the matches are in range",
   association => a("is a possible sub-body constraint for","process_count","may have sub-body constraints");
body_constraints::
   "in_range_define" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "List of classes to define if the matches are in range";
   "in_range_define" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","in_range_define","takes value");
   "out_of_range_define"
   comment => "List of classes to define if the matches are out of range",
   association => a("is a possible sub-body constraint for","process_count","may have sub-body constraints");
body_constraints::
   "out_of_range_define" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "List of classes to define if the matches are out of range";
   "out_of_range_define" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","out_of_range_define","takes value");
promise_types::
   "processes";
body_constraints::
   "process_select"
   comment => "Criteria for matching processes in the system process table",
   association => a("is a possible body constraint for","promise_types::processes","can have body constraints");
   "process_owner"
   comment => "List of regexes matching the user of a process",
   association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
body_constraints::
   "process_owner" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "List of regexes matching the user of a process";
   "process_owner" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","process_owner","takes value");
   "pid"
   comment => "Range of integers matching the process id of a process",
   association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
body_constraints::
   "pid" association => a("is a body constraint of type","a positive integer","has possible body constraints"),
          comment => "Range of integers matching the process id of a process";
values::

 "a positive integer" comment => "Represent type irange [int,int] and should match 0,99999999999",
    association => a("are used in constraint parameters","pid","takes value");
   "ppid"
   comment => "Range of integers matching the parent process id of a process",
   association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
body_constraints::
   "ppid" association => a("is a body constraint of type","a positive integer","has possible body constraints"),
          comment => "Range of integers matching the parent process id of a process";
values::

 "a positive integer" comment => "Represent type irange [int,int] and should match 0,99999999999",
    association => a("are used in constraint parameters","ppid","takes value");
   "pgid"
   comment => "Range of integers matching the parent group id of a process",
   association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
body_constraints::
   "pgid" association => a("is a body constraint of type","a positive integer","has possible body constraints"),
          comment => "Range of integers matching the parent group id of a process";
values::

 "a positive integer" comment => "Represent type irange [int,int] and should match 0,99999999999",
    association => a("are used in constraint parameters","pgid","takes value");
   "rsize"
   comment => "Range of integers matching the resident memory size of a process",
   association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
body_constraints::
   "rsize" association => a("is a body constraint of type","a positive integer","has possible body constraints"),
          comment => "Range of integers matching the resident memory size of a process";
values::

 "a positive integer" comment => "Represent type irange [int,int] and should match 0,99999999999",
    association => a("are used in constraint parameters","rsize","takes value");
   "vsize"
   comment => "Range of integers matching the virtual memory size of a process",
   association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
body_constraints::
   "vsize" association => a("is a body constraint of type","a positive integer","has possible body constraints"),
          comment => "Range of integers matching the virtual memory size of a process";
values::

 "a positive integer" comment => "Represent type irange [int,int] and should match 0,99999999999",
    association => a("are used in constraint parameters","vsize","takes value");
   "status"
   comment => "Regular expression matching the status field of a process",
   association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
body_constraints::
   "status" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Regular expression matching the status field of a process";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","status","takes value");
   "ttime_range"
   comment => "Range of integers matching the total elapsed time of a process",
   association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
body_constraints::
   "ttime_range" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
          comment => "Range of integers matching the total elapsed time of a process";
   "stime_range"
   comment => "Range of integers matching the start time of a process",
   association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
body_constraints::
   "stime_range" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
          comment => "Range of integers matching the start time of a process";
   "command"
   comment => "Regular expression matching the command/cmd field of a process",
   association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
body_constraints::
   "command" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Regular expression matching the command/cmd field of a process";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","command","takes value");
   "tty"
   comment => "Regular expression matching the tty field of a process",
   association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
body_constraints::
   "tty" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Regular expression matching the tty field of a process";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","tty","takes value");
   "priority"
   comment => "Range of integers matching the priority field (PRI/NI) of a process",
   association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
body_constraints::
   "priority" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
          comment => "Range of integers matching the priority field (PRI/NI) of a process";
   "threads"
   comment => "Range of integers matching the threads (NLWP) field of a process",
   association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
body_constraints::
   "threads" association => a("is a body constraint of type","a positive integer","has possible body constraints"),
          comment => "Range of integers matching the threads (NLWP) field of a process";
values::

 "a positive integer" comment => "Represent type irange [int,int] and should match 0,99999999999",
    association => a("are used in constraint parameters","threads","takes value");
   "process_result"
   comment => "Boolean class expression returning the logical combination of classes set by a process selection test",
   association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
body_constraints::
   "process_result" association => a("is a body constraint of type","string","has possible body constraints"),
          comment => "Boolean class expression returning the logical combination of classes set by a process selection test";
promise_types::
   "processes";
body_constraints::
   "restart_class"
   comment => "A class to be set if the process is not running, so that a command: rule can be referred to restart the process",
   association => a("is a possible body constraint for","promise_types::processes","can have body constraints");
body_constraints::
   "restart_class" association => a("is a body constraint of type","a cfengine identifier","has possible body constraints"),
          comment => "A class to be set if the process is not running, so that a command: rule can be referred to restart the process";
values::

 "a cfengine identifier" comment => "Represent type string and should match [a-zA-Z0-9_$.]+",
    association => a("are used in constraint parameters","restart_class","takes value");
promise_types::
   "storage";
body_constraints::
   "mount"
   comment => "Criteria for mounting foreign file systems",
   association => a("is a possible body constraint for","promise_types::storage","can have body constraints");
   "mount_type"
   comment => "Protocol type of remote file system",
   association => a("is a possible sub-body constraint for","mount","may have sub-body constraints");
body_constraints::
   "mount_type" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Protocol type of remote file system";
   "mount_source"
   comment => "Path of remote file system to mount",
   association => a("is a possible sub-body constraint for","mount","may have sub-body constraints");
body_constraints::
   "mount_source" association => a("is a body constraint of type","a file path","has possible body constraints"),
          comment => "Path of remote file system to mount";
values::

 "a file path" comment => "Represent type string and should match [cC]:\\.*|/.*",
    association => a("are used in constraint parameters","mount_source","takes value");
   "mount_server"
   comment => "Hostname or IP or remote file system server",
   association => a("is a possible sub-body constraint for","mount","may have sub-body constraints");
body_constraints::
   "mount_server" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Hostname or IP or remote file system server";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","mount_server","takes value");
   "mount_options"
   comment => "List of option strings to add to the file system table (\"fstab\")",
   association => a("is a possible sub-body constraint for","mount","may have sub-body constraints");
body_constraints::
   "mount_options" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "List of option strings to add to the file system table (\"fstab\")";
   "mount_options" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","mount_options","takes value");
   "edit_fstab"
   comment => "true/false add or remove entries to the file system table (\"fstab\")",
   association => a("is a possible sub-body constraint for","mount","may have sub-body constraints");
body_constraints::
   "edit_fstab" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false add or remove entries to the file system table (\"fstab\")";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","edit_fstab","takes value");
   "unmount"
   comment => "true/false unmount a previously mounted filesystem",
   association => a("is a possible sub-body constraint for","mount","may have sub-body constraints");
body_constraints::
   "unmount" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false unmount a previously mounted filesystem";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","unmount","takes value");
promise_types::
   "storage";
body_constraints::
   "volume"
   comment => "Criteria for monitoring/probing mounted volumes",
   association => a("is a possible body constraint for","promise_types::storage","can have body constraints");
   "check_foreign"
   comment => "true/false verify storage that is mounted from a foreign system on this host",
   association => a("is a possible sub-body constraint for","volume","may have sub-body constraints");
body_constraints::
   "check_foreign" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false verify storage that is mounted from a foreign system on this host";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","check_foreign","takes value");
   "freespace"
   comment => "Absolute or percentage minimum disk space that should be available before warning",
   association => a("is a possible sub-body constraint for","volume","may have sub-body constraints");
body_constraints::
   "freespace" association => a("is a body constraint of type","string","has possible body constraints"),
          comment => "Absolute or percentage minimum disk space that should be available before warning";
   "sensible_size"
   comment => "Minimum size in bytes that should be used on a sensible-looking storage device",
   association => a("is a possible sub-body constraint for","volume","may have sub-body constraints");
body_constraints::
   "sensible_size" association => a("is a body constraint of type","a positive integer","has possible body constraints"),
          comment => "Minimum size in bytes that should be used on a sensible-looking storage device";
values::

 "a positive integer" comment => "Represent type int and should match 0,99999999999",
    association => a("are used in constraint parameters","sensible_size","takes value");
   "sensible_count"
   comment => "Minimum number of files that should be defined on a sensible-looking storage device",
   association => a("is a possible sub-body constraint for","volume","may have sub-body constraints");
body_constraints::
   "sensible_count" association => a("is a body constraint of type","a positive integer","has possible body constraints"),
          comment => "Minimum number of files that should be defined on a sensible-looking storage device";
values::

 "a positive integer" comment => "Represent type int and should match 0,99999999999",
    association => a("are used in constraint parameters","sensible_count","takes value");
   "scan_arrivals"
   comment => "true/false generate pseudo-periodic disk change arrival distribution",
   association => a("is a possible sub-body constraint for","volume","may have sub-body constraints");
body_constraints::
   "scan_arrivals" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false generate pseudo-periodic disk change arrival distribution";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","scan_arrivals","takes value");
promise_types::
   "access";
body_constraints::
   "admit"
   comment => "List of host names or IP addresses to grant access to file objects",
   association => a("is a possible body constraint for","promise_types::access","can have body constraints");
body_constraints::
   "admit" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "List of host names or IP addresses to grant access to file objects";
   "admit" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","admit","takes value");
promise_types::
   "access";
body_constraints::
   "deny"
   comment => "List of host names or IP addresses to deny access to file objects",
   association => a("is a possible body constraint for","promise_types::access","can have body constraints");
body_constraints::
   "deny" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "List of host names or IP addresses to deny access to file objects";
   "deny" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","deny","takes value");
promise_types::
   "access";
body_constraints::
   "maproot"
   comment => "List of host names or IP addresses to grant full read-privilege on the server",
   association => a("is a possible body constraint for","promise_types::access","can have body constraints");
body_constraints::
   "maproot" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "List of host names or IP addresses to grant full read-privilege on the server";
   "maproot" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","maproot","takes value");
promise_types::
   "access";
body_constraints::
   "ifencrypted"
   comment => "true/false whether the current file access promise is conditional on the connection from the client being encrypted",
   association => a("is a possible body constraint for","promise_types::access","can have body constraints");
body_constraints::
   "ifencrypted" association => a("is a body constraint of type","boolean","has possible body constraints"),
          comment => "true/false whether the current file access promise is conditional on the connection from the client being encrypted";
values::

 "boolean" comment => "Represent type (menu option) and should match true,false,yes,no,on,off",
    association => a("are used in constraint parameters","ifencrypted","takes value");
promise_types::
   "access";
body_constraints::
   "resource_type"
   comment => "The type of object being granted access. The default is access to files.",
   association => a("is a possible body constraint for","promise_types::access","can have body constraints");
body_constraints::
   "resource_type" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "The type of object being granted access. The default is access to files.";
promise_types::
   "roles";
body_constraints::
   "authorize"
   comment => "List of public-key user names that are allowed to activate the promised class during remote agent activation",
   association => a("is a possible body constraint for","promise_types::roles","can have body constraints");
body_constraints::
   "authorize" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "List of public-key user names that are allowed to activate the promised class during remote agent activation";
   "authorize" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","authorize","takes value");
promise_types::
   "topics";
body_constraints::
   "association"
   comment => "Declare associated topics",
   association => a("is a possible body constraint for","promise_types::topics","can have body constraints");
   "forward_relationship"
   comment => "Name of forward association between promiser topic and associates",
   association => a("is a possible sub-body constraint for","association","may have sub-body constraints");
body_constraints::
   "forward_relationship" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Name of forward association between promiser topic and associates";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","forward_relationship","takes value");
   "backward_relationship"
   comment => "Name of backward/inverse association from associates to promiser topic",
   association => a("is a possible sub-body constraint for","association","may have sub-body constraints");
body_constraints::
   "backward_relationship" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Name of backward/inverse association from associates to promiser topic";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","backward_relationship","takes value");
   "associates"
   comment => "List of associated topics by this forward relationship",
   association => a("is a possible sub-body constraint for","association","may have sub-body constraints");
body_constraints::
   "associates" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "List of associated topics by this forward relationship";
   "associates" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","associates","takes value");
promise_types::
   "topics";
body_constraints::
   "comment"
   comment => "Retained comment about this promise's real intention",
   association => a("is a possible body constraint for","promise_types::topics","can have body constraints");
body_constraints::
   "comment" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Retained comment about this promise's real intention";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","comment","takes value");
promise_types::
   "occurrences";
body_constraints::
   "represents"
   comment => "List of subtopics that explains the type(s) of information represented by the occurrence",
   association => a("is a possible body constraint for","promise_types::occurrences","can have body constraints");
body_constraints::
   "represents" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "List of subtopics that explains the type(s) of information represented by the occurrence";
   "represents" association => a("is a list of type","An arbitrary string","is used in");
values::

 "An arbitrary string" comment => "Represent type slist and should match ",
    association => a("are used in constraint parameters","represents","takes value");
promise_types::
   "occurrences";
body_constraints::
   "representation"
   comment => "How to interpret the promiser string e.g. actual data or reference to data",
   association => a("is a possible body constraint for","promise_types::occurrences","can have body constraints");
body_constraints::
   "representation" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "How to interpret the promiser string e.g. actual data or reference to data";
promise_types::
   "occurrences";
body_constraints::
   "web_root"
   comment => "Base URL of the occurrence when rendered as a web-URL (replaces path_root)",
   association => a("is a possible body constraint for","promise_types::occurrences","can have body constraints");
body_constraints::
   "web_root" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Base URL of the occurrence when rendered as a web-URL (replaces path_root)";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","web_root","takes value");
promise_types::
   "occurrences";
body_constraints::
   "path_root"
   comment => "Base path of the occurrence when locating file (replaced by web_root)",
   association => a("is a possible body constraint for","promise_types::occurrences","can have body constraints");
body_constraints::
   "path_root" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Base path of the occurrence when locating file (replaced by web_root)";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","path_root","takes value");
promise_types::
   "measurements";
body_constraints::
   "stream_type"
   comment => "The datatype being collected.",
   association => a("is a possible body constraint for","promise_types::measurements","can have body constraints");
body_constraints::
   "stream_type" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "The datatype being collected.";
promise_types::
   "measurements";
body_constraints::
   "data_type"
   comment => "The datatype being collected.",
   association => a("is a possible body constraint for","promise_types::measurements","can have body constraints");
body_constraints::
   "data_type" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "The datatype being collected.";
promise_types::
   "measurements";
body_constraints::
   "history_type"
   comment => "Whether the data can be seen as a time-series or just an isolated value",
   association => a("is a possible body constraint for","promise_types::measurements","can have body constraints");
body_constraints::
   "history_type" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
          comment => "Whether the data can be seen as a time-series or just an isolated value";
promise_types::
   "measurements";
body_constraints::
   "units"
   comment => "The engineering dimensions of this value or a note about its intent used in plots",
   association => a("is a possible body constraint for","promise_types::measurements","can have body constraints");
body_constraints::
   "units" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "The engineering dimensions of this value or a note about its intent used in plots";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","units","takes value");
promise_types::
   "measurements";
body_constraints::
   "match_value"
   comment => "Criteria for extracting the measurement from a datastream",
   association => a("is a possible body constraint for","promise_types::measurements","can have body constraints");
   "select_line_matching"
   comment => "Regular expression for matching line location",
   association => a("is a possible sub-body constraint for","match_value","may have sub-body constraints");
body_constraints::
   "select_line_matching" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Regular expression for matching line location";
values::

 "An arbitrary string" comment => "Represent type string and should match .*",
    association => a("are used in constraint parameters","select_line_matching","takes value");
   "select_line_number"
   comment => "Read from the n-th line of the output (fixed format)",
   association => a("is a possible sub-body constraint for","match_value","may have sub-body constraints");
body_constraints::
   "select_line_number" association => a("is a body constraint of type","a positive integer","has possible body constraints"),
          comment => "Read from the n-th line of the output (fixed format)";
values::

 "a positive integer" comment => "Represent type int and should match 0,99999999999",
    association => a("are used in constraint parameters","select_line_number","takes value");
   "extraction_regex"
   comment => "Regular expression that should contain a single backreference for extracting a value",
   association => a("is a possible sub-body constraint for","match_value","may have sub-body constraints");
body_constraints::
   "extraction_regex" association => a("is a body constraint of type","An arbitrary string","has possible body constraints"),
          comment => "Regular expression that should contain a single backreference for extracting a value";
values::

 "An arbitrary string" comment => "Represent type string and should match ",
    association => a("are used in constraint parameters","extraction_regex","takes value");
   "action";
   "classes";
   "ifvarclass";
   "handle";
   "depends_on";
   "comment";
   "select_region";
miscellaneous_concepts::
  "data types";
data_types::
  "string" comment => "A scalar string matching ";
  "int" comment => "A scalar integer matching -99999999999,9999999999";
  "real" comment => "A scalar real number matching -9.99999E100,9.99999E100";
  "slist" comment => "A list of scalar strings matching ";
  "ilist" comment => "A list of integers matching -99999999999,9999999999";
  "rlist" comment => "A list of real numbers matching -9.99999E100,9.99999E100";
  "policy" comment => "The policy for (dis)allowing redefinition of variables matching free,overridable,constant";
  "class" comment => "A boolean returned by certain functions in classes promises";
functions::

 "accessedbefore"     comment => "True if arg1 was accessed before arg2 (atime)",
    association => a("returns data-type","class","is returned by function");
 "accumulated"     comment => "Convert an accumulated amount of time into a system representation",
    association => a("returns data-type","int","is returned by function");
 "ago"     comment => "Convert a time relative to now to an integer system representation",
    association => a("returns data-type","int","is returned by function");
 "canonify"     comment => "Convert an abitrary string into a legal class name",
    association => a("returns data-type","string","is returned by function");
 "changedbefore"     comment => "True if arg1 was changed before arg2 (ctime)",
    association => a("returns data-type","class","is returned by function");
 "classify"     comment => "True if the canonicalization of the argument is a currently defined class",
    association => a("returns data-type","class","is returned by function");
 "classmatch"     comment => "True if the regular expression matches any currently defined class",
    association => a("returns data-type","class","is returned by function");
 "execresult"     comment => "Execute named command and assign output to variable",
    association => a("returns data-type","string","is returned by function");
 "fileexists"     comment => "True if the named file can be accessed",
    association => a("returns data-type","class","is returned by function");
 "filesexist"     comment => "True if the named list of files can ALL be accessed",
    association => a("returns data-type","class","is returned by function");
 "getindices"     comment => "Get a list of keys to the array whose id is the argument and assign to variable",
    association => a("returns data-type","slist","is returned by function");
 "getgid"     comment => "Return the integer group id of the named group on this host",
    association => a("returns data-type","int","is returned by function");
 "getuid"     comment => "Return the integer user id of the named user on this host",
    association => a("returns data-type","int","is returned by function");
 "groupexists"     comment => "True if group or numerical id exists on this host",
    association => a("returns data-type","class","is returned by function");
 "hash"     comment => "Return the hash of arg1, type arg2 and assign to a variable",
    association => a("returns data-type","string","is returned by function");
 "hashmatch"     comment => "Compute the hash of arg1, of type arg2 and test if it matches the value in arg 3",
    association => a("returns data-type","class","is returned by function");
 "hostrange"     comment => "True if the current host lies in the range of enumerated hostnames specified",
    association => a("returns data-type","class","is returned by function");
 "hostinnetgroup"     comment => "True if the current host is in the named netgroup",
    association => a("returns data-type","class","is returned by function");
 "iprange"     comment => "True if the current host lies in the range of IP addresses specified",
    association => a("returns data-type","class","is returned by function");
 "irange"     comment => "Define a range of integer values for cfengine internal use",
    association => a("returns data-type","irange [int,int]","is returned by function");
 "isdir"     comment => "True if the named object is a directory",
    association => a("returns data-type","class","is returned by function");
 "isgreaterthan"     comment => "True if arg1 is numerically greater than arg2, else compare strings like strcmp",
    association => a("returns data-type","class","is returned by function");
 "islessthan"     comment => "True if arg1 is numerically less than arg2, else compare strings like NOT strcmp",
    association => a("returns data-type","class","is returned by function");
 "islink"     comment => "True if the named object is a symbolic link",
    association => a("returns data-type","class","is returned by function");
 "isnewerthan"     comment => "True if arg1 is newer (modified later) than arg2 (mtime)",
    association => a("returns data-type","class","is returned by function");
 "isplain"     comment => "True if the named object is a plain/regular file",
    association => a("returns data-type","class","is returned by function");
 "isvariable"     comment => "True if the named variable is defined",
    association => a("returns data-type","class","is returned by function");
 "lastnode"     comment => "Extract the last of a separated string, e.g. filename from a path",
    association => a("returns data-type","string","is returned by function");
 "ldaparray"     comment => "Extract all values from an ldap record",
    association => a("returns data-type","class","is returned by function");
 "ldaplist"     comment => "Extract all named values from multiple ldap records",
    association => a("returns data-type","slist","is returned by function");
 "ldapvalue"     comment => "Extract the first matching named value from ldap",
    association => a("returns data-type","string","is returned by function");
 "now"     comment => "Convert the current time into system representation",
    association => a("returns data-type","int","is returned by function");
 "on"     comment => "Convert an exact date/time to an integer system representation",
    association => a("returns data-type","int","is returned by function");
 "peers"     comment => "Get a list of peers (not including ourself) from the partition to which we belong",
    association => a("returns data-type","slist","is returned by function");
 "peerleader"     comment => "Get the assigned peer-leader of the partition to which we belong",
    association => a("returns data-type","string","is returned by function");
 "peerleaders"     comment => "Get a list of peer leaders from the named partitioning",
    association => a("returns data-type","slist","is returned by function");
 "randomint"     comment => "Generate a random integer between the given limits",
    association => a("returns data-type","int","is returned by function");
 "readfile"     comment => "Read max number of bytes from named file and assign to variable",
    association => a("returns data-type","string","is returned by function");
 "readintarray"     comment => "Read an array of integers from a file and assign the dimension to a variable",
    association => a("returns data-type","int","is returned by function");
 "readintlist"     comment => "Read and assign a list variable from a file of separated ints",
    association => a("returns data-type","ilist","is returned by function");
 "readrealarray"     comment => "Read an array of real numbers from a file and assign the dimension to a variable",
    association => a("returns data-type","int","is returned by function");
 "readreallist"     comment => "Read and assign a list variable from a file of separated real numbers",
    association => a("returns data-type","rlist","is returned by function");
 "readstringarray"     comment => "Read an array of strings from a file and assign the dimension to a variable",
    association => a("returns data-type","int","is returned by function");
 "readstringlist"     comment => "Read and assign a list variable from a file of separated strings",
    association => a("returns data-type","slist","is returned by function");
 "readtcp"     comment => "Connect to tcp port, send string and assign result to variable",
    association => a("returns data-type","string","is returned by function");
 "regarray"     comment => "True if arg1 matches any item in the associative array with id=arg2",
    association => a("returns data-type","class","is returned by function");
 "regcmp"     comment => "True if arg2 is a regular expression matching arg1",
    association => a("returns data-type","class","is returned by function");
 "registryvalue"     comment => "Returns a value for an MS-Win registry key,value pair",
    association => a("returns data-type","string","is returned by function");
 "regline"     comment => "True if arg2 is a regular expression matching a line in file arg1",
    association => a("returns data-type","class","is returned by function");
 "reglist"     comment => "True if arg2 matches any item in the list with id=arg1",
    association => a("returns data-type","class","is returned by function");
 "regldap"     comment => "True if arg6 is a regular expression matching a value item in an ldap search",
    association => a("returns data-type","class","is returned by function");
 "remotescalar"     comment => "Read a scalar value from a remote cfengine server",
    association => a("returns data-type","string","is returned by function");
 "returnszero"     comment => "True if named shell command has exit status zero",
    association => a("returns data-type","class","is returned by function");
 "rrange"     comment => "Define a range of real numbers for cfengine internal use",
    association => a("returns data-type","rrange [real,real]","is returned by function");
 "selectservers"     comment => "Select tcp servers which respond correctly to a query and return their number, set array of names",
    association => a("returns data-type","int","is returned by function");
 "splayclass"     comment => "True if the first argument's time-slot has arrived, according to a policy in arg2",
    association => a("returns data-type","class","is returned by function");
 "splitstring"     comment => "Convert a string in arg1 into a list of max arg3 strings by splitting on a regular expression in arg2",
    association => a("returns data-type","slist","is returned by function");
 "strcmp"     comment => "True if the two strings match exactly",
    association => a("returns data-type","class","is returned by function");
 "usemodule"     comment => "Execute cfengine module script and set class if successful",
    association => a("returns data-type","class","is returned by function");
 "userexists"     comment => "True if user name or numerical id exists on this host",
    association => a("returns data-type","class","is returned by function");

topics:

bundles::
  "update";
contexts::
  "any";
promisers::

  "master_location"
      association => a("occurs in bundle","bundles::update","bundle contains promiser");
  "master_location"
      association => a("makes promise of type","promise_types::vars","promises have been made by");
  "master_location"
      association => a("makes promises","promise_update_cf_7","is a promise made by");
promise_types::
  "vars" association => a("is employed in bundle","update","employs promises of type");
promises::

"promise_update_cf_7"
   comment => "(Uncommented promise of type <i>vars</i> made by: master_location..)";
"promise_update_cf_7" association => a("is activated by class context","any","activates promises");
"promise_update_cf_7" association => a("is a promise of type","vars","has current exemplars");

 occurrences:
promise_update_cf_7::
"promises.cf.html#promise_update_cf_7"
   comment => "A promise of type vars made by: master_location",
   represents => { "any", "vars" };

any::
"promises.cf.html#promise_update_cf_7"
   represents => { "promise", "master_location", "vars" };

update::
"promises.cf.html#bundle_update"
   represents => { "bundle reference" };

string::
"promises.cf.html#promise_update_cf_7"
   represents => { "used in promise", "promise_update_cf_7" };


topics:

bundles::
  "update";
contexts::
  "any";
promisers::

  "/var/cfengine/inputs"
      association => a("occurs in bundle","bundles::update","bundle contains promiser");
  "/var/cfengine/inputs"
      association => a("makes promise of type","promise_types::files","promises have been made by");
  "/var/cfengine/inputs"
      association => a("makes promises","promise_update_cf_13","is a promise made by");
promise_types::
  "files" association => a("is employed in bundle","update","employs promises of type");
promises::

"promise_update_cf_13"
   comment => "(Uncommented promise of type <i>files</i> made by: /var/cfengine/inputs..)";
"promise_update_cf_13" association => a("is activated by class context","any","activates promises");
"promise_update_cf_13" association => a("is a promise of type","files","has current exemplars");

 occurrences:
promise_update_cf_13::
"promises.cf.html#promise_update_cf_13"
   comment => "A promise of type files made by: /var/cfengine/inputs",
   represents => { "any", "files" };

any::
"promises.cf.html#promise_update_cf_13"
   represents => { "promise", "/var/cfengine/inputs", "files" };

update::
"promises.cf.html#bundle_update"
   represents => { "bundle reference" };

perms::
"promises.cf.html#promise_update_cf_13"
   represents => { "used in promise", "promise_update_cf_13" };

mode::
"promises.cf.html#promise_update_cf_13"
   represents => { "used in promise", "promise_update_cf_13" };

copy_from::
"promises.cf.html#promise_update_cf_13"
   represents => { "used in promise", "promise_update_cf_13" };

source::
"promises.cf.html#promise_update_cf_13"
   represents => { "used in promise", "promise_update_cf_13" };

compare::
"promises.cf.html#promise_update_cf_13"
   represents => { "used in promise", "promise_update_cf_13" };

copy_backup::
"promises.cf.html#promise_update_cf_13"
   represents => { "used in promise", "promise_update_cf_13" };

verify::
"promises.cf.html#promise_update_cf_13"
   represents => { "used in promise", "promise_update_cf_13" };

depth_search::
"promises.cf.html#promise_update_cf_13"
   represents => { "used in promise", "promise_update_cf_13" };

depth::
"promises.cf.html#promise_update_cf_13"
   represents => { "used in promise", "promise_update_cf_13" };

classes::
"promises.cf.html#promise_update_cf_13"
   represents => { "used in promise", "promise_update_cf_13" };

promise_repaired::
"promises.cf.html#promise_update_cf_13"
   represents => { "used in promise", "promise_update_cf_13" };

action::
"promises.cf.html#promise_update_cf_13"
   represents => { "used in promise", "promise_update_cf_13" };

ifelapsed::
"promises.cf.html#promise_update_cf_13"
   represents => { "used in promise", "promise_update_cf_13" };

topics:
promises::  "promise_update_cf_13"
      association => a("has direct influence on","reload","is directly influenced by");
promisers::  "/var/cfengine/inputs"
      association => a("has direct influence on","reload","is directly influenced by");
topics:
promises::  "promise_update_cf_13"
      association => a("has direct influence on","reload","is directly influenced by");
promisers::  "/var/cfengine/inputs"
      association => a("has direct influence on","reload","is directly influenced by");
topics:
promises::  "promise_update_cf_13"
      association => a("has direct influence on","reload","is directly influenced by");
promisers::  "/var/cfengine/inputs"
      association => a("has direct influence on","reload","is directly influenced by");

topics:

bundles::
  "update";
contexts::
  "any";
promisers::

  "/var/cfengine/bin"
      association => a("occurs in bundle","bundles::update","bundle contains promiser");
  "/var/cfengine/bin"
      association => a("makes promise of type","promise_types::files","promises have been made by");
  "/var/cfengine/bin"
      association => a("makes promises","promise_update_cf_21","is a promise made by");
promise_types::
  "files" association => a("is employed in bundle","update","employs promises of type");
promises::

"promise_update_cf_21"
   comment => "(Uncommented promise of type <i>files</i> made by: /var/cfengine/bin..)";
"promise_update_cf_21" association => a("is activated by class context","any","activates promises");
"promise_update_cf_21" association => a("is a promise of type","files","has current exemplars");

 occurrences:
promise_update_cf_21::
"promises.cf.html#promise_update_cf_21"
   comment => "A promise of type files made by: /var/cfengine/bin",
   represents => { "any", "files" };

any::
"promises.cf.html#promise_update_cf_21"
   represents => { "promise", "/var/cfengine/bin", "files" };

update::
"promises.cf.html#bundle_update"
   represents => { "bundle reference" };

perms::
"promises.cf.html#promise_update_cf_21"
   represents => { "used in promise", "promise_update_cf_21" };

mode::
"promises.cf.html#promise_update_cf_21"
   represents => { "used in promise", "promise_update_cf_21" };

copy_from::
"promises.cf.html#promise_update_cf_21"
   represents => { "used in promise", "promise_update_cf_21" };

source::
"promises.cf.html#promise_update_cf_21"
   represents => { "used in promise", "promise_update_cf_21" };

compare::
"promises.cf.html#promise_update_cf_21"
   represents => { "used in promise", "promise_update_cf_21" };

copy_backup::
"promises.cf.html#promise_update_cf_21"
   represents => { "used in promise", "promise_update_cf_21" };

verify::
"promises.cf.html#promise_update_cf_21"
   represents => { "used in promise", "promise_update_cf_21" };

depth_search::
"promises.cf.html#promise_update_cf_21"
   represents => { "used in promise", "promise_update_cf_21" };

depth::
"promises.cf.html#promise_update_cf_21"
   represents => { "used in promise", "promise_update_cf_21" };

classes::
"promises.cf.html#promise_update_cf_21"
   represents => { "used in promise", "promise_update_cf_21" };

promise_repaired::
"promises.cf.html#promise_update_cf_21"
   represents => { "used in promise", "promise_update_cf_21" };

action::
"promises.cf.html#promise_update_cf_21"
   represents => { "used in promise", "promise_update_cf_21" };

ifelapsed::
"promises.cf.html#promise_update_cf_21"
   represents => { "used in promise", "promise_update_cf_21" };

topics:
promises::  "promise_update_cf_21"
      association => a("has direct influence on","reload","is directly influenced by");
promisers::  "/var/cfengine/bin"
      association => a("has direct influence on","reload","is directly influenced by");
topics:
promises::  "promise_update_cf_21"
      association => a("has direct influence on","reload","is directly influenced by");
promisers::  "/var/cfengine/bin"
      association => a("has direct influence on","reload","is directly influenced by");
topics:
promises::  "promise_update_cf_21"
      association => a("has direct influence on","reload","is directly influenced by");
promisers::  "/var/cfengine/bin"
      association => a("has direct influence on","reload","is directly influenced by");

topics:

bundles::
  "update";
contexts::
  "any";
promisers::

  "cf-serverd"
      association => a("occurs in bundle","bundles::update","bundle contains promiser");
  "cf-serverd"
      association => a("makes promise of type","promise_types::processes","promises have been made by");
  "cf-serverd"
      association => a("makes promises","promise_update_cf_29","is a promise made by");
promise_types::
  "processes" association => a("is employed in bundle","update","employs promises of type");
promises::

"promise_update_cf_29"
   comment => "(Uncommented promise of type <i>processes</i> made by: cf-serverd..)";
"promise_update_cf_29" association => a("is activated by class context","any","activates promises");
"promise_update_cf_29" association => a("is a promise of type","processes","has current exemplars");

 occurrences:
promise_update_cf_29::
"promises.cf.html#promise_update_cf_29"
   comment => "A promise of type processes made by: cf-serverd",
   represents => { "any", "processes" };

any::
"promises.cf.html#promise_update_cf_29"
   represents => { "promise", "cf-serverd", "processes" };

update::
"promises.cf.html#bundle_update"
   represents => { "bundle reference" };

restart_class::
"promises.cf.html#promise_update_cf_29"
   represents => { "used in promise", "promise_update_cf_29" };


topics:

bundles::
  "update";
contexts::
  "any";
promisers::

  "cf-monitord"
      association => a("occurs in bundle","bundles::update","bundle contains promiser");
  "cf-monitord"
      association => a("makes promise of type","promise_types::processes","promises have been made by");
  "cf-monitord"
      association => a("makes promises","promise_update_cf_30","is a promise made by");
promise_types::
  "processes" association => a("is employed in bundle","update","employs promises of type");
promises::

"promise_update_cf_30"
   comment => "(Uncommented promise of type <i>processes</i> made by: cf-monitord..)";
"promise_update_cf_30" association => a("is activated by class context","any","activates promises");
"promise_update_cf_30" association => a("is a promise of type","processes","has current exemplars");

 occurrences:
promise_update_cf_30::
"promises.cf.html#promise_update_cf_30"
   comment => "A promise of type processes made by: cf-monitord",
   represents => { "any", "processes" };

any::
"promises.cf.html#promise_update_cf_30"
   represents => { "promise", "cf-monitord", "processes" };

update::
"promises.cf.html#bundle_update"
   represents => { "bundle reference" };

restart_class::
"promises.cf.html#promise_update_cf_30"
   represents => { "used in promise", "promise_update_cf_30" };


topics:

bundles::
  "update";
contexts::
  "any";
promisers::

  "cf-execd"
      association => a("occurs in bundle","bundles::update","bundle contains promiser");
  "cf-execd"
      association => a("makes promise of type","promise_types::processes","promises have been made by");
  "cf-execd"
      association => a("makes promises","promise_update_cf_31","is a promise made by");
promise_types::
  "processes" association => a("is employed in bundle","update","employs promises of type");
promises::

"promise_update_cf_31"
   comment => "(Uncommented promise of type <i>processes</i> made by: cf-execd..)";
"promise_update_cf_31" association => a("is activated by class context","any","activates promises");
"promise_update_cf_31" association => a("is a promise of type","processes","has current exemplars");

 occurrences:
promise_update_cf_31::
"promises.cf.html#promise_update_cf_31"
   comment => "A promise of type processes made by: cf-execd",
   represents => { "any", "processes" };

any::
"promises.cf.html#promise_update_cf_31"
   represents => { "promise", "cf-execd", "processes" };

update::
"promises.cf.html#bundle_update"
   represents => { "bundle reference" };

restart_class::
"promises.cf.html#promise_update_cf_31"
   represents => { "used in promise", "promise_update_cf_31" };


topics:

bundles::
  "update";
contexts::
  "reload.start_server";
promisers::

  "/var/cfengine/bin/cf-serverd"
      association => a("occurs in bundle","bundles::update","bundle contains promiser");
  "/var/cfengine/bin/cf-serverd"
      association => a("makes promise of type","promise_types::commands","promises have been made by");
  "/var/cfengine/bin/cf-serverd"
      association => a("makes promises","promise_update_cf_37","is a promise made by");
promise_types::
  "commands" association => a("is employed in bundle","update","employs promises of type");
promises::

"promise_update_cf_37"
   comment => "(Uncommented promise of type <i>commands</i> made by: /var/cfengine/bin/cf-serv..)";
"promise_update_cf_37" association => a("is activated by class context","reload.start_server","activates promises");
"promise_update_cf_37" association => a("is a promise of type","commands","has current exemplars");

 occurrences:
promise_update_cf_37::
"promises.cf.html#promise_update_cf_37"
   comment => "A promise of type commands made by: /var/cfengine/bin/cf-serverd",
   represents => { "reload.start_server", "commands" };

reload_start_server::
"promises.cf.html#promise_update_cf_37"
   represents => { "promise", "/var/cfengine/bin/cf-serverd", "commands" };

update::
"promises.cf.html#bundle_update"
   represents => { "bundle reference" };


topics:

bundles::
  "update";
contexts::
  "reload.start_monitor";
promisers::

  "/var/cfengine/bin/cf-monitord"
      association => a("occurs in bundle","bundles::update","bundle contains promiser");
  "/var/cfengine/bin/cf-monitord"
      association => a("makes promise of type","promise_types::commands","promises have been made by");
  "/var/cfengine/bin/cf-monitord"
      association => a("makes promises","promise_update_cf_41","is a promise made by");
promise_types::
  "commands" association => a("is employed in bundle","update","employs promises of type");
promises::

"promise_update_cf_41"
   comment => "(Uncommented promise of type <i>commands</i> made by: /var/cfengine/bin/cf-moni..)";
"promise_update_cf_41" association => a("is activated by class context","reload.start_monitor","activates promises");
"promise_update_cf_41" association => a("is a promise of type","commands","has current exemplars");

 occurrences:
promise_update_cf_41::
"promises.cf.html#promise_update_cf_41"
   comment => "A promise of type commands made by: /var/cfengine/bin/cf-monitord",
   represents => { "reload.start_monitor", "commands" };

reload_start_monitor::
"promises.cf.html#promise_update_cf_41"
   represents => { "promise", "/var/cfengine/bin/cf-monitord", "commands" };

update::
"promises.cf.html#bundle_update"
   represents => { "bundle reference" };


topics:

bundles::
  "update";
contexts::
  "reload.start_exec";
promisers::

  "/var/cfengine/bin/cf-execd"
      association => a("occurs in bundle","bundles::update","bundle contains promiser");
  "/var/cfengine/bin/cf-execd"
      association => a("makes promise of type","promise_types::commands","promises have been made by");
  "/var/cfengine/bin/cf-execd"
      association => a("makes promises","promise_update_cf_45","is a promise made by");
promise_types::
  "commands" association => a("is employed in bundle","update","employs promises of type");
promises::

"promise_update_cf_45"
   comment => "(Uncommented promise of type <i>commands</i> made by: /var/cfengine/bin/cf-exec..)";
"promise_update_cf_45" association => a("is activated by class context","reload.start_exec","activates promises");
"promise_update_cf_45" association => a("is a promise of type","commands","has current exemplars");

 occurrences:
promise_update_cf_45::
"promises.cf.html#promise_update_cf_45"
   comment => "A promise of type commands made by: /var/cfengine/bin/cf-execd",
   represents => { "reload.start_exec", "commands" };

reload_start_exec::
"promises.cf.html#promise_update_cf_45"
   represents => { "promise", "/var/cfengine/bin/cf-execd", "commands" };

update::
"promises.cf.html#bundle_update"
   represents => { "bundle reference" };


topics:

bundles::
  "g";
contexts::
  "SuSE";
promisers::

  "crontab"
      association => a("occurs in bundle","bundles::g","bundle contains promiser");
  "crontab"
      association => a("makes promise of type","promise_types::vars","promises have been made by");
  "crontab"
      association => a("makes promises","promise_site_cf_13","is a promise made by");
promise_types::
  "vars" association => a("is employed in bundle","g","employs promises of type");
promises::

"promise_site_cf_13"
   comment => "(Uncommented promise of type <i>vars</i> made by: crontab..)";
"promise_site_cf_13" association => a("is activated by class context","SuSE","activates promises");
"promise_site_cf_13" association => a("is a promise of type","vars","has current exemplars");

 occurrences:
promise_site_cf_13::
"promises.cf.html#promise_site_cf_13"
   comment => "A promise of type vars made by: crontab",
   represents => { "SuSE", "vars" };

SuSE::
"promises.cf.html#promise_site_cf_13"
   represents => { "promise", "crontab", "vars" };

g::
"promises.cf.html#bundle_g"
   represents => { "bundle reference" };

string::
"promises.cf.html#promise_site_cf_13"
   represents => { "used in promise", "promise_site_cf_13" };


topics:

bundles::
  "g";
contexts::
  "!SuSE";
promisers::

  "crontab"
      association => a("occurs in bundle","bundles::g","bundle contains promiser");
  "crontab"
      association => a("makes promise of type","promise_types::vars","promises have been made by");
  "crontab"
      association => a("makes promises","promise_site_cf_17","is a promise made by");
promise_types::
  "vars" association => a("is employed in bundle","g","employs promises of type");
promises::

"promise_site_cf_17"
   comment => "(Uncommented promise of type <i>vars</i> made by: crontab..)";
"promise_site_cf_17" association => a("is activated by class context","!SuSE","activates promises");
"promise_site_cf_17" association => a("is a promise of type","vars","has current exemplars");

 occurrences:
promise_site_cf_17::
"promises.cf.html#promise_site_cf_17"
   comment => "A promise of type vars made by: crontab",
   represents => { "!SuSE", "vars" };

_SuSE::
"promises.cf.html#promise_site_cf_17"
   represents => { "promise", "crontab", "vars" };

g::
"promises.cf.html#bundle_g"
   represents => { "bundle reference" };

string::
"promises.cf.html#promise_site_cf_17"
   represents => { "used in promise", "promise_site_cf_17" };


topics:

bundles::
  "cfengine";
contexts::
  "any";
promisers::

  "cf2bits"
      association => a("occurs in bundle","bundles::cfengine","bundle contains promiser");
  "cf2bits"
      association => a("makes promise of type","promise_types::vars","promises have been made by");
  "cf2bits"
      association => a("makes promises","promise_site_cf_40","is a promise made by");
promise_types::
  "vars" association => a("is employed in bundle","cfengine","employs promises of type");
promises::

"promise_site_cf_40"
   comment => "(Uncommented promise of type <i>vars</i> made by: cf2bits..)";
"promise_site_cf_40" association => a("is activated by class context","any","activates promises");
"promise_site_cf_40" association => a("is a promise of type","vars","has current exemplars");

 occurrences:
promise_site_cf_40::
"promises.cf.html#promise_site_cf_40"
   comment => "A promise of type vars made by: cf2bits",
   represents => { "any", "vars" };

any::
"promises.cf.html#promise_site_cf_40"
   represents => { "promise", "cf2bits", "vars" };

cfengine::
"promises.cf.html#bundle_cfengine"
   represents => { "bundle reference" };

slist::
"promises.cf.html#promise_site_cf_40"
   represents => { "used in promise", "promise_site_cf_40" };


topics:

bundles::
  "cfengine";
contexts::
  "integrate_cfengine2";
promisers::

  "/var/cfengine/bin/cfagent"
      association => a("occurs in bundle","bundles::cfengine","bundle contains promiser");
  "/var/cfengine/bin/cfagent"
      association => a("makes promise of type","promise_types::commands","promises have been made by");
  "/var/cfengine/bin/cfagent"
      association => a("makes promises","promise_site_cf_48","is a promise made by");
promise_types::
  "commands" association => a("is employed in bundle","cfengine","employs promises of type");
promises::

"promise_site_cf_48"
   comment => "(Uncommented promise of type <i>commands</i> made by: /var/cfengine/bin/cfagent..)";
"promise_site_cf_48" association => a("is activated by class context","integrate_cfengine2","activates promises");
"promise_site_cf_48" association => a("is a promise of type","commands","has current exemplars");

 occurrences:
promise_site_cf_48::
"promises.cf.html#promise_site_cf_48"
   comment => "A promise of type commands made by: /var/cfengine/bin/cfagent",
   represents => { "integrate_cfengine2", "commands" };

integrate_cfengine2::
"promises.cf.html#promise_site_cf_48"
   represents => { "promise", "/var/cfengine/bin/cfagent", "commands" };

cfengine::
"promises.cf.html#bundle_cfengine"
   represents => { "bundle reference" };

action::
"promises.cf.html#promise_site_cf_48"
   represents => { "used in promise", "promise_site_cf_48" };

ifelapsed::
"promises.cf.html#promise_site_cf_48"
   represents => { "used in promise", "promise_site_cf_48" };

expireafter::
"promises.cf.html#promise_site_cf_48"
   represents => { "used in promise", "promise_site_cf_48" };

background::
"promises.cf.html#promise_site_cf_48"
   represents => { "used in promise", "promise_site_cf_48" };


topics:

bundles::
  "cfengine";
contexts::
  "any";
promisers::

  "/var/cfengine/inputs/.*"
      association => a("occurs in bundle","bundles::cfengine","bundle contains promiser");
  "/var/cfengine/inputs/.*"
      association => a("makes promise of type","promise_types::files","promises have been made by");
  "/var/cfengine/inputs/.*"
      association => a("makes promises","promise_site_cf_58","is a promise made by");
promise_types::
  "files" association => a("is employed in bundle","cfengine","employs promises of type");
promises::

"promise_site_cf_58"
   comment => "Check if there are still promises about cfengine 2 that need removing";
"promise_site_cf_58" association => a("is activated by class context","any","activates promises");
"promise_site_cf_58" association => a("is a promise of type","files","has current exemplars");

 occurrences:
promise_site_cf_58::
"promises.cf.html#promise_site_cf_58"
   comment => "Check if there are still promises about cfengine 2 that need removing",
   represents => { "any", "files" };

any::
"promises.cf.html#promise_site_cf_58"
   represents => { "promise", "/var/cfengine/inputs/.*", "files" };

cfengine::
"promises.cf.html#bundle_cfengine"
   represents => { "bundle reference" };

comment::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };

"Check if there are still promises about cfengine 2 that need removing"
   representation => "literal",

   represents => { "promise_site_cf_58" };
promise_site_cf_58::
"Check if there are still promises about cfengine 2 that need removing"
   representation => "literal",

   represents => { "comment" };
edit_line::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };

file_select::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };

leaf_name::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };

file_result::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };

action::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };

action_policy::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };

ifelapsed::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };


topics:

bundles::
  "cfengine";
contexts::
  "any";
promisers::

  "/var/cfengine/inputs/.*"
      association => a("occurs in bundle","bundles::cfengine","bundle contains promiser");
  "/var/cfengine/inputs/.*"
      association => a("makes promise of type","promise_types::files","promises have been made by");
  "/var/cfengine/inputs/.*"
      association => a("makes promises","promise_site_cf_58","is a promise made by");
promise_types::
  "files" association => a("is employed in bundle","cfengine","employs promises of type");
promises::

"promise_site_cf_58"
   comment => "Check if there are still promises about cfengine 2 that need removing";
"promise_site_cf_58" association => a("is activated by class context","any","activates promises");
"promise_site_cf_58" association => a("is a promise of type","files","has current exemplars");

 occurrences:
promise_site_cf_58::
"promises.cf.html#promise_site_cf_58"
   comment => "Check if there are still promises about cfengine 2 that need removing",
   represents => { "any", "files" };

any::
"promises.cf.html#promise_site_cf_58"
   represents => { "promise", "/var/cfengine/inputs/.*", "files" };

cfengine::
"promises.cf.html#bundle_cfengine"
   represents => { "bundle reference" };

comment::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };

"Check if there are still promises about cfengine 2 that need removing"
   representation => "literal",

   represents => { "promise_site_cf_58" };
promise_site_cf_58::
"Check if there are still promises about cfengine 2 that need removing"
   representation => "literal",

   represents => { "comment" };
edit_line::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };

file_select::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };

leaf_name::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };

file_result::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };

action::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };

action_policy::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };

ifelapsed::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };


topics:

bundles::
  "cfengine";
contexts::
  "any";
promisers::

  "/var/cfengine/inputs/.*"
      association => a("occurs in bundle","bundles::cfengine","bundle contains promiser");
  "/var/cfengine/inputs/.*"
      association => a("makes promise of type","promise_types::files","promises have been made by");
  "/var/cfengine/inputs/.*"
      association => a("makes promises","promise_site_cf_58","is a promise made by");
promise_types::
  "files" association => a("is employed in bundle","cfengine","employs promises of type");
promises::

"promise_site_cf_58"
   comment => "Check if there are still promises about cfengine 2 that need removing";
"promise_site_cf_58" association => a("is activated by class context","any","activates promises");
"promise_site_cf_58" association => a("is a promise of type","files","has current exemplars");

 occurrences:
promise_site_cf_58::
"promises.cf.html#promise_site_cf_58"
   comment => "Check if there are still promises about cfengine 2 that need removing",
   represents => { "any", "files" };

any::
"promises.cf.html#promise_site_cf_58"
   represents => { "promise", "/var/cfengine/inputs/.*", "files" };

cfengine::
"promises.cf.html#bundle_cfengine"
   represents => { "bundle reference" };

comment::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };

"Check if there are still promises about cfengine 2 that need removing"
   representation => "literal",

   represents => { "promise_site_cf_58" };
promise_site_cf_58::
"Check if there are still promises about cfengine 2 that need removing"
   representation => "literal",

   represents => { "comment" };
edit_line::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };

file_select::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };

leaf_name::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };

file_result::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };

action::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };

action_policy::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };

ifelapsed::
"promises.cf.html#promise_site_cf_58"
   represents => { "used in promise", "promise_site_cf_58" };


topics:

bundles::
  "cfengine";
contexts::
  "any";
promisers::

  "/var/spool/cron/tabs/root"
      association => a("occurs in bundle","bundles::cfengine","bundle contains promiser");
  "/var/spool/cron/tabs/root"
      association => a("makes promise of type","promise_types::files","promises have been made by");
  "/var/spool/cron/tabs/root"
      association => a("makes promises","promise_site_cf_66","is a promise made by");
promise_types::
  "files" association => a("is employed in bundle","cfengine","employs promises of type");
promises::

"promise_site_cf_66"
   comment => "(Uncommented promise of type <i>files</i> made by: /var/spool/cron/tabs/root..)";
"promise_site_cf_66" association => a("is activated by class context","any","activates promises");
"promise_site_cf_66" association => a("is a promise of type","files","has current exemplars");

 occurrences:
promise_site_cf_66::
"promises.cf.html#promise_site_cf_66"
   comment => "A promise of type files made by: /var/spool/cron/tabs/root",
   represents => { "any", "files" };

any::
"promises.cf.html#promise_site_cf_66"
   represents => { "promise", "/var/spool/cron/tabs/root", "files" };

cfengine::
"promises.cf.html#bundle_cfengine"
   represents => { "bundle reference" };

edit_line::
"promises.cf.html#promise_site_cf_66"
   represents => { "used in promise", "promise_site_cf_66" };


topics:

bundles::
  "cfengine";
contexts::
  "any";
promisers::

  "/dev/sr0"
      association => a("occurs in bundle","bundles::cfengine","bundle contains promiser");
  "/dev/sr0"
      association => a("makes promise of type","promise_types::files","promises have been made by");
  "/dev/sr0"
      association => a("makes promises","promise_site_cf_70","is a promise made by");
promise_types::
  "files" association => a("is employed in bundle","cfengine","employs promises of type");
promises::

"promise_site_cf_70"
   comment => "This is inaccessible in new suse after cd opened/closed";
"promise_site_cf_70" association => a("is activated by class context","any","activates promises");
"promise_site_cf_70" association => a("is a promise of type","files","has current exemplars");

 occurrences:
promise_site_cf_70::
"promises.cf.html#promise_site_cf_70"
   comment => "This is inaccessible in new suse after cd opened/closed",
   represents => { "any", "files" };

any::
"promises.cf.html#promise_site_cf_70"
   represents => { "promise", "/dev/sr0", "files" };

cfengine::
"promises.cf.html#bundle_cfengine"
   represents => { "bundle reference" };

comment::
"promises.cf.html#promise_site_cf_70"
   represents => { "used in promise", "promise_site_cf_70" };

"This is inaccessible in new suse after cd opened/closed"
   representation => "literal",

   represents => { "promise_site_cf_70" };
promise_site_cf_70::
"This is inaccessible in new suse after cd opened/closed"
   representation => "literal",

   represents => { "comment" };
perms::
"promises.cf.html#promise_site_cf_70"
   represents => { "used in promise", "promise_site_cf_70" };

owners::
"promises.cf.html#promise_site_cf_70"
   represents => { "used in promise", "promise_site_cf_70" };


topics:

bundles::
  "cfengine";
contexts::
  "exec_fix";
promisers::

  "cron"
      association => a("occurs in bundle","bundles::cfengine","bundle contains promiser");
  "cron"
      association => a("makes promise of type","promise_types::processes","promises have been made by");
  "cron"
      association => a("makes promises","promise_site_cf_77","is a promise made by");
promise_types::
  "processes" association => a("is employed in bundle","cfengine","employs promises of type");
promises::

"promise_site_cf_77"
   comment => "(Uncommented promise of type <i>processes</i> made by: cron..)";
"promise_site_cf_77" association => a("is activated by class context","exec_fix","activates promises");
"promise_site_cf_77" association => a("is a promise of type","processes","has current exemplars");

 occurrences:
promise_site_cf_77::
"promises.cf.html#promise_site_cf_77"
   comment => "A promise of type processes made by: cron",
   represents => { "exec_fix", "processes" };

exec_fix::
"promises.cf.html#promise_site_cf_77"
   represents => { "promise", "cron", "processes" };

cfengine::
"promises.cf.html#bundle_cfengine"
   represents => { "bundle reference" };

signals::
"promises.cf.html#promise_site_cf_77"
   represents => { "used in promise", "promise_site_cf_77" };


topics:

bundles::
  "main";
contexts::
  "any";
promisers::

  "component"
      association => a("occurs in bundle","bundles::main","bundle contains promiser");
  "component"
      association => a("makes promise of type","promise_types::vars","promises have been made by");
  "component"
      association => a("makes promises","promise_site_cf_90","is a promise made by");
promise_types::
  "vars" association => a("is employed in bundle","main","employs promises of type");
promises::

"promise_site_cf_90"
   comment => "(Uncommented promise of type <i>vars</i> made by: component..)";
"promise_site_cf_90" association => a("is activated by class context","any","activates promises");
"promise_site_cf_90" association => a("is a promise of type","vars","has current exemplars");

 occurrences:
promise_site_cf_90::
"promises.cf.html#promise_site_cf_90"
   comment => "A promise of type vars made by: component",
   represents => { "any", "vars" };

any::
"promises.cf.html#promise_site_cf_90"
   represents => { "promise", "component", "vars" };

main::
"promises.cf.html#bundle_main"
   represents => { "bundle reference" };

slist::
"promises.cf.html#promise_site_cf_90"
   represents => { "used in promise", "promise_site_cf_90" };


topics:

bundles::
  "main";
contexts::
  "!up_and_running";
promisers::

  "Laptop wakes up"
      association => a("occurs in bundle","bundles::main","bundle contains promiser");
  "Laptop wakes up"
      association => a("makes promise of type","promise_types::reports","promises have been made by");
  "Laptop wakes up"
      association => a("makes promises","promise_site_cf_98","is a promise made by");
promise_types::
  "reports" association => a("is employed in bundle","main","employs promises of type");
promises::

"promise_site_cf_98"
   comment => "(Uncommented promise of type <i>reports</i> made by: Laptop wakes up..)";
"promise_site_cf_98" association => a("is activated by class context","!up_and_running","activates promises");
"promise_site_cf_98" association => a("is a promise of type","reports","has current exemplars");

 occurrences:
promise_site_cf_98::
"promises.cf.html#promise_site_cf_98"
   comment => "A promise of type reports made by: Laptop wakes up",
   represents => { "!up_and_running", "reports" };

_up_and_running::
"promises.cf.html#promise_site_cf_98"
   represents => { "promise", "Laptop wakes up", "reports" };

main::
"promises.cf.html#bundle_main"
   represents => { "bundle reference" };

classes::
"promises.cf.html#promise_site_cf_98"
   represents => { "used in promise", "promise_site_cf_98" };

promise_repaired::
"promises.cf.html#promise_site_cf_98"
   represents => { "used in promise", "promise_site_cf_98" };

persist_time::
"promises.cf.html#promise_site_cf_98"
   represents => { "used in promise", "promise_site_cf_98" };

timer_policy::
"promises.cf.html#promise_site_cf_98"
   represents => { "used in promise", "promise_site_cf_98" };

topics:
promises::  "promise_site_cf_98"
      association => a("has direct influence on","up_and_running","is directly influenced by");
promisers::  "Laptop wakes up"
      association => a("has direct influence on","up_and_running","is directly influenced by");
contexts::  "!up_and_running"
      association => a("is activated by class context","up_and_running","activates promises");

topics:

bundles::
  "main";
contexts::
  "any";
promisers::

  "/etc/resolv.conf"
      association => a("occurs in bundle","bundles::main","bundle contains promiser");
  "/etc/resolv.conf"
      association => a("makes promise of type","promise_types::files","promises have been made by");
  "/etc/resolv.conf"
      association => a("makes promises","promise_site_cf_106","is a promise made by");
promise_types::
  "files" association => a("is employed in bundle","main","employs promises of type");
promises::

"promise_site_cf_106"
   comment => "(Uncommented promise of type <i>files</i> made by: /etc/resolv.conf..)";
"promise_site_cf_106" association => a("is activated by class context","any","activates promises");
"promise_site_cf_106" association => a("is a promise of type","files","has current exemplars");

 occurrences:
promise_site_cf_106::
"promises.cf.html#promise_site_cf_106"
   comment => "A promise of type files made by: /etc/resolv.conf",
   represents => { "any", "files" };

any::
"promises.cf.html#promise_site_cf_106"
   represents => { "promise", "/etc/resolv.conf", "files" };

main::
"promises.cf.html#bundle_main"
   represents => { "bundle reference" };

create::
"promises.cf.html#promise_site_cf_106"
   represents => { "used in promise", "promise_site_cf_106" };

edit_line::
"promises.cf.html#promise_site_cf_106"
   represents => { "used in promise", "promise_site_cf_106" };

edit_defaults::
"promises.cf.html#promise_site_cf_106"
   represents => { "used in promise", "promise_site_cf_106" };

empty_file_before_editing::
"promises.cf.html#promise_site_cf_106"
   represents => { "used in promise", "promise_site_cf_106" };

edit_backup::
"promises.cf.html#promise_site_cf_106"
   represents => { "used in promise", "promise_site_cf_106" };

max_file_size::
"promises.cf.html#promise_site_cf_106"
   represents => { "used in promise", "promise_site_cf_106" };


topics:

bundles::
  "main";
contexts::
  "any";
promisers::

  "cfenvd"
      association => a("occurs in bundle","bundles::main","bundle contains promiser");
  "cfenvd"
      association => a("makes promise of type","promise_types::processes","promises have been made by");
  "cfenvd"
      association => a("makes promises","promise_site_cf_120","is a promise made by");
promise_types::
  "processes" association => a("is employed in bundle","main","employs promises of type");
promises::

"promise_site_cf_120"
   comment => "(Uncommented promise of type <i>processes</i> made by: cfenvd..)";
"promise_site_cf_120" association => a("is activated by class context","any","activates promises");
"promise_site_cf_120" association => a("is a promise of type","processes","has current exemplars");

 occurrences:
promise_site_cf_120::
"promises.cf.html#promise_site_cf_120"
   comment => "A promise of type processes made by: cfenvd",
   represents => { "any", "processes" };

any::
"promises.cf.html#promise_site_cf_120"
   represents => { "promise", "cfenvd", "processes" };

main::
"promises.cf.html#bundle_main"
   represents => { "bundle reference" };

signals::
"promises.cf.html#promise_site_cf_120"
   represents => { "used in promise", "promise_site_cf_120" };


topics:

bundles::
  "main";
contexts::
  "any";
promisers::

  "cf-monitord"
      association => a("occurs in bundle","bundles::main","bundle contains promiser");
  "cf-monitord"
      association => a("makes promise of type","promise_types::processes","promises have been made by");
  "cf-monitord"
      association => a("makes promises","promise_site_cf_131","is a promise made by");
promise_types::
  "processes" association => a("is employed in bundle","main","employs promises of type");
promises::

"promise_site_cf_131"
   comment => "(Uncommented promise of type <i>processes</i> made by: cf-monitord..)";
"promise_site_cf_131" association => a("is activated by class context","any","activates promises");
"promise_site_cf_131" association => a("is a promise of type","processes","has current exemplars");

 occurrences:
promise_site_cf_131::
"promises.cf.html#promise_site_cf_131"
   comment => "A promise of type processes made by: cf-monitord",
   represents => { "any", "processes" };

any::
"promises.cf.html#promise_site_cf_131"
   represents => { "promise", "cf-monitord", "processes" };

main::
"promises.cf.html#bundle_main"
   represents => { "bundle reference" };

restart_class::
"promises.cf.html#promise_site_cf_131"
   represents => { "used in promise", "promise_site_cf_131" };


topics:

bundles::
  "main";
contexts::
  "any";
promisers::

  "cf-serverd"
      association => a("occurs in bundle","bundles::main","bundle contains promiser");
  "cf-serverd"
      association => a("makes promise of type","promise_types::processes","promises have been made by");
  "cf-serverd"
      association => a("makes promises","promise_site_cf_131","is a promise made by");
promise_types::
  "processes" association => a("is employed in bundle","main","employs promises of type");
promises::

"promise_site_cf_131"
   comment => "(Uncommented promise of type <i>processes</i> made by: cf-serverd..)";
"promise_site_cf_131" association => a("is activated by class context","any","activates promises");
"promise_site_cf_131" association => a("is a promise of type","processes","has current exemplars");

 occurrences:
promise_site_cf_131::
"promises.cf.html#promise_site_cf_131"
   comment => "A promise of type processes made by: cf-serverd",
   represents => { "any", "processes" };

any::
"promises.cf.html#promise_site_cf_131"
   represents => { "promise", "cf-serverd", "processes" };

main::
"promises.cf.html#bundle_main"
   represents => { "bundle reference" };

restart_class::
"promises.cf.html#promise_site_cf_131"
   represents => { "used in promise", "promise_site_cf_131" };


topics:

bundles::
  "main";
contexts::
  "any";
promisers::

  "/var/cfengine/bin/cf-monitord"
      association => a("occurs in bundle","bundles::main","bundle contains promiser");
  "/var/cfengine/bin/cf-monitord"
      association => a("makes promise of type","promise_types::commands","promises have been made by");
  "/var/cfengine/bin/cf-monitord"
      association => a("makes promises","promise_site_cf_139","is a promise made by");
promise_types::
  "commands" association => a("is employed in bundle","main","employs promises of type");
promises::

"promise_site_cf_139"
   comment => "(Uncommented promise of type <i>commands</i> made by: /var/cfengine/bin/cf-moni..)";
"promise_site_cf_139" association => a("is activated by class context","any","activates promises");
"promise_site_cf_139" association => a("is a promise of type","commands","has current exemplars");

 occurrences:
promise_site_cf_139::
"promises.cf.html#promise_site_cf_139"
   comment => "A promise of type commands made by: /var/cfengine/bin/cf-monitord",
   represents => { "any", "commands" };

any::
"promises.cf.html#promise_site_cf_139"
   represents => { "promise", "/var/cfengine/bin/cf-monitord", "commands" };

main::
"promises.cf.html#bundle_main"
   represents => { "bundle reference" };

ifvarclass::
"promises.cf.html#promise_site_cf_139"
   represents => { "used in promise", "promise_site_cf_139" };


topics:

bundles::
  "main";
contexts::
  "any";
promisers::

  "/var/cfengine/bin/cf-serverd"
      association => a("occurs in bundle","bundles::main","bundle contains promiser");
  "/var/cfengine/bin/cf-serverd"
      association => a("makes promise of type","promise_types::commands","promises have been made by");
  "/var/cfengine/bin/cf-serverd"
      association => a("makes promises","promise_site_cf_139","is a promise made by");
promise_types::
  "commands" association => a("is employed in bundle","main","employs promises of type");
promises::

"promise_site_cf_139"
   comment => "(Uncommented promise of type <i>commands</i> made by: /var/cfengine/bin/cf-serv..)";
"promise_site_cf_139" association => a("is activated by class context","any","activates promises");
"promise_site_cf_139" association => a("is a promise of type","commands","has current exemplars");

 occurrences:
promise_site_cf_139::
"promises.cf.html#promise_site_cf_139"
   comment => "A promise of type commands made by: /var/cfengine/bin/cf-serverd",
   represents => { "any", "commands" };

any::
"promises.cf.html#promise_site_cf_139"
   represents => { "promise", "/var/cfengine/bin/cf-serverd", "commands" };

main::
"promises.cf.html#bundle_main"
   represents => { "bundle reference" };

ifvarclass::
"promises.cf.html#promise_site_cf_139"
   represents => { "used in promise", "promise_site_cf_139" };


topics:

bundles::
  "main";
contexts::
  "any";
promisers::

  "/usr/bin/zypper -non-interactive patch"
      association => a("occurs in bundle","bundles::main","bundle contains promiser");
  "/usr/bin/zypper -non-interactive patch"
      association => a("makes promise of type","promise_types::commands","promises have been made by");
  "/usr/bin/zypper -non-interactive patch"
      association => a("makes promises","promise_site_cf_141","is a promise made by");
promise_types::
  "commands" association => a("is employed in bundle","main","employs promises of type");
promises::

"promise_site_cf_141"
   comment => "(Uncommented promise of type <i>commands</i> made by: /usr/bin/zypper -non-inte..)";
"promise_site_cf_141" association => a("is activated by class context","any","activates promises");
"promise_site_cf_141" association => a("is a promise of type","commands","has current exemplars");

 occurrences:
promise_site_cf_141::
"promises.cf.html#promise_site_cf_141"
   comment => "A promise of type commands made by: /usr/bin/zypper -non-interactive patch",
   represents => { "any", "commands" };

any::
"promises.cf.html#promise_site_cf_141"
   represents => { "promise", "/usr/bin/zypper -non-interactive patch", "commands" };

main::
"promises.cf.html#bundle_main"
   represents => { "bundle reference" };

action::
"promises.cf.html#promise_site_cf_141"
   represents => { "used in promise", "promise_site_cf_141" };

ifelapsed::
"promises.cf.html#promise_site_cf_141"
   represents => { "used in promise", "promise_site_cf_141" };

expireafter::
"promises.cf.html#promise_site_cf_141"
   represents => { "used in promise", "promise_site_cf_141" };


topics:

bundles::
  "main";
contexts::
  "Hr12";
promisers::

  "/usr/bin/updatedb --prunepaths=/windows"
      association => a("occurs in bundle","bundles::main","bundle contains promiser");
  "/usr/bin/updatedb --prunepaths=/windows"
      association => a("makes promise of type","promise_types::commands","promises have been made by");
  "/usr/bin/updatedb --prunepaths=/windows"
      association => a("makes promises","promise_site_cf_148","is a promise made by");
promise_types::
  "commands" association => a("is employed in bundle","main","employs promises of type");
promises::

"promise_site_cf_148"
   comment => "Update the locate database";
"promise_site_cf_148" association => a("is activated by class context","Hr12","activates promises");
"promise_site_cf_148" association => a("is a promise of type","commands","has current exemplars");

 occurrences:
promise_site_cf_148::
"promises.cf.html#promise_site_cf_148"
   comment => "Update the locate database",
   represents => { "Hr12", "commands" };

Hr12::
"promises.cf.html#promise_site_cf_148"
   represents => { "promise", "/usr/bin/updatedb --prunepaths=/windows", "commands" };

main::
"promises.cf.html#bundle_main"
   represents => { "bundle reference" };

comment::
"promises.cf.html#promise_site_cf_148"
   represents => { "used in promise", "promise_site_cf_148" };

"Update the locate database"
   representation => "literal",

   represents => { "promise_site_cf_148" };
promise_site_cf_148::
"Update the locate database"
   representation => "literal",

   represents => { "comment" };
action::
"promises.cf.html#promise_site_cf_148"
   represents => { "used in promise", "promise_site_cf_148" };

ifelapsed::
"promises.cf.html#promise_site_cf_148"
   represents => { "used in promise", "promise_site_cf_148" };

expireafter::
"promises.cf.html#promise_site_cf_148"
   represents => { "used in promise", "promise_site_cf_148" };

background::
"promises.cf.html#promise_site_cf_148"
   represents => { "used in promise", "promise_site_cf_148" };


topics:

bundles::
  "main";
contexts::
  "any";
promisers::

  "no match"
      association => a("occurs in bundle","bundles::main","bundle contains promiser");
  "no match"
      association => a("makes promise of type","promise_types::packages","promises have been made by");
  "no match"
      association => a("makes promises","promise_site_cf_157","is a promise made by");
promise_types::
  "packages" association => a("is employed in bundle","main","employs promises of type");
promises::

"promise_site_cf_157"
   comment => "Install patches";
"promise_site_cf_157" association => a("is activated by class context","any","activates promises");
"promise_site_cf_157" association => a("is a promise of type","packages","has current exemplars");

 occurrences:
promise_site_cf_157::
"promises.cf.html#promise_site_cf_157"
   comment => "Install patches",
   represents => { "any", "packages" };

any::
"promises.cf.html#promise_site_cf_157"
   represents => { "promise", "no match", "packages" };

main::
"promises.cf.html#bundle_main"
   represents => { "bundle reference" };

comment::
"promises.cf.html#promise_site_cf_157"
   represents => { "used in promise", "promise_site_cf_157" };

"Install patches"
   representation => "literal",

   represents => { "promise_site_cf_157" };
promise_site_cf_157::
"Install patches"
   representation => "literal",

   represents => { "comment" };
package_policy::
"promises.cf.html#promise_site_cf_157"
   represents => { "used in promise", "promise_site_cf_157" };

package_method::
"promises.cf.html#promise_site_cf_157"
   represents => { "used in promise", "promise_site_cf_157" };

package_changes::
"promises.cf.html#promise_site_cf_157"
   represents => { "used in promise", "promise_site_cf_157" };

package_list_command::
"promises.cf.html#promise_site_cf_157"
   represents => { "used in promise", "promise_site_cf_157" };

package_patch_list_command::
"promises.cf.html#promise_site_cf_157"
   represents => { "used in promise", "promise_site_cf_157" };

package_installed_regex::
"promises.cf.html#promise_site_cf_157"
   represents => { "used in promise", "promise_site_cf_157" };

package_list_name_regex::
"promises.cf.html#promise_site_cf_157"
   represents => { "used in promise", "promise_site_cf_157" };

package_list_version_regex::
"promises.cf.html#promise_site_cf_157"
   represents => { "used in promise", "promise_site_cf_157" };

package_list_arch_regex::
"promises.cf.html#promise_site_cf_157"
   represents => { "used in promise", "promise_site_cf_157" };

package_patch_installed_regex::
"promises.cf.html#promise_site_cf_157"
   represents => { "used in promise", "promise_site_cf_157" };

package_patch_name_regex::
"promises.cf.html#promise_site_cf_157"
   represents => { "used in promise", "promise_site_cf_157" };

package_patch_version_regex::
"promises.cf.html#promise_site_cf_157"
   represents => { "used in promise", "promise_site_cf_157" };

package_name_convention::
"promises.cf.html#promise_site_cf_157"
   represents => { "used in promise", "promise_site_cf_157" };

package_add_command::
"promises.cf.html#promise_site_cf_157"
   represents => { "used in promise", "promise_site_cf_157" };

package_delete_command::
"promises.cf.html#promise_site_cf_157"
   represents => { "used in promise", "promise_site_cf_157" };

package_update_command::
"promises.cf.html#promise_site_cf_157"
   represents => { "used in promise", "promise_site_cf_157" };

package_patch_command::
"promises.cf.html#promise_site_cf_157"
   represents => { "used in promise", "promise_site_cf_157" };


topics:

bundles::
  "garbage_collection";
contexts::
  "any";
promisers::

  "/var/cfengine/outputs"
      association => a("occurs in bundle","bundles::garbage_collection","bundle contains promiser");
  "/var/cfengine/outputs"
      association => a("makes promise of type","promise_types::files","promises have been made by");
  "/var/cfengine/outputs"
      association => a("makes promises","promise_site_cf_174","is a promise made by");
promise_types::
  "files" association => a("is employed in bundle","garbage_collection","employs promises of type");
promises::

"promise_site_cf_174"
   comment => "(Uncommented promise of type <i>files</i> made by: /var/cfengine/outputs..)";
"promise_site_cf_174" association => a("is activated by class context","any","activates promises");
"promise_site_cf_174" association => a("is a promise of type","files","has current exemplars");

 occurrences:
promise_site_cf_174::
"promises.cf.html#promise_site_cf_174"
   comment => "A promise of type files made by: /var/cfengine/outputs",
   represents => { "any", "files" };

any::
"promises.cf.html#promise_site_cf_174"
   represents => { "promise", "/var/cfengine/outputs", "files" };

garbage_collection::
"promises.cf.html#bundle_garbage_collection"
   represents => { "bundle reference" };

delete::
"promises.cf.html#promise_site_cf_174"
   represents => { "used in promise", "promise_site_cf_174" };

dirlinks::
"promises.cf.html#promise_site_cf_174"
   represents => { "used in promise", "promise_site_cf_174" };

rmdirs::
"promises.cf.html#promise_site_cf_174"
   represents => { "used in promise", "promise_site_cf_174" };

file_select::
"promises.cf.html#promise_site_cf_174"
   represents => { "used in promise", "promise_site_cf_174" };

mtime::
"promises.cf.html#promise_site_cf_174"
   represents => { "used in promise", "promise_site_cf_174" };

file_result::
"promises.cf.html#promise_site_cf_174"
   represents => { "used in promise", "promise_site_cf_174" };

depth_search::
"promises.cf.html#promise_site_cf_174"
   represents => { "used in promise", "promise_site_cf_174" };

depth::
"promises.cf.html#promise_site_cf_174"
   represents => { "used in promise", "promise_site_cf_174" };


topics:

bundles::
  "garbage_collection";
contexts::
  "any";
promisers::

  "/etc/resolv.conf\..*"
      association => a("occurs in bundle","bundles::garbage_collection","bundle contains promiser");
  "/etc/resolv.conf\..*"
      association => a("makes promise of type","promise_types::files","promises have been made by");
  "/etc/resolv.conf\..*"
      association => a("makes promises","promise_site_cf_180","is a promise made by");
promise_types::
  "files" association => a("is employed in bundle","garbage_collection","employs promises of type");
promises::

"promise_site_cf_180"
   comment => "(Uncommented promise of type <i>files</i> made by: /etc/resolv.conf\..*..)";
"promise_site_cf_180" association => a("is activated by class context","any","activates promises");
"promise_site_cf_180" association => a("is a promise of type","files","has current exemplars");

 occurrences:
promise_site_cf_180::
"promises.cf.html#promise_site_cf_180"
   comment => "A promise of type files made by: /etc/resolv.conf\..*",
   represents => { "any", "files" };

any::
"promises.cf.html#promise_site_cf_180"
   represents => { "promise", "/etc/resolv.conf\..*", "files" };

garbage_collection::
"promises.cf.html#bundle_garbage_collection"
   represents => { "bundle reference" };

delete::
"promises.cf.html#promise_site_cf_180"
   represents => { "used in promise", "promise_site_cf_180" };

dirlinks::
"promises.cf.html#promise_site_cf_180"
   represents => { "used in promise", "promise_site_cf_180" };

rmdirs::
"promises.cf.html#promise_site_cf_180"
   represents => { "used in promise", "promise_site_cf_180" };

file_select::
"promises.cf.html#promise_site_cf_180"
   represents => { "used in promise", "promise_site_cf_180" };

mtime::
"promises.cf.html#promise_site_cf_180"
   represents => { "used in promise", "promise_site_cf_180" };

file_result::
"promises.cf.html#promise_site_cf_180"
   represents => { "used in promise", "promise_site_cf_180" };


topics:

bundles::
  "watch";
contexts::
  "atlas";
promisers::

  "/var/cfengine/state/cf_rootprocs"
      association => a("occurs in bundle","bundles::watch","bundle contains promiser");
  "/var/cfengine/state/cf_rootprocs"
      association => a("makes promise of type","promise_types::measurements","promises have been made by");
  "/var/cfengine/state/cf_rootprocs"
      association => a("makes promises","monitor_self_watch","is a promise made by");
promise_types::
  "measurements" association => a("is employed in bundle","watch","employs promises of type");
promises::

"monitor_self_watch"
   comment => "(Uncommented promise of type <i>measurements</i> made by: /var/cfengine/state/cf_ro..)";
"monitor_self_watch" association => a("is activated by class context","atlas","activates promises");
"monitor_self_watch" association => a("is a promise of type","measurements","has current exemplars");

 occurrences:
monitor_self_watch::
"promises.cf.html#monitor_self_watch"
   comment => "A promise of type measurements made by: /var/cfengine/state/cf_rootprocs",
   represents => { "atlas", "measurements" };

atlas::
"promises.cf.html#monitor_self_watch"
   represents => { "promise", "/var/cfengine/state/cf_rootprocs", "measurements" };

watch::
"promises.cf.html#bundle_watch"
   represents => { "bundle reference" };

handle::
"promises.cf.html#monitor_self_watch"
   represents => { "used in promise", "monitor_self_watch" };

stream_type::
"promises.cf.html#monitor_self_watch"
   represents => { "used in promise", "monitor_self_watch" };

data_type::
"promises.cf.html#monitor_self_watch"
   represents => { "used in promise", "monitor_self_watch" };

history_type::
"promises.cf.html#monitor_self_watch"
   represents => { "used in promise", "monitor_self_watch" };

units::
"promises.cf.html#monitor_self_watch"
   represents => { "used in promise", "monitor_self_watch" };

match_value::
"promises.cf.html#monitor_self_watch"
   represents => { "used in promise", "monitor_self_watch" };

select_line_matching::
"promises.cf.html#monitor_self_watch"
   represents => { "used in promise", "monitor_self_watch" };

extraction_regex::
"promises.cf.html#monitor_self_watch"
   represents => { "used in promise", "monitor_self_watch" };


topics:

bundles::
  "watch";
contexts::
  "linux";
promisers::

  "/proc/meminfo"
      association => a("occurs in bundle","bundles::watch","bundle contains promiser");
  "/proc/meminfo"
      association => a("makes promise of type","promise_types::measurements","promises have been made by");
  "/proc/meminfo"
      association => a("makes promises","free_memory_watch","is a promise made by");
promise_types::
  "measurements" association => a("is employed in bundle","watch","employs promises of type");
promises::

"free_memory_watch"
   comment => "(Uncommented promise of type <i>measurements</i> made by: /proc/meminfo..)";
"free_memory_watch" association => a("is activated by class context","linux","activates promises");
"free_memory_watch" association => a("is a promise of type","measurements","has current exemplars");

 occurrences:
free_memory_watch::
"promises.cf.html#free_memory_watch"
   comment => "A promise of type measurements made by: /proc/meminfo",
   represents => { "linux", "measurements" };

linux::
"promises.cf.html#free_memory_watch"
   represents => { "promise", "/proc/meminfo", "measurements" };

watch::
"promises.cf.html#bundle_watch"
   represents => { "bundle reference" };

handle::
"promises.cf.html#free_memory_watch"
   represents => { "used in promise", "free_memory_watch" };

stream_type::
"promises.cf.html#free_memory_watch"
   represents => { "used in promise", "free_memory_watch" };

data_type::
"promises.cf.html#free_memory_watch"
   represents => { "used in promise", "free_memory_watch" };

history_type::
"promises.cf.html#free_memory_watch"
   represents => { "used in promise", "free_memory_watch" };

units::
"promises.cf.html#free_memory_watch"
   represents => { "used in promise", "free_memory_watch" };

match_value::
"promises.cf.html#free_memory_watch"
   represents => { "used in promise", "free_memory_watch" };

select_line_matching::
"promises.cf.html#free_memory_watch"
   represents => { "used in promise", "free_memory_watch" };

extraction_regex::
"promises.cf.html#free_memory_watch"
   represents => { "used in promise", "free_memory_watch" };


topics:

bundles::
  "watch";
contexts::
  "linux";
promisers::

  "/bin/df"
      association => a("occurs in bundle","bundles::watch","bundle contains promiser");
  "/bin/df"
      association => a("makes promise of type","promise_types::measurements","promises have been made by");
  "/bin/df"
      association => a("makes promises","free_disk_watch","is a promise made by");
promise_types::
  "measurements" association => a("is employed in bundle","watch","employs promises of type");
promises::

"free_disk_watch"
   comment => "(Uncommented promise of type <i>measurements</i> made by: /bin/df..)";
"free_disk_watch" association => a("is activated by class context","linux","activates promises");
"free_disk_watch" association => a("is a promise of type","measurements","has current exemplars");

 occurrences:
free_disk_watch::
"promises.cf.html#free_disk_watch"
   comment => "A promise of type measurements made by: /bin/df",
   represents => { "linux", "measurements" };

linux::
"promises.cf.html#free_disk_watch"
   represents => { "promise", "/bin/df", "measurements" };

watch::
"promises.cf.html#bundle_watch"
   represents => { "bundle reference" };

handle::
"promises.cf.html#free_disk_watch"
   represents => { "used in promise", "free_disk_watch" };

stream_type::
"promises.cf.html#free_disk_watch"
   represents => { "used in promise", "free_disk_watch" };

data_type::
"promises.cf.html#free_disk_watch"
   represents => { "used in promise", "free_disk_watch" };

history_type::
"promises.cf.html#free_disk_watch"
   represents => { "used in promise", "free_disk_watch" };

units::
"promises.cf.html#free_disk_watch"
   represents => { "used in promise", "free_disk_watch" };

match_value::
"promises.cf.html#free_disk_watch"
   represents => { "used in promise", "free_disk_watch" };

select_line_matching::
"promises.cf.html#free_disk_watch"
   represents => { "used in promise", "free_disk_watch" };

extraction_regex::
"promises.cf.html#free_disk_watch"
   represents => { "used in promise", "free_disk_watch" };

action::
"promises.cf.html#free_disk_watch"
   represents => { "used in promise", "free_disk_watch" };

ifelapsed::
"promises.cf.html#free_disk_watch"
   represents => { "used in promise", "free_disk_watch" };

expireafter::
"promises.cf.html#free_disk_watch"
   represents => { "used in promise", "free_disk_watch" };


topics:

bundles::
  "anomalies";
contexts::
  "any";
promisers::

  "sysdir"
      association => a("occurs in bundle","bundles::anomalies","bundle contains promiser");
  "sysdir"
      association => a("makes promise of type","promise_types::vars","promises have been made by");
  "sysdir"
      association => a("makes promises","promise_site_cf_274","is a promise made by");
promise_types::
  "vars" association => a("is employed in bundle","anomalies","employs promises of type");
promises::

"promise_site_cf_274"
   comment => "(Uncommented promise of type <i>vars</i> made by: sysdir..)";
"promise_site_cf_274" association => a("is activated by class context","any","activates promises");
"promise_site_cf_274" association => a("is a promise of type","vars","has current exemplars");

 occurrences:
promise_site_cf_274::
"promises.cf.html#promise_site_cf_274"
   comment => "A promise of type vars made by: sysdir",
   represents => { "any", "vars" };

any::
"promises.cf.html#promise_site_cf_274"
   represents => { "promise", "sysdir", "vars" };

anomalies::
"promises.cf.html#bundle_anomalies"
   represents => { "bundle reference" };

string::
"promises.cf.html#promise_site_cf_274"
   represents => { "used in promise", "promise_site_cf_274" };


topics:

bundles::
  "anomalies";
contexts::
  "any";
promisers::

  "files"
      association => a("occurs in bundle","bundles::anomalies","bundle contains promiser");
  "files"
      association => a("makes promise of type","promise_types::vars","promises have been made by");
  "files"
      association => a("makes promises","promise_site_cf_275","is a promise made by");
promise_types::
  "vars" association => a("is employed in bundle","anomalies","employs promises of type");
promises::

"promise_site_cf_275"
   comment => "(Uncommented promise of type <i>vars</i> made by: files..)";
"promise_site_cf_275" association => a("is activated by class context","any","activates promises");
"promise_site_cf_275" association => a("is a promise of type","vars","has current exemplars");

 occurrences:
promise_site_cf_275::
"promises.cf.html#promise_site_cf_275"
   comment => "A promise of type vars made by: files",
   represents => { "any", "vars" };

any::
"promises.cf.html#promise_site_cf_275"
   represents => { "promise", "files", "vars" };

anomalies::
"promises.cf.html#bundle_anomalies"
   represents => { "bundle reference" };

slist::
"promises.cf.html#promise_site_cf_275"
   represents => { "used in promise", "promise_site_cf_275" };


topics:

bundles::
  "anomalies";
contexts::
  "any";
promisers::

  "/var/cfengine/inputs/passwd"
      association => a("occurs in bundle","bundles::anomalies","bundle contains promiser");
  "/var/cfengine/inputs/passwd"
      association => a("makes promise of type","promise_types::files","promises have been made by");
  "/var/cfengine/inputs/passwd"
      association => a("makes promises","promise_site_cf_287","is a promise made by");
promise_types::
  "files" association => a("is employed in bundle","anomalies","employs promises of type");
promises::

"promise_site_cf_287"
   comment => "(Uncommented promise of type <i>files</i> made by: /var/cfengine/inputs/pass..)";
"promise_site_cf_287" association => a("is activated by class context","any","activates promises");
"promise_site_cf_287" association => a("is a promise of type","files","has current exemplars");

 occurrences:
promise_site_cf_287::
"promises.cf.html#promise_site_cf_287"
   comment => "A promise of type files made by: /var/cfengine/inputs/passwd",
   represents => { "any", "files" };

any::
"promises.cf.html#promise_site_cf_287"
   represents => { "promise", "/var/cfengine/inputs/passwd", "files" };

anomalies::
"promises.cf.html#bundle_anomalies"
   represents => { "bundle reference" };

copy_from::
"promises.cf.html#promise_site_cf_287"
   represents => { "used in promise", "promise_site_cf_287" };

source::
"promises.cf.html#promise_site_cf_287"
   represents => { "used in promise", "promise_site_cf_287" };

preserve::
"promises.cf.html#promise_site_cf_287"
   represents => { "used in promise", "promise_site_cf_287" };

copy_backup::
"promises.cf.html#promise_site_cf_287"
   represents => { "used in promise", "promise_site_cf_287" };


topics:

bundles::
  "anomalies";
contexts::
  "any";
promisers::

  "/var/cfengine/inputs/shadow"
      association => a("occurs in bundle","bundles::anomalies","bundle contains promiser");
  "/var/cfengine/inputs/shadow"
      association => a("makes promise of type","promise_types::files","promises have been made by");
  "/var/cfengine/inputs/shadow"
      association => a("makes promises","promise_site_cf_287","is a promise made by");
promise_types::
  "files" association => a("is employed in bundle","anomalies","employs promises of type");
promises::

"promise_site_cf_287"
   comment => "(Uncommented promise of type <i>files</i> made by: /var/cfengine/inputs/shad..)";
"promise_site_cf_287" association => a("is activated by class context","any","activates promises");
"promise_site_cf_287" association => a("is a promise of type","files","has current exemplars");

 occurrences:
promise_site_cf_287::
"promises.cf.html#promise_site_cf_287"
   comment => "A promise of type files made by: /var/cfengine/inputs/shadow",
   represents => { "any", "files" };

any::
"promises.cf.html#promise_site_cf_287"
   represents => { "promise", "/var/cfengine/inputs/shadow", "files" };

anomalies::
"promises.cf.html#bundle_anomalies"
   represents => { "bundle reference" };

copy_from::
"promises.cf.html#promise_site_cf_287"
   represents => { "used in promise", "promise_site_cf_287" };

source::
"promises.cf.html#promise_site_cf_287"
   represents => { "used in promise", "promise_site_cf_287" };

preserve::
"promises.cf.html#promise_site_cf_287"
   represents => { "used in promise", "promise_site_cf_287" };

copy_backup::
"promises.cf.html#promise_site_cf_287"
   represents => { "used in promise", "promise_site_cf_287" };


topics:

bundles::
  "anomalies";
contexts::
  "any";
promisers::

  "/tmp/passwd"
      association => a("occurs in bundle","bundles::anomalies","bundle contains promiser");
  "/tmp/passwd"
      association => a("makes promise of type","promise_types::files","promises have been made by");
  "/tmp/passwd"
      association => a("makes promises","promise_site_cf_293","is a promise made by");
promise_types::
  "files" association => a("is employed in bundle","anomalies","employs promises of type");
promises::

"promise_site_cf_293"
   comment => "(Uncommented promise of type <i>files</i> made by: /tmp/passwd..)";
"promise_site_cf_293" association => a("is activated by class context","any","activates promises");
"promise_site_cf_293" association => a("is a promise of type","files","has current exemplars");

 occurrences:
promise_site_cf_293::
"promises.cf.html#promise_site_cf_293"
   comment => "A promise of type files made by: /tmp/passwd",
   represents => { "any", "files" };

any::
"promises.cf.html#promise_site_cf_293"
   represents => { "promise", "/tmp/passwd", "files" };

anomalies::
"promises.cf.html#bundle_anomalies"
   represents => { "bundle reference" };

copy_from::
"promises.cf.html#promise_site_cf_293"
   represents => { "used in promise", "promise_site_cf_293" };

source::
"promises.cf.html#promise_site_cf_293"
   represents => { "used in promise", "promise_site_cf_293" };

preserve::
"promises.cf.html#promise_site_cf_293"
   represents => { "used in promise", "promise_site_cf_293" };

copy_backup::
"promises.cf.html#promise_site_cf_293"
   represents => { "used in promise", "promise_site_cf_293" };

ifvarclass::
"promises.cf.html#promise_site_cf_293"
   represents => { "used in promise", "promise_site_cf_293" };


topics:

bundles::
  "anomalies";
contexts::
  "any";
promisers::

  "/tmp/shadow"
      association => a("occurs in bundle","bundles::anomalies","bundle contains promiser");
  "/tmp/shadow"
      association => a("makes promise of type","promise_types::files","promises have been made by");
  "/tmp/shadow"
      association => a("makes promises","promise_site_cf_293","is a promise made by");
promise_types::
  "files" association => a("is employed in bundle","anomalies","employs promises of type");
promises::

"promise_site_cf_293"
   comment => "(Uncommented promise of type <i>files</i> made by: /tmp/shadow..)";
"promise_site_cf_293" association => a("is activated by class context","any","activates promises");
"promise_site_cf_293" association => a("is a promise of type","files","has current exemplars");

 occurrences:
promise_site_cf_293::
"promises.cf.html#promise_site_cf_293"
   comment => "A promise of type files made by: /tmp/shadow",
   represents => { "any", "files" };

any::
"promises.cf.html#promise_site_cf_293"
   represents => { "promise", "/tmp/shadow", "files" };

anomalies::
"promises.cf.html#bundle_anomalies"
   represents => { "bundle reference" };

copy_from::
"promises.cf.html#promise_site_cf_293"
   represents => { "used in promise", "promise_site_cf_293" };

source::
"promises.cf.html#promise_site_cf_293"
   represents => { "used in promise", "promise_site_cf_293" };

preserve::
"promises.cf.html#promise_site_cf_293"
   represents => { "used in promise", "promise_site_cf_293" };

copy_backup::
"promises.cf.html#promise_site_cf_293"
   represents => { "used in promise", "promise_site_cf_293" };

ifvarclass::
"promises.cf.html#promise_site_cf_293"
   represents => { "used in promise", "promise_site_cf_293" };


topics:

bundles::
  "anomalies";
contexts::
  "rootprocs_high_dev2";
promisers::

  "RootProc anomaly high 2 dev on $(mon.host) at Tue Jun 30 12:46:08 2009 
    measured value 100 av $(mon.average_rootprocs) pm $(mon.stddev_rootprocs)"
      association => a("occurs in bundle","bundles::anomalies","bundle contains promiser");
  "RootProc anomaly high 2 dev on $(mon.host) at Tue Jun 30 12:46:08 2009 
    measured value 100 av $(mon.average_rootprocs) pm $(mon.stddev_rootprocs)"
      association => a("makes promise of type","promise_types::reports","promises have been made by");
  "RootProc anomaly high 2 dev on $(mon.host) at Tue Jun 30 12:46:08 2009 
    measured value 100 av $(mon.average_rootprocs) pm $(mon.stddev_rootprocs)"
      association => a("makes promises","promise_site_cf_303","is a promise made by");
promise_types::
  "reports" association => a("is employed in bundle","anomalies","employs promises of type");
promises::

"promise_site_cf_303"
   comment => "(Uncommented promise of type <i>reports</i> made by: RootProc anomaly high 2 d..)";
"promise_site_cf_303" association => a("is activated by class context","rootprocs_high_dev2","activates promises");
"promise_site_cf_303" association => a("is a promise of type","reports","has current exemplars");

 occurrences:
promise_site_cf_303::
"promises.cf.html#promise_site_cf_303"
   comment => "A promise of type reports made by: RootProc anomaly high 2 dev on $(mon.host) at Tue Jun 30 12:46:08 2009 
    measured value 100 av $(mon.average_rootprocs) pm $(mon.stddev_rootprocs)",
   represents => { "rootprocs_high_dev2", "reports" };

rootprocs_high_dev2::
"promises.cf.html#promise_site_cf_303"
   represents => { "promise", "RootProc anomaly high 2 dev on $(mon.host) at Tue Jun 30 12:46:08 2009 
    measured value 100 av $(mon.average_rootprocs) pm $(mon.stddev_rootprocs)", "reports" };

anomalies::
"promises.cf.html#bundle_anomalies"
   represents => { "bundle reference" };

showstate::
"promises.cf.html#promise_site_cf_303"
   represents => { "used in promise", "promise_site_cf_303" };


topics:

bundles::
  "anomalies";
contexts::
  "entropy_www_in_high&anomaly_hosts.www_in_high_anomaly";
promisers::

  "HIGH ENTROPY Incoming www anomaly high anomaly dev!! on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(mon.average_www_in) pm $(mon.stddev_www_in)"
      association => a("occurs in bundle","bundles::anomalies","bundle contains promiser");
  "HIGH ENTROPY Incoming www anomaly high anomaly dev!! on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(mon.average_www_in) pm $(mon.stddev_www_in)"
      association => a("makes promise of type","promise_types::reports","promises have been made by");
  "HIGH ENTROPY Incoming www anomaly high anomaly dev!! on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(mon.average_www_in) pm $(mon.stddev_www_in)"
      association => a("makes promises","promise_site_cf_310","is a promise made by");
promise_types::
  "reports" association => a("is employed in bundle","anomalies","employs promises of type");
promises::

"promise_site_cf_310"
   comment => "(Uncommented promise of type <i>reports</i> made by: HIGH ENTROPY Incoming www..)";
"promise_site_cf_310" association => a("is activated by class context","entropy_www_in_high&anomaly_hosts.www_in_high_anomaly","activates promises");
"promise_site_cf_310" association => a("is a promise of type","reports","has current exemplars");

 occurrences:
promise_site_cf_310::
"promises.cf.html#promise_site_cf_310"
   comment => "A promise of type reports made by: HIGH ENTROPY Incoming www anomaly high anomaly dev!! on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(mon.average_www_in) pm $(mon.stddev_www_in)",
   represents => { "entropy_www_in_high&anomaly_hosts.www_in_high_anomaly", "reports" };

entropy_www_in_high_anomaly_hosts_www_in_high_anomaly::
"promises.cf.html#promise_site_cf_310"
   represents => { "promise", "HIGH ENTROPY Incoming www anomaly high anomaly dev!! on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(mon.average_www_in) pm $(mon.stddev_www_in)", "reports" };

anomalies::
"promises.cf.html#bundle_anomalies"
   represents => { "bundle reference" };

showstate::
"promises.cf.html#promise_site_cf_310"
   represents => { "used in promise", "promise_site_cf_310" };


topics:

bundles::
  "anomalies";
contexts::
  "entropy_www_in_low.anomaly_hosts.www_in_high_anomaly";
promisers::

  "LOW ENTROPY Incoming www anomaly high anomaly dev!! on $(mon.host) at Tue Jun 30 12:46:08 2009
     - measured value $(svalue_www_in) av $(average_www_in) pm $(stddev_www_in)"
      association => a("occurs in bundle","bundles::anomalies","bundle contains promiser");
  "LOW ENTROPY Incoming www anomaly high anomaly dev!! on $(mon.host) at Tue Jun 30 12:46:08 2009
     - measured value $(svalue_www_in) av $(average_www_in) pm $(stddev_www_in)"
      association => a("makes promise of type","promise_types::reports","promises have been made by");
  "LOW ENTROPY Incoming www anomaly high anomaly dev!! on $(mon.host) at Tue Jun 30 12:46:08 2009
     - measured value $(svalue_www_in) av $(average_www_in) pm $(stddev_www_in)"
      association => a("makes promises","promise_site_cf_317","is a promise made by");
promise_types::
  "reports" association => a("is employed in bundle","anomalies","employs promises of type");
promises::

"promise_site_cf_317"
   comment => "(Uncommented promise of type <i>reports</i> made by: LOW ENTROPY Incoming www ..)";
"promise_site_cf_317" association => a("is activated by class context","entropy_www_in_low.anomaly_hosts.www_in_high_anomaly","activates promises");
"promise_site_cf_317" association => a("is a promise of type","reports","has current exemplars");

 occurrences:
promise_site_cf_317::
"promises.cf.html#promise_site_cf_317"
   comment => "A promise of type reports made by: LOW ENTROPY Incoming www anomaly high anomaly dev!! on $(mon.host) at Tue Jun 30 12:46:08 2009
     - measured value $(svalue_www_in) av $(average_www_in) pm $(stddev_www_in)",
   represents => { "entropy_www_in_low.anomaly_hosts.www_in_high_anomaly", "reports" };

entropy_www_in_low_anomaly_hosts_www_in_high_anomaly::
"promises.cf.html#promise_site_cf_317"
   represents => { "promise", "LOW ENTROPY Incoming www anomaly high anomaly dev!! on $(mon.host) at Tue Jun 30 12:46:08 2009
     - measured value $(svalue_www_in) av $(average_www_in) pm $(stddev_www_in)", "reports" };

anomalies::
"promises.cf.html#bundle_anomalies"
   represents => { "bundle reference" };

showstate::
"promises.cf.html#promise_site_cf_317"
   represents => { "used in promise", "promise_site_cf_317" };


topics:

bundles::
  "anomalies";
contexts::
  "entropy_tcpsyn_in_low.anomaly_hosts.tcpsyn_in_high_dev2";
promisers::

  "Anomalous number of new TCP connections on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(mon.average_tcpsyn_in) pm $(mon.stddev_tcpsyn_in)"
      association => a("occurs in bundle","bundles::anomalies","bundle contains promiser");
  "Anomalous number of new TCP connections on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(mon.average_tcpsyn_in) pm $(mon.stddev_tcpsyn_in)"
      association => a("makes promise of type","promise_types::reports","promises have been made by");
  "Anomalous number of new TCP connections on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(mon.average_tcpsyn_in) pm $(mon.stddev_tcpsyn_in)"
      association => a("makes promises","promise_site_cf_324","is a promise made by");
promise_types::
  "reports" association => a("is employed in bundle","anomalies","employs promises of type");
promises::

"promise_site_cf_324"
   comment => "(Uncommented promise of type <i>reports</i> made by: Anomalous number of new T..)";
"promise_site_cf_324" association => a("is activated by class context","entropy_tcpsyn_in_low.anomaly_hosts.tcpsyn_in_high_dev2","activates promises");
"promise_site_cf_324" association => a("is a promise of type","reports","has current exemplars");

 occurrences:
promise_site_cf_324::
"promises.cf.html#promise_site_cf_324"
   comment => "A promise of type reports made by: Anomalous number of new TCP connections on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(mon.average_tcpsyn_in) pm $(mon.stddev_tcpsyn_in)",
   represents => { "entropy_tcpsyn_in_low.anomaly_hosts.tcpsyn_in_high_dev2", "reports" };

entropy_tcpsyn_in_low_anomaly_hosts_tcpsyn_in_high_dev2::
"promises.cf.html#promise_site_cf_324"
   represents => { "promise", "Anomalous number of new TCP connections on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(mon.average_tcpsyn_in) pm $(mon.stddev_tcpsyn_in)", "reports" };

anomalies::
"promises.cf.html#bundle_anomalies"
   represents => { "bundle reference" };

showstate::
"promises.cf.html#promise_site_cf_324"
   represents => { "used in promise", "promise_site_cf_324" };


topics:

bundles::
  "anomalies";
contexts::
  "entropy_dns_in_low.anomaly_hosts.dns_in_high_anomaly";
promisers::

  "Anomalous (3dev) incoming DNS packets on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(average_dns_in) pm $(mon.stddev_dns_in)"
      association => a("occurs in bundle","bundles::anomalies","bundle contains promiser");
  "Anomalous (3dev) incoming DNS packets on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(average_dns_in) pm $(mon.stddev_dns_in)"
      association => a("makes promise of type","promise_types::reports","promises have been made by");
  "Anomalous (3dev) incoming DNS packets on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(average_dns_in) pm $(mon.stddev_dns_in)"
      association => a("makes promises","promise_site_cf_331","is a promise made by");
promise_types::
  "reports" association => a("is employed in bundle","anomalies","employs promises of type");
promises::

"promise_site_cf_331"
   comment => "(Uncommented promise of type <i>reports</i> made by: Anomalous (3dev) incoming..)";
"promise_site_cf_331" association => a("is activated by class context","entropy_dns_in_low.anomaly_hosts.dns_in_high_anomaly","activates promises");
"promise_site_cf_331" association => a("is a promise of type","reports","has current exemplars");

 occurrences:
promise_site_cf_331::
"promises.cf.html#promise_site_cf_331"
   comment => "A promise of type reports made by: Anomalous (3dev) incoming DNS packets on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(average_dns_in) pm $(mon.stddev_dns_in)",
   represents => { "entropy_dns_in_low.anomaly_hosts.dns_in_high_anomaly", "reports" };

entropy_dns_in_low_anomaly_hosts_dns_in_high_anomaly::
"promises.cf.html#promise_site_cf_331"
   represents => { "promise", "Anomalous (3dev) incoming DNS packets on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(average_dns_in) pm $(mon.stddev_dns_in)", "reports" };

anomalies::
"promises.cf.html#bundle_anomalies"
   represents => { "bundle reference" };

showstate::
"promises.cf.html#promise_site_cf_331"
   represents => { "used in promise", "promise_site_cf_331" };


topics:

bundles::
  "anomalies";
contexts::
  "entropy_dns_in_low.anomaly_hosts.udp_in_high_dev2";
promisers::

  "Anomalous (2dev) incoming (non-DNS) UDP traffic on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(mon.average_udp_in) pm $(mon.stddev_udp_in)"
      association => a("occurs in bundle","bundles::anomalies","bundle contains promiser");
  "Anomalous (2dev) incoming (non-DNS) UDP traffic on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(mon.average_udp_in) pm $(mon.stddev_udp_in)"
      association => a("makes promise of type","promise_types::reports","promises have been made by");
  "Anomalous (2dev) incoming (non-DNS) UDP traffic on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(mon.average_udp_in) pm $(mon.stddev_udp_in)"
      association => a("makes promises","promise_site_cf_338","is a promise made by");
promise_types::
  "reports" association => a("is employed in bundle","anomalies","employs promises of type");
promises::

"promise_site_cf_338"
   comment => "(Uncommented promise of type <i>reports</i> made by: Anomalous (2dev) incoming..)";
"promise_site_cf_338" association => a("is activated by class context","entropy_dns_in_low.anomaly_hosts.udp_in_high_dev2","activates promises");
"promise_site_cf_338" association => a("is a promise of type","reports","has current exemplars");

 occurrences:
promise_site_cf_338::
"promises.cf.html#promise_site_cf_338"
   comment => "A promise of type reports made by: Anomalous (2dev) incoming (non-DNS) UDP traffic on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(mon.average_udp_in) pm $(mon.stddev_udp_in)",
   represents => { "entropy_dns_in_low.anomaly_hosts.udp_in_high_dev2", "reports" };

entropy_dns_in_low_anomaly_hosts_udp_in_high_dev2::
"promises.cf.html#promise_site_cf_338"
   represents => { "promise", "Anomalous (2dev) incoming (non-DNS) UDP traffic on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(mon.average_udp_in) pm $(mon.stddev_udp_in)", "reports" };

anomalies::
"promises.cf.html#bundle_anomalies"
   represents => { "bundle reference" };

showstate::
"promises.cf.html#promise_site_cf_338"
   represents => { "used in promise", "promise_site_cf_338" };


topics:

bundles::
  "anomalies";
contexts::
  "anomaly_hosts.icmp_in_high_anomaly.!entropy_icmp_in_high";
promisers::

  "Anomalous low entropy (3dev) incoming ICMP traffic on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(mon.average_icmp_in) pm $(mon.stddev_icmp_in)"
      association => a("occurs in bundle","bundles::anomalies","bundle contains promiser");
  "Anomalous low entropy (3dev) incoming ICMP traffic on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(mon.average_icmp_in) pm $(mon.stddev_icmp_in)"
      association => a("makes promise of type","promise_types::reports","promises have been made by");
  "Anomalous low entropy (3dev) incoming ICMP traffic on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(mon.average_icmp_in) pm $(mon.stddev_icmp_in)"
      association => a("makes promises","promise_site_cf_345","is a promise made by");
promise_types::
  "reports" association => a("is employed in bundle","anomalies","employs promises of type");
promises::

"promise_site_cf_345"
   comment => "(Uncommented promise of type <i>reports</i> made by: Anomalous low entropy (3d..)";
"promise_site_cf_345" association => a("is activated by class context","anomaly_hosts.icmp_in_high_anomaly.!entropy_icmp_in_high","activates promises");
"promise_site_cf_345" association => a("is a promise of type","reports","has current exemplars");

 occurrences:
promise_site_cf_345::
"promises.cf.html#promise_site_cf_345"
   comment => "A promise of type reports made by: Anomalous low entropy (3dev) incoming ICMP traffic on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(mon.average_icmp_in) pm $(mon.stddev_icmp_in)",
   represents => { "anomaly_hosts.icmp_in_high_anomaly.!entropy_icmp_in_high", "reports" };

anomaly_hosts_icmp_in_high_anomaly__entropy_icmp_in_high::
"promises.cf.html#promise_site_cf_345"
   represents => { "promise", "Anomalous low entropy (3dev) incoming ICMP traffic on $(mon.host) at Tue Jun 30 12:46:08 2009 
    - measured value 0 av $(mon.average_icmp_in) pm $(mon.stddev_icmp_in)", "reports" };

anomalies::
"promises.cf.html#bundle_anomalies"
   represents => { "bundle reference" };

showstate::
"promises.cf.html#promise_site_cf_345"
   represents => { "used in promise", "promise_site_cf_345" };


topics:

bundles::
  "access_rules";
contexts::
  "any";
promisers::

  "/home/mark/LapTop"
      association => a("occurs in bundle","bundles::access_rules","bundle contains promiser");
  "/home/mark/LapTop"
      association => a("makes promise of type","promise_types::access","promises have been made by");
  "/home/mark/LapTop"
      association => a("makes promises","promise_site_cf_358","is a promise made by");
promise_types::
  "access" association => a("is employed in bundle","access_rules","employs promises of type");
promises::

"promise_site_cf_358"
   comment => "(Uncommented promise of type <i>access</i> made by: /home/mark/LapTop..)";
"promise_site_cf_358" association => a("is activated by class context","any","activates promises");
"promise_site_cf_358" association => a("is a promise of type","access","has current exemplars");

 occurrences:
promise_site_cf_358::
"promises.cf.html#promise_site_cf_358"
   comment => "A promise of type access made by: /home/mark/LapTop",
   represents => { "any", "access" };

any::
"promises.cf.html#promise_site_cf_358"
   represents => { "promise", "/home/mark/LapTop", "access" };

access_rules::
"promises.cf.html#bundle_access_rules"
   represents => { "bundle reference" };

admit::
"promises.cf.html#promise_site_cf_358"
   represents => { "used in promise", "promise_site_cf_358" };


topics:

bundles::
  "access_rules";
contexts::
  "any";
promisers::

  "/home/mark/.cfagent/bin/cf-agent"
      association => a("occurs in bundle","bundles::access_rules","bundle contains promiser");
  "/home/mark/.cfagent/bin/cf-agent"
      association => a("makes promise of type","promise_types::access","promises have been made by");
  "/home/mark/.cfagent/bin/cf-agent"
      association => a("makes promises","promise_site_cf_362","is a promise made by");
promise_types::
  "access" association => a("is employed in bundle","access_rules","employs promises of type");
promises::

"promise_site_cf_362"
   comment => "(Uncommented promise of type <i>access</i> made by: /home/mark/.cfagent/bin/c..)";
"promise_site_cf_362" association => a("is activated by class context","any","activates promises");
"promise_site_cf_362" association => a("is a promise of type","access","has current exemplars");

 occurrences:
promise_site_cf_362::
"promises.cf.html#promise_site_cf_362"
   comment => "A promise of type access made by: /home/mark/.cfagent/bin/cf-agent",
   represents => { "any", "access" };

any::
"promises.cf.html#promise_site_cf_362"
   represents => { "promise", "/home/mark/.cfagent/bin/cf-agent", "access" };

access_rules::
"promises.cf.html#bundle_access_rules"
   represents => { "bundle reference" };

admit::
"promises.cf.html#promise_site_cf_362"
   represents => { "used in promise", "promise_site_cf_362" };


topics:

bundles::
  "access_rules";
contexts::
  "any";
promisers::

  ".*"
      association => a("occurs in bundle","bundles::access_rules","bundle contains promiser");
  ".*"
      association => a("makes promise of type","promise_types::roles","promises have been made by");
  ".*"
      association => a("makes promises","promise_site_cf_366","is a promise made by");
promise_types::
  "roles" association => a("is employed in bundle","access_rules","employs promises of type");
promises::

"promise_site_cf_366"
   comment => "(Uncommented promise of type <i>roles</i> made by: .*..)";
"promise_site_cf_366" association => a("is activated by class context","any","activates promises");
"promise_site_cf_366" association => a("is a promise of type","roles","has current exemplars");

 occurrences:
promise_site_cf_366::
"promises.cf.html#promise_site_cf_366"
   comment => "A promise of type roles made by: .*",
   represents => { "any", "roles" };

any::
"promises.cf.html#promise_site_cf_366"
   represents => { "promise", ".*", "roles" };

access_rules::
"promises.cf.html#bundle_access_rules"
   represents => { "bundle reference" };

authorize::
"promises.cf.html#promise_site_cf_366"
   represents => { "used in promise", "promise_site_cf_366" };


topics:

bundles::
  "resolver";
contexts::
  "any";
promisers::

  "search"
      association => a("occurs in bundle","bundles::resolver","bundle contains promiser");
  "search"
      association => a("makes promise of type","promise_types::vars","promises have been made by");
  "search"
      association => a("makes promises","promise_library_cf_105","is a promise made by");
promise_types::
  "vars" association => a("is employed in bundle","resolver","employs promises of type");
promises::

"promise_library_cf_105"
   comment => "(Uncommented promise of type <i>vars</i> made by: search..)";
"promise_library_cf_105" association => a("is activated by class context","any","activates promises");
"promise_library_cf_105" association => a("is a promise of type","vars","has current exemplars");

 occurrences:
promise_library_cf_105::
"promises.cf.html#promise_library_cf_105"
   comment => "A promise of type vars made by: search",
   represents => { "any", "vars" };

any::
"promises.cf.html#promise_library_cf_105"
   represents => { "promise", "search", "vars" };

resolver::
"promises.cf.html#bundle_resolver"
   represents => { "bundle reference" };

slist::
"promises.cf.html#promise_library_cf_105"
   represents => { "used in promise", "promise_library_cf_105" };


topics:

bundles::
  "resolver";
contexts::
  "any";
promisers::

  "NETCONFIG_DNS_STATIC_SEARCHLIST.*"
      association => a("occurs in bundle","bundles::resolver","bundle contains promiser");
  "NETCONFIG_DNS_STATIC_SEARCHLIST.*"
      association => a("makes promise of type","promise_types::field_edits","promises have been made by");
  "NETCONFIG_DNS_STATIC_SEARCHLIST.*"
      association => a("makes promises","promise_library_cf_113","is a promise made by");
promise_types::
  "field_edits" association => a("is employed in bundle","resolver","employs promises of type");
promises::

"promise_library_cf_113"
   comment => "(Uncommented promise of type <i>field_edits</i> made by: NETCONFIG_DNS_STATIC_SEAR..)";
"promise_library_cf_113" association => a("is activated by class context","any","activates promises");
"promise_library_cf_113" association => a("is a promise of type","field_edits","has current exemplars");

 occurrences:
promise_library_cf_113::
"promises.cf.html#promise_library_cf_113"
   comment => "A promise of type field_edits made by: NETCONFIG_DNS_STATIC_SEARCHLIST.*",
   represents => { "any", "field_edits" };

any::
"promises.cf.html#promise_library_cf_113"
   represents => { "promise", "NETCONFIG_DNS_STATIC_SEARCHLIST.*", "field_edits" };

resolver::
"promises.cf.html#bundle_resolver"
   represents => { "bundle reference" };

edit_field::
"promises.cf.html#promise_library_cf_113"
   represents => { "used in promise", "promise_library_cf_113" };

field_separator::
"promises.cf.html#promise_library_cf_113"
   represents => { "used in promise", "promise_library_cf_113" };

select_field::
"promises.cf.html#promise_library_cf_113"
   represents => { "used in promise", "promise_library_cf_113" };

value_separator::
"promises.cf.html#promise_library_cf_113"
   represents => { "used in promise", "promise_library_cf_113" };

field_value::
"promises.cf.html#promise_library_cf_113"
   represents => { "used in promise", "promise_library_cf_113" };

field_operation::
"promises.cf.html#promise_library_cf_113"
   represents => { "used in promise", "promise_library_cf_113" };

extend_fields::
"promises.cf.html#promise_library_cf_113"
   represents => { "used in promise", "promise_library_cf_113" };

allow_blank_fields::
"promises.cf.html#promise_library_cf_113"
   represents => { "used in promise", "promise_library_cf_113" };


topics:

bundles::
  "resolver";
contexts::
  "any";
promisers::

  "NETCONFIG_DNS_STATIC_SEARCHLIST.*"
      association => a("occurs in bundle","bundles::resolver","bundle contains promiser");
  "NETCONFIG_DNS_STATIC_SEARCHLIST.*"
      association => a("makes promise of type","promise_types::field_edits","promises have been made by");
  "NETCONFIG_DNS_STATIC_SEARCHLIST.*"
      association => a("makes promises","promise_library_cf_113","is a promise made by");
promise_types::
  "field_edits" association => a("is employed in bundle","resolver","employs promises of type");
promises::

"promise_library_cf_113"
   comment => "(Uncommented promise of type <i>field_edits</i> made by: NETCONFIG_DNS_STATIC_SEAR..)";
"promise_library_cf_113" association => a("is activated by class context","any","activates promises");
"promise_library_cf_113" association => a("is a promise of type","field_edits","has current exemplars");

 occurrences:
promise_library_cf_113::
"promises.cf.html#promise_library_cf_113"
   comment => "A promise of type field_edits made by: NETCONFIG_DNS_STATIC_SEARCHLIST.*",
   represents => { "any", "field_edits" };

any::
"promises.cf.html#promise_library_cf_113"
   represents => { "promise", "NETCONFIG_DNS_STATIC_SEARCHLIST.*", "field_edits" };

resolver::
"promises.cf.html#bundle_resolver"
   represents => { "bundle reference" };

edit_field::
"promises.cf.html#promise_library_cf_113"
   represents => { "used in promise", "promise_library_cf_113" };

field_separator::
"promises.cf.html#promise_library_cf_113"
   represents => { "used in promise", "promise_library_cf_113" };

select_field::
"promises.cf.html#promise_library_cf_113"
   represents => { "used in promise", "promise_library_cf_113" };

value_separator::
"promises.cf.html#promise_library_cf_113"
   represents => { "used in promise", "promise_library_cf_113" };

field_value::
"promises.cf.html#promise_library_cf_113"
   represents => { "used in promise", "promise_library_cf_113" };

field_operation::
"promises.cf.html#promise_library_cf_113"
   represents => { "used in promise", "promise_library_cf_113" };

extend_fields::
"promises.cf.html#promise_library_cf_113"
   represents => { "used in promise", "promise_library_cf_113" };

allow_blank_fields::
"promises.cf.html#promise_library_cf_113"
   represents => { "used in promise", "promise_library_cf_113" };


topics:

bundles::
  "DeleteLinesMatching";
contexts::
  "any";
promisers::

  "$(regex)"
      association => a("occurs in bundle","bundles::DeleteLinesMatching","bundle contains promiser");
  "$(regex)"
      association => a("makes promise of type","promise_types::delete_lines","promises have been made by");
  "$(regex)"
      association => a("makes promises","promise_library_cf_165","is a promise made by");
promise_types::
  "delete_lines" association => a("is employed in bundle","DeleteLinesMatching","employs promises of type");
promises::

"promise_library_cf_165"
   comment => "(Uncommented promise of type <i>delete_lines</i> made by: $(regex)..)";
"promise_library_cf_165" association => a("is activated by class context","any","activates promises");
"promise_library_cf_165" association => a("is a promise of type","delete_lines","has current exemplars");

 occurrences:
promise_library_cf_165::
"promises.cf.html#promise_library_cf_165"
   comment => "A promise of type delete_lines made by: $(regex)",
   represents => { "any", "delete_lines" };

any::
"promises.cf.html#promise_library_cf_165"
   represents => { "promise", "$(regex)", "delete_lines" };

DeleteLinesMatching::
"promises.cf.html#bundle_DeleteLinesMatching"
   represents => { "bundle reference" };

action::
"promises.cf.html#promise_library_cf_165"
   represents => { "used in promise", "promise_library_cf_165" };

action_policy::
"promises.cf.html#promise_library_cf_165"
   represents => { "used in promise", "promise_library_cf_165" };

ifelapsed::
"promises.cf.html#promise_library_cf_165"
   represents => { "used in promise", "promise_library_cf_165" };


topics:

bundles::
  "upgrade_cfexecd";
contexts::
  "exec_fix";
promisers::

  "0,5,10,15,20,25,30,35,40,45,50,55 * * * * /var/cfengine/bin/cf-execd -F"
      association => a("occurs in bundle","bundles::upgrade_cfexecd","bundle contains promiser");
  "0,5,10,15,20,25,30,35,40,45,50,55 * * * * /var/cfengine/bin/cf-execd -F"
      association => a("makes promise of type","promise_types::insert_lines","promises have been made by");
  "0,5,10,15,20,25,30,35,40,45,50,55 * * * * /var/cfengine/bin/cf-execd -F"
      association => a("makes promises","promise_library_cf_190","is a promise made by");
promise_types::
  "insert_lines" association => a("is employed in bundle","upgrade_cfexecd","employs promises of type");
promises::

"promise_library_cf_190"
   comment => "(Uncommented promise of type <i>insert_lines</i> made by: 0,5,10,15,20,25,30,35,40,..)";
"promise_library_cf_190" association => a("is activated by class context","exec_fix","activates promises");
"promise_library_cf_190" association => a("is a promise of type","insert_lines","has current exemplars");

 occurrences:
promise_library_cf_190::
"promises.cf.html#promise_library_cf_190"
   comment => "A promise of type insert_lines made by: 0,5,10,15,20,25,30,35,40,45,50,55 * * * * /var/cfengine/bin/cf-execd -F",
   represents => { "exec_fix", "insert_lines" };

exec_fix::
"promises.cf.html#promise_library_cf_190"
   represents => { "promise", "0,5,10,15,20,25,30,35,40,45,50,55 * * * * /var/cfengine/bin/cf-execd -F", "insert_lines" };

upgrade_cfexecd::
"promises.cf.html#bundle_upgrade_cfexecd"
   represents => { "bundle reference" };


topics:

bundles::
  "upgrade_cfexecd";
contexts::
  "any";
promisers::

  "cfexecd"
      association => a("occurs in bundle","bundles::upgrade_cfexecd","bundle contains promiser");
  "cfexecd"
      association => a("makes promise of type","promise_types::replace_patterns","promises have been made by");
  "cfexecd"
      association => a("makes promises","promise_library_cf_194","is a promise made by");
promise_types::
  "replace_patterns" association => a("is employed in bundle","upgrade_cfexecd","employs promises of type");
promises::

"promise_library_cf_194"
   comment => "(Uncommented promise of type <i>replace_patterns</i> made by: cfexecd..)";
"promise_library_cf_194" association => a("is activated by class context","any","activates promises");
"promise_library_cf_194" association => a("is a promise of type","replace_patterns","has current exemplars");

 occurrences:
promise_library_cf_194::
"promises.cf.html#promise_library_cf_194"
   comment => "A promise of type replace_patterns made by: cfexecd",
   represents => { "any", "replace_patterns" };

any::
"promises.cf.html#promise_library_cf_194"
   represents => { "promise", "cfexecd", "replace_patterns" };

upgrade_cfexecd::
"promises.cf.html#bundle_upgrade_cfexecd"
   represents => { "bundle reference" };

replace_with::
"promises.cf.html#promise_library_cf_194"
   represents => { "used in promise", "promise_library_cf_194" };

replace_value::
"promises.cf.html#promise_library_cf_194"
   represents => { "used in promise", "promise_library_cf_194" };

occurrences::
"promises.cf.html#promise_library_cf_194"
   represents => { "used in promise", "promise_library_cf_194" };


topics:

bundles::
  "upgrade_cfexecd";
contexts::
  "exec_fix";
promisers::

  "Added a 5 minute schedule to crontabs"
      association => a("occurs in bundle","bundles::upgrade_cfexecd","bundle contains promiser");
  "Added a 5 minute schedule to crontabs"
      association => a("makes promise of type","promise_types::reports","promises have been made by");
  "Added a 5 minute schedule to crontabs"
      association => a("makes promises","promise_library_cf_200","is a promise made by");
promise_types::
  "reports" association => a("is employed in bundle","upgrade_cfexecd","employs promises of type");
promises::

"promise_library_cf_200"
   comment => "(Uncommented promise of type <i>reports</i> made by: Added a 5 minute schedule..)";
"promise_library_cf_200" association => a("is activated by class context","exec_fix","activates promises");
"promise_library_cf_200" association => a("is a promise of type","reports","has current exemplars");

 occurrences:
promise_library_cf_200::
"promises.cf.html#promise_library_cf_200"
   comment => "A promise of type reports made by: Added a 5 minute schedule to crontabs",
   represents => { "exec_fix", "reports" };

exec_fix::
"promises.cf.html#promise_library_cf_200"
   represents => { "promise", "Added a 5 minute schedule to crontabs", "reports" };

upgrade_cfexecd::
"promises.cf.html#bundle_upgrade_cfexecd"
   represents => { "bundle reference" };


topics:

bundles::
  "laptop";
contexts::
  "any";
promisers::

  "mount_point"
      association => a("occurs in bundle","bundles::laptop","bundle contains promiser");
  "mount_point"
      association => a("makes promise of type","promise_types::vars","promises have been made by");
  "mount_point"
      association => a("makes promises","promise_laptop_cf_6","is a promise made by");
promise_types::
  "vars" association => a("is employed in bundle","laptop","employs promises of type");
promises::

"promise_laptop_cf_6"
   comment => "(Uncommented promise of type <i>vars</i> made by: mount_point..)";
"promise_laptop_cf_6" association => a("is activated by class context","any","activates promises");
"promise_laptop_cf_6" association => a("is a promise of type","vars","has current exemplars");

 occurrences:
promise_laptop_cf_6::
"promises.cf.html#promise_laptop_cf_6"
   comment => "A promise of type vars made by: mount_point",
   represents => { "any", "vars" };

any::
"promises.cf.html#promise_laptop_cf_6"
   represents => { "promise", "mount_point", "vars" };

laptop::
"promises.cf.html#bundle_laptop"
   represents => { "bundle reference" };

string::
"promises.cf.html#promise_laptop_cf_6"
   represents => { "used in promise", "promise_laptop_cf_6" };


topics:

bundles::
  "laptop";
contexts::
  "usb_backup_device_loaded";
promisers::

  "/media/disk-1/CfengineBackupDevice"
      association => a("occurs in bundle","bundles::laptop","bundle contains promiser");
  "/media/disk-1/CfengineBackupDevice"
      association => a("makes promise of type","promise_types::files","promises have been made by");
  "/media/disk-1/CfengineBackupDevice"
      association => a("makes promises","promise_laptop_cf_22","is a promise made by");
promise_types::
  "files" association => a("is employed in bundle","laptop","employs promises of type");
promises::

"promise_laptop_cf_22"
   comment => "(Uncommented promise of type <i>files</i> made by: /media/disk-1/CfengineBac..)";
"promise_laptop_cf_22" association => a("is activated by class context","usb_backup_device_loaded","activates promises");
"promise_laptop_cf_22" association => a("is a promise of type","files","has current exemplars");

 occurrences:
promise_laptop_cf_22::
"promises.cf.html#promise_laptop_cf_22"
   comment => "A promise of type files made by: /media/disk-1/CfengineBackupDevice",
   represents => { "usb_backup_device_loaded", "files" };

usb_backup_device_loaded::
"promises.cf.html#promise_laptop_cf_22"
   represents => { "promise", "/media/disk-1/CfengineBackupDevice", "files" };

laptop::
"promises.cf.html#bundle_laptop"
   represents => { "bundle reference" };

copy_from::
"promises.cf.html#promise_laptop_cf_22"
   represents => { "used in promise", "promise_laptop_cf_22" };

source::
"promises.cf.html#promise_laptop_cf_22"
   represents => { "used in promise", "promise_laptop_cf_22" };

copy_backup::
"promises.cf.html#promise_laptop_cf_22"
   represents => { "used in promise", "promise_laptop_cf_22" };

depth_search::
"promises.cf.html#promise_laptop_cf_22"
   represents => { "used in promise", "promise_laptop_cf_22" };

depth::
"promises.cf.html#promise_laptop_cf_22"
   represents => { "used in promise", "promise_laptop_cf_22" };

file_select::
"promises.cf.html#promise_laptop_cf_22"
   represents => { "used in promise", "promise_laptop_cf_22" };

leaf_name::
"promises.cf.html#promise_laptop_cf_22"
   represents => { "used in promise", "promise_laptop_cf_22" };

file_result::
"promises.cf.html#promise_laptop_cf_22"
   represents => { "used in promise", "promise_laptop_cf_22" };

action::
"promises.cf.html#promise_laptop_cf_22"
   represents => { "used in promise", "promise_laptop_cf_22" };

ifelapsed::
"promises.cf.html#promise_laptop_cf_22"
   represents => { "used in promise", "promise_laptop_cf_22" };

expireafter::
"promises.cf.html#promise_laptop_cf_22"
   represents => { "used in promise", "promise_laptop_cf_22" };

background::
"promises.cf.html#promise_laptop_cf_22"
   represents => { "used in promise", "promise_laptop_cf_22" };


topics:

bundles::
  "laptop";
contexts::
  "!usb_backup_device_loaded";
promisers::

  "/home/backup"
      association => a("occurs in bundle","bundles::laptop","bundle contains promiser");
  "/home/backup"
      association => a("makes promise of type","promise_types::files","promises have been made by");
  "/home/backup"
      association => a("makes promises","promise_laptop_cf_31","is a promise made by");
promise_types::
  "files" association => a("is employed in bundle","laptop","employs promises of type");
promises::

"promise_laptop_cf_31"
   comment => "(Uncommented promise of type <i>files</i> made by: /home/backup..)";
"promise_laptop_cf_31" association => a("is activated by class context","!usb_backup_device_loaded","activates promises");
"promise_laptop_cf_31" association => a("is a promise of type","files","has current exemplars");

 occurrences:
promise_laptop_cf_31::
"promises.cf.html#promise_laptop_cf_31"
   comment => "A promise of type files made by: /home/backup",
   represents => { "!usb_backup_device_loaded", "files" };

_usb_backup_device_loaded::
"promises.cf.html#promise_laptop_cf_31"
   represents => { "promise", "/home/backup", "files" };

laptop::
"promises.cf.html#bundle_laptop"
   represents => { "bundle reference" };

copy_from::
"promises.cf.html#promise_laptop_cf_31"
   represents => { "used in promise", "promise_laptop_cf_31" };

source::
"promises.cf.html#promise_laptop_cf_31"
   represents => { "used in promise", "promise_laptop_cf_31" };

copy_backup::
"promises.cf.html#promise_laptop_cf_31"
   represents => { "used in promise", "promise_laptop_cf_31" };

depth_search::
"promises.cf.html#promise_laptop_cf_31"
   represents => { "used in promise", "promise_laptop_cf_31" };

depth::
"promises.cf.html#promise_laptop_cf_31"
   represents => { "used in promise", "promise_laptop_cf_31" };

file_select::
"promises.cf.html#promise_laptop_cf_31"
   represents => { "used in promise", "promise_laptop_cf_31" };

leaf_name::
"promises.cf.html#promise_laptop_cf_31"
   represents => { "used in promise", "promise_laptop_cf_31" };

file_result::
"promises.cf.html#promise_laptop_cf_31"
   represents => { "used in promise", "promise_laptop_cf_31" };

action::
"promises.cf.html#promise_laptop_cf_31"
   represents => { "used in promise", "promise_laptop_cf_31" };

ifelapsed::
"promises.cf.html#promise_laptop_cf_31"
   represents => { "used in promise", "promise_laptop_cf_31" };

expireafter::
"promises.cf.html#promise_laptop_cf_31"
   represents => { "used in promise", "promise_laptop_cf_31" };

background::
"promises.cf.html#promise_laptop_cf_31"
   represents => { "used in promise", "promise_laptop_cf_31" };


topics:

bundles::
  "web_server";
contexts::
  "any";
promisers::

  "document_root"
      association => a("occurs in bundle","bundles::web_server","bundle contains promiser");
  "document_root"
      association => a("makes promise of type","promise_types::vars","promises have been made by");
  "document_root"
      association => a("makes promises","promise_webserver_cf_11","is a promise made by");
promise_types::
  "vars" association => a("is employed in bundle","web_server","employs promises of type");
promises::

"promise_webserver_cf_11"
   comment => "(Uncommented promise of type <i>vars</i> made by: document_root..)";
"promise_webserver_cf_11" association => a("is activated by class context","any","activates promises");
"promise_webserver_cf_11" association => a("is a promise of type","vars","has current exemplars");

 occurrences:
promise_webserver_cf_11::
"promises.cf.html#promise_webserver_cf_11"
   comment => "A promise of type vars made by: document_root",
   represents => { "any", "vars" };

any::
"promises.cf.html#promise_webserver_cf_11"
   represents => { "promise", "document_root", "vars" };

web_server::
"promises.cf.html#bundle_web_server"
   represents => { "bundle reference" };

string::
"promises.cf.html#promise_webserver_cf_11"
   represents => { "used in promise", "promise_webserver_cf_11" };


topics:

bundles::
  "web_server";
contexts::
  "any";
promisers::

  "site_http_conf"
      association => a("occurs in bundle","bundles::web_server","bundle contains promiser");
  "site_http_conf"
      association => a("makes promise of type","promise_types::vars","promises have been made by");
  "site_http_conf"
      association => a("makes promises","promise_webserver_cf_17","is a promise made by");
promise_types::
  "vars" association => a("is employed in bundle","web_server","employs promises of type");
promises::

"promise_webserver_cf_17"
   comment => "(Uncommented promise of type <i>vars</i> made by: site_http_conf..)";
"promise_webserver_cf_17" association => a("is activated by class context","any","activates promises");
"promise_webserver_cf_17" association => a("is a promise of type","vars","has current exemplars");

 occurrences:
promise_webserver_cf_17::
"promises.cf.html#promise_webserver_cf_17"
   comment => "A promise of type vars made by: site_http_conf",
   represents => { "any", "vars" };

any::
"promises.cf.html#promise_webserver_cf_17"
   represents => { "promise", "site_http_conf", "vars" };

web_server::
"promises.cf.html#bundle_web_server"
   represents => { "bundle reference" };

string::
"promises.cf.html#promise_webserver_cf_17"
   represents => { "used in promise", "promise_webserver_cf_17" };


topics:

bundles::
  "web_server";
contexts::
  "any";
promisers::

  "match_package"
      association => a("occurs in bundle","bundles::web_server","bundle contains promiser");
  "match_package"
      association => a("makes promise of type","promise_types::vars","promises have been made by");
  "match_package"
      association => a("makes promises","promise_webserver_cf_23","is a promise made by");
promise_types::
  "vars" association => a("is employed in bundle","web_server","employs promises of type");
promises::

"promise_webserver_cf_23"
   comment => "(Uncommented promise of type <i>vars</i> made by: match_package..)";
"promise_webserver_cf_23" association => a("is activated by class context","any","activates promises");
"promise_webserver_cf_23" association => a("is a promise of type","vars","has current exemplars");

 occurrences:
promise_webserver_cf_23::
"promises.cf.html#promise_webserver_cf_23"
   comment => "A promise of type vars made by: match_package",
   represents => { "any", "vars" };

any::
"promises.cf.html#promise_webserver_cf_23"
   represents => { "promise", "match_package", "vars" };

web_server::
"promises.cf.html#bundle_web_server"
   represents => { "bundle reference" };

slist::
"promises.cf.html#promise_webserver_cf_23"
   represents => { "used in promise", "promise_webserver_cf_23" };


topics:

bundles::
  "web_server";
contexts::
  "web_ok.on";
promisers::

  "apache2"
      association => a("occurs in bundle","bundles::web_server","bundle contains promiser");
  "apache2"
      association => a("makes promise of type","promise_types::processes","promises have been made by");
  "apache2"
      association => a("makes promises","promise_webserver_cf_38","is a promise made by");
promise_types::
  "processes" association => a("is employed in bundle","web_server","employs promises of type");
promises::

"promise_webserver_cf_38"
   comment => "(Uncommented promise of type <i>processes</i> made by: apache2..)";
"promise_webserver_cf_38" association => a("is activated by class context","web_ok.on","activates promises");
"promise_webserver_cf_38" association => a("is a promise of type","processes","has current exemplars");

 occurrences:
promise_webserver_cf_38::
"promises.cf.html#promise_webserver_cf_38"
   comment => "A promise of type processes made by: apache2",
   represents => { "web_ok.on", "processes" };

web_ok_on::
"promises.cf.html#promise_webserver_cf_38"
   represents => { "promise", "apache2", "processes" };

web_server::
"promises.cf.html#bundle_web_server"
   represents => { "bundle reference" };

restart_class::
"promises.cf.html#promise_webserver_cf_38"
   represents => { "used in promise", "promise_webserver_cf_38" };


topics:

bundles::
  "web_server";
contexts::
  "off";
promisers::

  "apache2"
      association => a("occurs in bundle","bundles::web_server","bundle contains promiser");
  "apache2"
      association => a("makes promise of type","promise_types::processes","promises have been made by");
  "apache2"
      association => a("makes promises","promise_webserver_cf_44","is a promise made by");
promise_types::
  "processes" association => a("is employed in bundle","web_server","employs promises of type");
promises::

"promise_webserver_cf_44"
   comment => "(Uncommented promise of type <i>processes</i> made by: apache2..)";
"promise_webserver_cf_44" association => a("is activated by class context","off","activates promises");
"promise_webserver_cf_44" association => a("is a promise of type","processes","has current exemplars");

 occurrences:
promise_webserver_cf_44::
"promises.cf.html#promise_webserver_cf_44"
   comment => "A promise of type processes made by: apache2",
   represents => { "off", "processes" };

off::
"promises.cf.html#promise_webserver_cf_44"
   represents => { "promise", "apache2", "processes" };

web_server::
"promises.cf.html#bundle_web_server"
   represents => { "bundle reference" };

process_stop::
"promises.cf.html#promise_webserver_cf_44"
   represents => { "used in promise", "promise_webserver_cf_44" };


topics:

bundles::
  "web_server";
contexts::
  "start_apache";
promisers::

  "/etc/init.d/apache2 restart"
      association => a("occurs in bundle","bundles::web_server","bundle contains promiser");
  "/etc/init.d/apache2 restart"
      association => a("makes promise of type","promise_types::commands","promises have been made by");
  "/etc/init.d/apache2 restart"
      association => a("makes promises","promise_webserver_cf_53","is a promise made by");
promise_types::
  "commands" association => a("is employed in bundle","web_server","employs promises of type");
promises::

"promise_webserver_cf_53"
   comment => "(Uncommented promise of type <i>commands</i> made by: /etc/init.d/apache2 resta..)";
"promise_webserver_cf_53" association => a("is activated by class context","start_apache","activates promises");
"promise_webserver_cf_53" association => a("is a promise of type","commands","has current exemplars");

 occurrences:
promise_webserver_cf_53::
"promises.cf.html#promise_webserver_cf_53"
   comment => "A promise of type commands made by: /etc/init.d/apache2 restart",
   represents => { "start_apache", "commands" };

start_apache::
"promises.cf.html#promise_webserver_cf_53"
   represents => { "promise", "/etc/init.d/apache2 restart", "commands" };

web_server::
"promises.cf.html#bundle_web_server"
   represents => { "bundle reference" };


topics:

bundles::
  "web_server";
contexts::
  "any";
promisers::

  "apache2"
      association => a("occurs in bundle","bundles::web_server","bundle contains promiser");
  "apache2"
      association => a("makes promise of type","promise_types::packages","promises have been made by");
  "apache2"
      association => a("makes promises","promise_webserver_cf_62","is a promise made by");
promise_types::
  "packages" association => a("is employed in bundle","web_server","employs promises of type");
promises::

"promise_webserver_cf_62"
   comment => "(Uncommented promise of type <i>packages</i> made by: apache2..)";
"promise_webserver_cf_62" association => a("is activated by class context","any","activates promises");
"promise_webserver_cf_62" association => a("is a promise of type","packages","has current exemplars");

 occurrences:
promise_webserver_cf_62::
"promises.cf.html#promise_webserver_cf_62"
   comment => "A promise of type packages made by: apache2",
   represents => { "any", "packages" };

any::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "promise", "apache2", "packages" };

web_server::
"promises.cf.html#bundle_web_server"
   represents => { "bundle reference" };

package_policy::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_method::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_changes::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_list_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_patch_list_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_installed_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_list_name_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_list_version_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_list_arch_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_patch_installed_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_patch_name_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_patch_version_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_name_convention::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_add_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_delete_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_update_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_patch_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

classes::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

promise_kept::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

promise_repaired::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

topics:
promises::  "promise_webserver_cf_62"
      association => a("has direct influence on","software_ok","is directly influenced by");
promisers::  "apache2"
      association => a("has direct influence on","software_ok","is directly influenced by");
topics:
promises::  "promise_webserver_cf_62"
      association => a("has direct influence on","software_ok","is directly influenced by");
promisers::  "apache2"
      association => a("has direct influence on","software_ok","is directly influenced by");

topics:

bundles::
  "web_server";
contexts::
  "any";
promisers::

  "apache2-mod_php5"
      association => a("occurs in bundle","bundles::web_server","bundle contains promiser");
  "apache2-mod_php5"
      association => a("makes promise of type","promise_types::packages","promises have been made by");
  "apache2-mod_php5"
      association => a("makes promises","promise_webserver_cf_62","is a promise made by");
promise_types::
  "packages" association => a("is employed in bundle","web_server","employs promises of type");
promises::

"promise_webserver_cf_62"
   comment => "(Uncommented promise of type <i>packages</i> made by: apache2-mod_php5..)";
"promise_webserver_cf_62" association => a("is activated by class context","any","activates promises");
"promise_webserver_cf_62" association => a("is a promise of type","packages","has current exemplars");

 occurrences:
promise_webserver_cf_62::
"promises.cf.html#promise_webserver_cf_62"
   comment => "A promise of type packages made by: apache2-mod_php5",
   represents => { "any", "packages" };

any::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "promise", "apache2-mod_php5", "packages" };

web_server::
"promises.cf.html#bundle_web_server"
   represents => { "bundle reference" };

package_policy::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_method::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_changes::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_list_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_patch_list_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_installed_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_list_name_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_list_version_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_list_arch_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_patch_installed_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_patch_name_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_patch_version_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_name_convention::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_add_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_delete_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_update_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_patch_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

classes::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

promise_kept::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

promise_repaired::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

topics:
promises::  "promise_webserver_cf_62"
      association => a("has direct influence on","software_ok","is directly influenced by");
promisers::  "apache2-mod_php5"
      association => a("has direct influence on","software_ok","is directly influenced by");
topics:
promises::  "promise_webserver_cf_62"
      association => a("has direct influence on","software_ok","is directly influenced by");
promisers::  "apache2-mod_php5"
      association => a("has direct influence on","software_ok","is directly influenced by");

topics:

bundles::
  "web_server";
contexts::
  "any";
promisers::

  "apache2-prefork"
      association => a("occurs in bundle","bundles::web_server","bundle contains promiser");
  "apache2-prefork"
      association => a("makes promise of type","promise_types::packages","promises have been made by");
  "apache2-prefork"
      association => a("makes promises","promise_webserver_cf_62","is a promise made by");
promise_types::
  "packages" association => a("is employed in bundle","web_server","employs promises of type");
promises::

"promise_webserver_cf_62"
   comment => "(Uncommented promise of type <i>packages</i> made by: apache2-prefork..)";
"promise_webserver_cf_62" association => a("is activated by class context","any","activates promises");
"promise_webserver_cf_62" association => a("is a promise of type","packages","has current exemplars");

 occurrences:
promise_webserver_cf_62::
"promises.cf.html#promise_webserver_cf_62"
   comment => "A promise of type packages made by: apache2-prefork",
   represents => { "any", "packages" };

any::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "promise", "apache2-prefork", "packages" };

web_server::
"promises.cf.html#bundle_web_server"
   represents => { "bundle reference" };

package_policy::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_method::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_changes::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_list_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_patch_list_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_installed_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_list_name_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_list_version_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_list_arch_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_patch_installed_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_patch_name_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_patch_version_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_name_convention::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_add_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_delete_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_update_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_patch_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

classes::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

promise_kept::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

promise_repaired::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

topics:
promises::  "promise_webserver_cf_62"
      association => a("has direct influence on","software_ok","is directly influenced by");
promisers::  "apache2-prefork"
      association => a("has direct influence on","software_ok","is directly influenced by");
topics:
promises::  "promise_webserver_cf_62"
      association => a("has direct influence on","software_ok","is directly influenced by");
promisers::  "apache2-prefork"
      association => a("has direct influence on","software_ok","is directly influenced by");

topics:

bundles::
  "web_server";
contexts::
  "any";
promisers::

  "php5"
      association => a("occurs in bundle","bundles::web_server","bundle contains promiser");
  "php5"
      association => a("makes promise of type","promise_types::packages","promises have been made by");
  "php5"
      association => a("makes promises","promise_webserver_cf_62","is a promise made by");
promise_types::
  "packages" association => a("is employed in bundle","web_server","employs promises of type");
promises::

"promise_webserver_cf_62"
   comment => "(Uncommented promise of type <i>packages</i> made by: php5..)";
"promise_webserver_cf_62" association => a("is activated by class context","any","activates promises");
"promise_webserver_cf_62" association => a("is a promise of type","packages","has current exemplars");

 occurrences:
promise_webserver_cf_62::
"promises.cf.html#promise_webserver_cf_62"
   comment => "A promise of type packages made by: php5",
   represents => { "any", "packages" };

any::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "promise", "php5", "packages" };

web_server::
"promises.cf.html#bundle_web_server"
   represents => { "bundle reference" };

package_policy::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_method::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_changes::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_list_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_patch_list_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_installed_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_list_name_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_list_version_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_list_arch_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_patch_installed_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_patch_name_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_patch_version_regex::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_name_convention::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_add_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_delete_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_update_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

package_patch_command::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

classes::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

promise_kept::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

promise_repaired::
"promises.cf.html#promise_webserver_cf_62"
   represents => { "used in promise", "promise_webserver_cf_62" };

topics:
promises::  "promise_webserver_cf_62"
      association => a("has direct influence on","software_ok","is directly influenced by");
promisers::  "php5"
      association => a("has direct influence on","software_ok","is directly influenced by");
topics:
promises::  "promise_webserver_cf_62"
      association => a("has direct influence on","software_ok","is directly influenced by");
promisers::  "php5"
      association => a("has direct influence on","software_ok","is directly influenced by");

topics:

bundles::
  "web_server";
contexts::
  "software_ok";
promisers::

  "/etc/sysconfig/apache2"
      association => a("occurs in bundle","bundles::web_server","bundle contains promiser");
  "/etc/sysconfig/apache2"
      association => a("makes promise of type","promise_types::files","promises have been made by");
  "/etc/sysconfig/apache2"
      association => a("makes promises","promise_webserver_cf_74","is a promise made by");
promise_types::
  "files" association => a("is employed in bundle","web_server","employs promises of type");
promises::

"promise_webserver_cf_74"
   comment => "(Uncommented promise of type <i>files</i> made by: /etc/sysconfig/apache2..)";
"promise_webserver_cf_74" association => a("is activated by class context","software_ok","activates promises");
"promise_webserver_cf_74" association => a("is a promise of type","files","has current exemplars");

 occurrences:
promise_webserver_cf_74::
"promises.cf.html#promise_webserver_cf_74"
   comment => "A promise of type files made by: /etc/sysconfig/apache2",
   represents => { "software_ok", "files" };

software_ok::
"promises.cf.html#promise_webserver_cf_74"
   represents => { "promise", "/etc/sysconfig/apache2", "files" };

web_server::
"promises.cf.html#bundle_web_server"
   represents => { "bundle reference" };

edit_line::
"promises.cf.html#promise_webserver_cf_74"
   represents => { "used in promise", "promise_webserver_cf_74" };

classes::
"promises.cf.html#promise_webserver_cf_74"
   represents => { "used in promise", "promise_webserver_cf_74" };

promise_kept::
"promises.cf.html#promise_webserver_cf_74"
   represents => { "used in promise", "promise_webserver_cf_74" };

promise_repaired::
"promises.cf.html#promise_webserver_cf_74"
   represents => { "used in promise", "promise_webserver_cf_74" };

topics:
promises::  "promise_webserver_cf_74"
      association => a("has direct influence on","web_ok","is directly influenced by");
promisers::  "/etc/sysconfig/apache2"
      association => a("has direct influence on","web_ok","is directly influenced by");
contexts::  "software_ok"
      association => a("is activated by class context","web_ok","activates promises");

topics:

bundles::
  "web_server";
contexts::
  "!software_ok.on";
promisers::

  "The web server software could not be installed"
      association => a("occurs in bundle","bundles::web_server","bundle contains promiser");
  "The web server software could not be installed"
      association => a("makes promise of type","promise_types::reports","promises have been made by");
  "The web server software could not be installed"
      association => a("makes promises","promise_webserver_cf_83","is a promise made by");
promise_types::
  "reports" association => a("is employed in bundle","web_server","employs promises of type");
promises::

"promise_webserver_cf_83"
   comment => "(Uncommented promise of type <i>reports</i> made by: The web server software c..)";
"promise_webserver_cf_83" association => a("is activated by class context","!software_ok.on","activates promises");
"promise_webserver_cf_83" association => a("is a promise of type","reports","has current exemplars");

 occurrences:
promise_webserver_cf_83::
"promises.cf.html#promise_webserver_cf_83"
   comment => "A promise of type reports made by: The web server software could not be installed",
   represents => { "!software_ok.on", "reports" };

_software_ok_on::
"promises.cf.html#promise_webserver_cf_83"
   represents => { "promise", "The web server software could not be installed", "reports" };

web_server::
"promises.cf.html#bundle_web_server"
   represents => { "bundle reference" };


topics:

bundles::
  "fixapache";
contexts::
  "any";
promisers::

  "add_modules"
      association => a("occurs in bundle","bundles::fixapache","bundle contains promiser");
  "add_modules"
      association => a("makes promise of type","promise_types::vars","promises have been made by");
  "add_modules"
      association => a("makes promises","promise_webserver_cf_102","is a promise made by");
promise_types::
  "vars" association => a("is employed in bundle","fixapache","employs promises of type");
promises::

"promise_webserver_cf_102"
   comment => "(Uncommented promise of type <i>vars</i> made by: add_modules..)";
"promise_webserver_cf_102" association => a("is activated by class context","any","activates promises");
"promise_webserver_cf_102" association => a("is a promise of type","vars","has current exemplars");

 occurrences:
promise_webserver_cf_102::
"promises.cf.html#promise_webserver_cf_102"
   comment => "A promise of type vars made by: add_modules",
   represents => { "any", "vars" };

any::
"promises.cf.html#promise_webserver_cf_102"
   represents => { "promise", "add_modules", "vars" };

fixapache::
"promises.cf.html#bundle_fixapache"
   represents => { "bundle reference" };

slist::
"promises.cf.html#promise_webserver_cf_102"
   represents => { "used in promise", "promise_webserver_cf_102" };


topics:

bundles::
  "fixapache";
contexts::
  "any";
promisers::

  "del_modules"
      association => a("occurs in bundle","bundles::fixapache","bundle contains promiser");
  "del_modules"
      association => a("makes promise of type","promise_types::vars","promises have been made by");
  "del_modules"
      association => a("makes promises","promise_webserver_cf_106","is a promise made by");
promise_types::
  "vars" association => a("is employed in bundle","fixapache","employs promises of type");
promises::

"promise_webserver_cf_106"
   comment => "(Uncommented promise of type <i>vars</i> made by: del_modules..)";
"promise_webserver_cf_106" association => a("is activated by class context","any","activates promises");
"promise_webserver_cf_106" association => a("is a promise of type","vars","has current exemplars");

 occurrences:
promise_webserver_cf_106::
"promises.cf.html#promise_webserver_cf_106"
   comment => "A promise of type vars made by: del_modules",
   represents => { "any", "vars" };

any::
"promises.cf.html#promise_webserver_cf_106"
   represents => { "promise", "del_modules", "vars" };

fixapache::
"promises.cf.html#bundle_fixapache"
   represents => { "bundle reference" };

slist::
"promises.cf.html#promise_webserver_cf_106"
   represents => { "used in promise", "promise_webserver_cf_106" };


topics:

bundles::
  "fixapache";
contexts::
  "any";
promisers::

  "APACHE_CONF_INCLUDE_FILES=\"/home/mark/cfengine-inputs/httpd.conf\""
      association => a("occurs in bundle","bundles::fixapache","bundle contains promiser");
  "APACHE_CONF_INCLUDE_FILES=\"/home/mark/cfengine-inputs/httpd.conf\""
      association => a("makes promise of type","promise_types::insert_lines","promises have been made by");
  "APACHE_CONF_INCLUDE_FILES=\"/home/mark/cfengine-inputs/httpd.conf\""
      association => a("makes promises","promise_webserver_cf_115","is a promise made by");
promise_types::
  "insert_lines" association => a("is employed in bundle","fixapache","employs promises of type");
promises::

"promise_webserver_cf_115"
   comment => "(Uncommented promise of type <i>insert_lines</i> made by: APACHE_CONF_INCLUDE_FILES..)";
"promise_webserver_cf_115" association => a("is activated by class context","any","activates promises");
"promise_webserver_cf_115" association => a("is a promise of type","insert_lines","has current exemplars");

 occurrences:
promise_webserver_cf_115::
"promises.cf.html#promise_webserver_cf_115"
   comment => "A promise of type insert_lines made by: APACHE_CONF_INCLUDE_FILES=\"/home/mark/cfengine-inputs/httpd.conf\"",
   represents => { "any", "insert_lines" };

any::
"promises.cf.html#promise_webserver_cf_115"
   represents => { "promise", "APACHE_CONF_INCLUDE_FILES=\"/home/mark/cfengine-inputs/httpd.conf\"", "insert_lines" };

fixapache::
"promises.cf.html#bundle_fixapache"
   represents => { "bundle reference" };


topics:

bundles::
  "fixapache";
contexts::
  "any";
promisers::

  "APACHE_MODULES=.*"
      association => a("occurs in bundle","bundles::fixapache","bundle contains promiser");
  "APACHE_MODULES=.*"
      association => a("makes promise of type","promise_types::field_edits","promises have been made by");
  "APACHE_MODULES=.*"
      association => a("makes promises","promise_webserver_cf_128","is a promise made by");
promise_types::
  "field_edits" association => a("is employed in bundle","fixapache","employs promises of type");
promises::

"promise_webserver_cf_128"
   comment => "(Uncommented promise of type <i>field_edits</i> made by: APACHE_MODULES=.*..)";
"promise_webserver_cf_128" association => a("is activated by class context","any","activates promises");
"promise_webserver_cf_128" association => a("is a promise of type","field_edits","has current exemplars");

 occurrences:
promise_webserver_cf_128::
"promises.cf.html#promise_webserver_cf_128"
   comment => "A promise of type field_edits made by: APACHE_MODULES=.*",
   represents => { "any", "field_edits" };

any::
"promises.cf.html#promise_webserver_cf_128"
   represents => { "promise", "APACHE_MODULES=.*", "field_edits" };

fixapache::
"promises.cf.html#bundle_fixapache"
   represents => { "bundle reference" };

edit_field::
"promises.cf.html#promise_webserver_cf_128"
   represents => { "used in promise", "promise_webserver_cf_128" };

field_separator::
"promises.cf.html#promise_webserver_cf_128"
   represents => { "used in promise", "promise_webserver_cf_128" };

select_field::
"promises.cf.html#promise_webserver_cf_128"
   represents => { "used in promise", "promise_webserver_cf_128" };

value_separator::
"promises.cf.html#promise_webserver_cf_128"
   represents => { "used in promise", "promise_webserver_cf_128" };

field_value::
"promises.cf.html#promise_webserver_cf_128"
   represents => { "used in promise", "promise_webserver_cf_128" };

field_operation::
"promises.cf.html#promise_webserver_cf_128"
   represents => { "used in promise", "promise_webserver_cf_128" };

extend_fields::
"promises.cf.html#promise_webserver_cf_128"
   represents => { "used in promise", "promise_webserver_cf_128" };

allow_blank_fields::
"promises.cf.html#promise_webserver_cf_128"
   represents => { "used in promise", "promise_webserver_cf_128" };


topics:

bundles::
  "fixapache";
contexts::
  "any";
promisers::

  "APACHE_MODULES=.*"
      association => a("occurs in bundle","bundles::fixapache","bundle contains promiser");
  "APACHE_MODULES=.*"
      association => a("makes promise of type","promise_types::field_edits","promises have been made by");
  "APACHE_MODULES=.*"
      association => a("makes promises","promise_webserver_cf_135","is a promise made by");
promise_types::
  "field_edits" association => a("is employed in bundle","fixapache","employs promises of type");
promises::

"promise_webserver_cf_135"
   comment => "(Uncommented promise of type <i>field_edits</i> made by: APACHE_MODULES=.*..)";
"promise_webserver_cf_135" association => a("is activated by class context","any","activates promises");
"promise_webserver_cf_135" association => a("is a promise of type","field_edits","has current exemplars");

 occurrences:
promise_webserver_cf_135::
"promises.cf.html#promise_webserver_cf_135"
   comment => "A promise of type field_edits made by: APACHE_MODULES=.*",
   represents => { "any", "field_edits" };

any::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "promise", "APACHE_MODULES=.*", "field_edits" };

fixapache::
"promises.cf.html#bundle_fixapache"
   represents => { "bundle reference" };

edit_field::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

field_separator::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

select_field::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

value_separator::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

field_value::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

field_operation::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

extend_fields::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

allow_blank_fields::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };


topics:

bundles::
  "fixapache";
contexts::
  "any";
promisers::

  "APACHE_MODULES=.*"
      association => a("occurs in bundle","bundles::fixapache","bundle contains promiser");
  "APACHE_MODULES=.*"
      association => a("makes promise of type","promise_types::field_edits","promises have been made by");
  "APACHE_MODULES=.*"
      association => a("makes promises","promise_webserver_cf_135","is a promise made by");
promise_types::
  "field_edits" association => a("is employed in bundle","fixapache","employs promises of type");
promises::

"promise_webserver_cf_135"
   comment => "(Uncommented promise of type <i>field_edits</i> made by: APACHE_MODULES=.*..)";
"promise_webserver_cf_135" association => a("is activated by class context","any","activates promises");
"promise_webserver_cf_135" association => a("is a promise of type","field_edits","has current exemplars");

 occurrences:
promise_webserver_cf_135::
"promises.cf.html#promise_webserver_cf_135"
   comment => "A promise of type field_edits made by: APACHE_MODULES=.*",
   represents => { "any", "field_edits" };

any::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "promise", "APACHE_MODULES=.*", "field_edits" };

fixapache::
"promises.cf.html#bundle_fixapache"
   represents => { "bundle reference" };

edit_field::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

field_separator::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

select_field::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

value_separator::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

field_value::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

field_operation::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

extend_fields::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

allow_blank_fields::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };


topics:

bundles::
  "fixapache";
contexts::
  "any";
promisers::

  "APACHE_MODULES=.*"
      association => a("occurs in bundle","bundles::fixapache","bundle contains promiser");
  "APACHE_MODULES=.*"
      association => a("makes promise of type","promise_types::field_edits","promises have been made by");
  "APACHE_MODULES=.*"
      association => a("makes promises","promise_webserver_cf_135","is a promise made by");
promise_types::
  "field_edits" association => a("is employed in bundle","fixapache","employs promises of type");
promises::

"promise_webserver_cf_135"
   comment => "(Uncommented promise of type <i>field_edits</i> made by: APACHE_MODULES=.*..)";
"promise_webserver_cf_135" association => a("is activated by class context","any","activates promises");
"promise_webserver_cf_135" association => a("is a promise of type","field_edits","has current exemplars");

 occurrences:
promise_webserver_cf_135::
"promises.cf.html#promise_webserver_cf_135"
   comment => "A promise of type field_edits made by: APACHE_MODULES=.*",
   represents => { "any", "field_edits" };

any::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "promise", "APACHE_MODULES=.*", "field_edits" };

fixapache::
"promises.cf.html#bundle_fixapache"
   represents => { "bundle reference" };

edit_field::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

field_separator::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

select_field::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

value_separator::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

field_value::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

field_operation::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

extend_fields::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

allow_blank_fields::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };


topics:

bundles::
  "fixapache";
contexts::
  "any";
promisers::

  "APACHE_MODULES=.*"
      association => a("occurs in bundle","bundles::fixapache","bundle contains promiser");
  "APACHE_MODULES=.*"
      association => a("makes promise of type","promise_types::field_edits","promises have been made by");
  "APACHE_MODULES=.*"
      association => a("makes promises","promise_webserver_cf_135","is a promise made by");
promise_types::
  "field_edits" association => a("is employed in bundle","fixapache","employs promises of type");
promises::

"promise_webserver_cf_135"
   comment => "(Uncommented promise of type <i>field_edits</i> made by: APACHE_MODULES=.*..)";
"promise_webserver_cf_135" association => a("is activated by class context","any","activates promises");
"promise_webserver_cf_135" association => a("is a promise of type","field_edits","has current exemplars");

 occurrences:
promise_webserver_cf_135::
"promises.cf.html#promise_webserver_cf_135"
   comment => "A promise of type field_edits made by: APACHE_MODULES=.*",
   represents => { "any", "field_edits" };

any::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "promise", "APACHE_MODULES=.*", "field_edits" };

fixapache::
"promises.cf.html#bundle_fixapache"
   represents => { "bundle reference" };

edit_field::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

field_separator::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

select_field::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

value_separator::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

field_value::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

field_operation::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

extend_fields::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };

allow_blank_fields::
"promises.cf.html#promise_webserver_cf_135"
   represents => { "used in promise", "promise_webserver_cf_135" };


topics:

bundles::
  "setup_knowledge";
contexts::
  "any";
promisers::

  "doc_root"
      association => a("occurs in bundle","bundles::setup_knowledge","bundle contains promiser");
  "doc_root"
      association => a("makes promise of type","promise_types::vars","promises have been made by");
  "doc_root"
      association => a("makes promises","promise_knowledge_cf_12","is a promise made by");
promise_types::
  "vars" association => a("is employed in bundle","setup_knowledge","employs promises of type");
promises::

"promise_knowledge_cf_12"
   comment => "(Uncommented promise of type <i>vars</i> made by: doc_root..)";
"promise_knowledge_cf_12" association => a("is activated by class context","any","activates promises");
"promise_knowledge_cf_12" association => a("is a promise of type","vars","has current exemplars");

 occurrences:
promise_knowledge_cf_12::
"promises.cf.html#promise_knowledge_cf_12"
   comment => "A promise of type vars made by: doc_root",
   represents => { "any", "vars" };

any::
"promises.cf.html#promise_knowledge_cf_12"
   represents => { "promise", "doc_root", "vars" };

setup_knowledge::
"promises.cf.html#bundle_setup_knowledge"
   represents => { "bundle reference" };

string::
"promises.cf.html#promise_knowledge_cf_12"
   represents => { "used in promise", "promise_knowledge_cf_12" };


topics:

bundles::
  "setup_knowledge";
contexts::
  "any";
promisers::

  "/srv/www/htdocs/cfknowledgebase"
      association => a("occurs in bundle","bundles::setup_knowledge","bundle contains promiser");
  "/srv/www/htdocs/cfknowledgebase"
      association => a("makes promise of type","promise_types::files","promises have been made by");
  "/srv/www/htdocs/cfknowledgebase"
      association => a("makes promises","promise_knowledge_cf_24","is a promise made by");
promise_types::
  "files" association => a("is employed in bundle","setup_knowledge","employs promises of type");
promises::

"promise_knowledge_cf_24"
   comment => "Make sure knowledge files are accessible to webserver";
"promise_knowledge_cf_24" association => a("is activated by class context","any","activates promises");
"promise_knowledge_cf_24" association => a("is a promise of type","files","has current exemplars");

 occurrences:
promise_knowledge_cf_24::
"promises.cf.html#promise_knowledge_cf_24"
   comment => "Make sure knowledge files are accessible to webserver",
   represents => { "any", "files" };

any::
"promises.cf.html#promise_knowledge_cf_24"
   represents => { "promise", "/srv/www/htdocs/cfknowledgebase", "files" };

setup_knowledge::
"promises.cf.html#bundle_setup_knowledge"
   represents => { "bundle reference" };

comment::
"promises.cf.html#promise_knowledge_cf_24"
   represents => { "used in promise", "promise_knowledge_cf_24" };

"Make sure knowledge files are accessible to webserver"
   representation => "literal",

   represents => { "promise_knowledge_cf_24" };
promise_knowledge_cf_24::
"Make sure knowledge files are accessible to webserver"
   representation => "literal",

   represents => { "comment" };
perms::
"promises.cf.html#promise_knowledge_cf_24"
   represents => { "used in promise", "promise_knowledge_cf_24" };

owners::
"promises.cf.html#promise_knowledge_cf_24"
   represents => { "used in promise", "promise_knowledge_cf_24" };

mode::
"promises.cf.html#promise_knowledge_cf_24"
   represents => { "used in promise", "promise_knowledge_cf_24" };

depth_search::
"promises.cf.html#promise_knowledge_cf_24"
   represents => { "used in promise", "promise_knowledge_cf_24" };

depth::
"promises.cf.html#promise_knowledge_cf_24"
   represents => { "used in promise", "promise_knowledge_cf_24" };


topics:

bundles::
  "setup_knowledge";
contexts::
  "any";
promisers::

  "/usr/local/sbin/cf-promises -r"
      association => a("occurs in bundle","bundles::setup_knowledge","bundle contains promiser");
  "/usr/local/sbin/cf-promises -r"
      association => a("makes promise of type","promise_types::commands","promises have been made by");
  "/usr/local/sbin/cf-promises -r"
      association => a("makes promises","promise_knowledge_cf_34","is a promise made by");
promise_types::
  "commands" association => a("is employed in bundle","setup_knowledge","employs promises of type");
promises::

"promise_knowledge_cf_34"
   comment => "Generate config reports";
"promise_knowledge_cf_34" association => a("is activated by class context","any","activates promises");
"promise_knowledge_cf_34" association => a("is a promise of type","commands","has current exemplars");

 occurrences:
promise_knowledge_cf_34::
"promises.cf.html#promise_knowledge_cf_34"
   comment => "Generate config reports",
   represents => { "any", "commands" };

any::
"promises.cf.html#promise_knowledge_cf_34"
   represents => { "promise", "/usr/local/sbin/cf-promises -r", "commands" };

setup_knowledge::
"promises.cf.html#bundle_setup_knowledge"
   represents => { "bundle reference" };

comment::
"promises.cf.html#promise_knowledge_cf_34"
   represents => { "used in promise", "promise_knowledge_cf_34" };

"Generate config reports"
   representation => "literal",

   represents => { "promise_knowledge_cf_34" };
promise_knowledge_cf_34::
"Generate config reports"
   representation => "literal",

   represents => { "comment" };
contain::
"promises.cf.html#promise_knowledge_cf_34"
   represents => { "used in promise", "promise_knowledge_cf_34" };

chdir::
"promises.cf.html#promise_knowledge_cf_34"
   represents => { "used in promise", "promise_knowledge_cf_34" };


topics:

bundles::
  "setup_knowledge";
contexts::
  "web_server";
promisers::

  "/usr/local/sbin/cf-know -f /srv/www/htdocs/cfknowledgebase/enterprise.cf -g"
      association => a("occurs in bundle","bundles::setup_knowledge","bundle contains promiser");
  "/usr/local/sbin/cf-know -f /srv/www/htdocs/cfknowledgebase/enterprise.cf -g"
      association => a("makes promise of type","promise_types::commands","promises have been made by");
  "/usr/local/sbin/cf-know -f /srv/www/htdocs/cfknowledgebase/enterprise.cf -g"
      association => a("makes promises","promise_knowledge_cf_41","is a promise made by");
promise_types::
  "commands" association => a("is employed in bundle","setup_knowledge","employs promises of type");
promises::

"promise_knowledge_cf_41"
   comment => "Generate knowledge associative graphs";
"promise_knowledge_cf_41" association => a("is activated by class context","web_server","activates promises");
"promise_knowledge_cf_41" association => a("is a promise of type","commands","has current exemplars");

 occurrences:
promise_knowledge_cf_41::
"promises.cf.html#promise_knowledge_cf_41"
   comment => "Generate knowledge associative graphs",
   represents => { "web_server", "commands" };

web_server::
"promises.cf.html#promise_knowledge_cf_41"
   represents => { "promise", "/usr/local/sbin/cf-know -f /srv/www/htdocs/cfknowledgebase/enterprise.cf -g", "commands" };

setup_knowledge::
"promises.cf.html#bundle_setup_knowledge"
   represents => { "bundle reference" };

comment::
"promises.cf.html#promise_knowledge_cf_41"
   represents => { "used in promise", "promise_knowledge_cf_41" };

"Generate knowledge associative graphs"
   representation => "literal",

   represents => { "promise_knowledge_cf_41" };
promise_knowledge_cf_41::
"Generate knowledge associative graphs"
   representation => "literal",

   represents => { "comment" };
}
