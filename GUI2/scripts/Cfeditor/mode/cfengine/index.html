<!doctype html>
<html>
    <head>
        <title>CodeMirror 2: CFEngine mode</title>
        <link rel="stylesheet" href="../../lib/codemirror.css">
        <script src="../../lib/codemirror.js"></script>
        <script src="cfsyntax.js"></script>
        <script src="cfengine.js"></script>
        <link rel="stylesheet" href="cfengine.css">
        <style>.CodeMirror {border-top: 1px solid #ddd; border-bottom: 1px solid #ddd;}
            .cm-completions {
                position: absolute;
                z-index: 10;
                overflow: hidden;
                -webkit-box-shadow: 2px 3px 5px rgba(0,0,0,.2);
                -moz-box-shadow: 2px 3px 5px rgba(0,0,0,.2);
                box-shadow: 2px 3px 5px rgba(0,0,0,.2);
            }
            .cm-completions select {
                background: #fafafa;
                outline: none;
                border: none;
                padding: 0;
                margin: 0;
                font-family: monospace;
            }

        </style>
        <link rel="stylesheet" href="../../css/docs.css">
    </head>
    <body>
        <h1>CodeMirror 2: CFEngine mode</h1>
        <form><textarea id="code" name="code">

            
            ##################################################################
#
# CFEngine internal services
#
# Do not edit this file. It will be maintained by CFEngine AS
#
##################################################################
##################################################################
#
# cfengine_limit_rebot_agents
#  - kill CFE processes and restart it when the process grown  
#
##################################################################

bundle agent cfengine_limit_robot_agents
{
 processes:

  linux::

   "cf-execd"
      process_count => check_execd("2"),
            comment => "Check cf-execd process if exceed the number",
             handle => "cfengine_limit_robot_agents_processes_check_cf_execd";

   "cf-monitord"
      process_count => check_monitord("1"),
            comment => "Check cf-monitord process if exceed the number",
             handle => "cfengine_limit_robot_agents_processes_check_cf_monitord";
   
   #
   # Do not do this for cf-hub because cf-hub may have unlimited processes
   #

  something_wrong_execd::

   "cf-execd"
            signals => { "term", "kill" },
      restart_class => "restart_execd",
            comment => "When cf-execd comes undone then kill all and restart the process",
             handle => "cfengine_limit_robot_agents_processes_kill_cf_execd";

  something_wrong_monitord::

   "cf-monitord"
            signals => { "term", "kill" },
      restart_class => "restart_monitord",
            comment => "When cf-monitord comes undone then kill all and restart the process",
             handle => "cfengine_limit_robot_agents_processes_kill_cf_monitord";

#

 commands:

  restart_execd::

   "$(sys.cf_execd)"
      comment => "Restart cf-execd process",
       handle => "cfengine_limit_robot_agents_commands_restart_cf_execd";

  restart_monitord::

   "$(sys.cf_monitord)"
      comment => "Restart cf-monitord process",
       handle => "cfengine_limit_robot_agents_commands_restart_cf_monitord";

}

#

body process_count check_execd(n)
{
match_range => "0,$(n)";
out_of_range_define => {"something_wrong_execd"};
}

body process_count check_monitord(n)
{
match_range => "0,$(n)";
out_of_range_define => {"something_wrong_monitord"};
}

##################################################################
#
# cfengine_update_folders
#  - create temp directories to make CFE silent (self-upgrading)  
#
##################################################################

bundle agent cfengine_update_folders
{
 vars:

  "dirs" slist => {
                   "ubuntu_10_i686",
                   "ubuntu_10_x86_64",
                   "ubuntu_11_i686",
                   "ubuntu_11_x86_64",
                   "centos_5_i686",
                   "centos_5_x86_64",
                   "redhat_5_i686",
                   "redhat_5_x86_64",
                   "redhat_6_i686",
                   "redhat_6_x86_64",
                   "SuSE_11_i686",
                   "SuSE_11_x86_64",
                   "debian_5_i686",
                   "debian_5_x86_64",
                   "debian_6_i686",
                   "debian_6_x86_64",
                   "debian_wheezy_i686",
                   "debian_wheeyz_x86_64"
                  },
       comment => "Define a list for $(sys.flavour)_$(sys.arch) directories",
        handle => "cfengine_update_folders_vars_dirs";

#

 files:

  "$(sys.workdir)/master_software_updates/$(dirs)/."
     comment => "Prepare binary upgrade folders for all distributions in our environment",
      handle => "cfengine_update_folders_files_create_dirs",
      create => "true";

}

##################################################################
#
# cfengine_correct_cftwin
#  - create cf-twin for self-upgrading purpose
#
##################################################################

bundle agent cfengine_correct_cftwin
{
 files:

  !windows::

   "/var/cfengine/lib-twin"
           comment => "Correct lib-twin to be the same as lib, in case of dependency upgrade. This effect cf-twin's behaviour",
            handle => "cfengine_correct_cftwin_files_libtwin",
             perms => m("644"),
         copy_from => local_cp("/var/cfengine/lib"),
      depth_search => recurse("inf");

   "/var/cfengine/bin/cf-twin"
        comment => "Correct cf-twin to be the same as cf-agent, in case of dependency upgrade",
         handle => "cfengine_correct_cftwin_files_cftwin",
          perms => m("755"),
      copy_from => local_cp("/var/cfengine/bin/cf-agent");

}
            
            
            </textarea></form>
        <script>
            //Change tracking

               
            (function () {
                // Minimal event-handling wrapper.
                function stopEvent() {
                    if (this.preventDefault) {this.preventDefault(); this.stopPropagation();}
                    else {this.returnValue = false; this.cancelBubble = true;}
                }
                function addStop(event) {
                    if (!event.stop) event.stop = stopEvent;
                    return event;
                }
                function connect(node, type, handler) {
                    function wrapHandler(event) {handler(addStop(event || window.event));}
                    if (typeof node.addEventListener == "function")
                        node.addEventListener(type, wrapHandler, false);
                    else
                        node.attachEvent("on" + type, wrapHandler);
                }

                function forEach(arr, f) {
                    for (var i = 0, e = arr.length; i < e; ++i) f(arr[i]);
                }

                              

                startComplete= function() {
                    // We want a single cursor position.
                
                    if (editor.somethingSelected()) return;
                                    
                  
                    var cur = editor.getCursor();               
                    line = editor.getLine(cur.line);
                    var to = {'line':cur.line,'ch':cur.ch-1};
                    
                    var textBefore = editor.getRange(to,cur);
                    
                    var token = editor.getTokenAt(cur);
                    var state = editor.getStateAfter(cur.line); 
                    var content = token.state.content;
                    
                    var text = textBefore;
                    var added = false;
                    if (/(?:^|[\s\)\}\"])$/.test(text)) { added = true;}  
                    
                    var expected = [];
                    if (!added) 
                        expected = token.state.expected;
                    else 
                        expected = state.expected;
                    
                    var completions = getCompletions(expected);
                    var match=[];
                    
                    
                    
                    for (var i = 0; i < completions.length; i++) {
                        var str = completions[i];
                        if (added === false ) {
                            if (str.indexOf(content) != 0) continue; 
                        }
                        match.push(str);
                    }
                    
                    match.sort();
                
                   
                    if (!match.length) return;
                 
                 
                    function insert(str) {
                        if (added===true) str = textBefore + str; 
                        editor.replaceRange(str, {line: cur.line, ch: token.start}, {line: cur.line, ch: token.end});
                        return true;
                    }
                    // When there is only one completion, use it directly.
                    if (match.length == 1) {insert(match[0]); return true;}

                    // Build the select widget
                    var complete = document.createElement("div");
                    complete.className = "cm-completions";
                    var sel = complete.appendChild(document.createElement("select"));
                    sel.multiple = false;
                    for (var i = 0; i < match.length; ++i) {
                        var opt = sel.appendChild(document.createElement("option"));
                        opt.appendChild(document.createTextNode(match[i]));
                    }
                    sel.firstChild.selected = true;
                    sel.size = Math.min(10, match.length);
                    var pos = editor.cursorCoords();
                    complete.style.left = pos.x + "px";
                    complete.style.top = pos.yBot + "px";
                    document.body.appendChild(complete);
                    // Hack to hide the scrollbar.
                    if (completions.length <= 10)
                        complete.style.width = (sel.clientWidth - 1) + "px";

                    var done = false;
                    function close() {
                        if (done) return;
                        done = true;
                        complete.parentNode.removeChild(complete);
                    }
                    function pick() {
                        insert(sel.options[sel.selectedIndex].value);
                        close();
                        setTimeout(function(){editor.focus();}, 50);
                    }
                    connect(sel, "blur", close);
                    connect(sel, "keydown", function(event) {
                        var code = event.keyCode;
                        // Enter and space
                        if (code == 13 || code == 32) {event.stop(); pick();}
                        // Escape
                        else if (code == 27) {event.stop(); close(); editor.focus();}
                        else if (code != 38 && code != 40) {close(); editor.focus(); setTimeout(startComplete, 50);}
                    });
                    connect(sel, "dblclick", pick);

                    sel.focus();
                    // Opera sometimes ignores focusing a freshly created node
                    if (window.opera) setTimeout(function(){if (!done) sel.focus();}, 100);
                    return true;
                    
                }              

                function getCompletions(expected) {
                    if (expected == null)
                        return [];
                    else if (expected.pcre_range)
                        return expected.pcre_range.indexOf("|") == -1 ? []
                    : map(function(x){return "\"" + x + "\"";}, expected.pcre_range.split("|"));
                    else
                        return propertiesOf(expected);
                                    
                }
                                
                function propertiesOf(obj) {
                    var result = [];
                    for (var n in obj)
                        if (obj.hasOwnProperty(n)) result.push(n);
                    return result;
                }
                                
                function map(func, arr) {
                    var res = [], len = arr.length;
                    for (var i = 0; i < len; i++)
                        res.push(func(arr[i]));
                    return res;
                }
                             
               
               

                var editor = CodeMirror.fromTextArea(document.getElementById("code"), {
                    onKeyEvent: function(i, e) {
                        // Hook into ctrl-space
                        if (e.keyCode == 32 && (e.ctrlKey || e.metaKey) && !e.altKey) {
                            e.stop();
                            return startComplete();
                        }
                    }});
 

            })();

            
        </script>

        <p><strong>MIME types defined:</strong> <code>text/x-diff</code>.</p>

    </body>
</html>
