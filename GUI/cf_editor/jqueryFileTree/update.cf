#########################################################
#
# a pre-defined template, update.cf
#
#########################################################

#########################################################
# Update definitions
#########################################################

bundle agent u_def
{
vars:

 "policy_server_file" string => translatepath("$(sys.workdir)/policy_server.dat"),
                     comment => "Path to file containing address to policy server";

 "policy_server"      string => readfile("$(policy_server_file)", 40),
                     comment => "IP address to locate your policy host.";

}


#########################################################
# Cfengine binary update
#########################################################

bundle agent update_bins
{
vars:

 "cf_components"       slist => { "cf-key", "cf-know", 
                                  "cf-monitord", "cf-promises", "cf-report", 
                                  "cf-runagent", "cf-serverd" };

 "master_software_location"  string => "/var/cfengine/master_software_updates",
                            comment => "The Cfengine binary updates directory on the policy host";

 "local_software_dir"        string => translatepath("$(sys.workdir)/software_updates/$(sys.flavour)_$(pkgarch)"),
                            comment => "Local directory containing binary updates for this host";

 windows::

  "stop_signal"              string => "kill";

 !windows::

  "stop_signal"              string => "term";

 solarisx86|solaris::
   "novapkg"                 string => "CFEcfengine-nova";
 
 !(solarisx86|solaris)::
   "novapkg"                 string => "cfengine-nova";

 solaris::
   "pkgarch"                 string => "sparc";

 !solaris::
   "pkgarch"                 string => "$(sys.arch)";

#########################################################

processes:

bin_newpkg::

 "$(cf_components)" signals => { "$(stop_signal)" };

bin_newpkg.!windows::

  "cf-execd"  signals => { "$(stop_signal)" };

#########################################################

packages:

 # update packages after all Cfengine have been killed

bin_newpkg::

  "$(novapkg)"
    package_policy           => "update",
    package_select           => ">=",                 # picks the newest Nova available
    package_architectures    => { "$(pkgarch)" },
    package_version          => "1.0.0",              # at least Nova version 1.0.0
    package_method           => u_generic( "$(local_software_dir)" ),
    classes                  => u_if_else("bin_update_success", "bin_update_fail");

#########################################################

files:

  "$(local_software_dir)"
        comment => "Copy binary updates from master source on policy server",
       copy_from => u_rcp("$(master_software_location)/$(sys.flavour)_$(pkgarch)","$(u_def.policy_server)"),
    depth_search => u_recurse("1"),  # Nova updates should be in root dir
      depends_on => { "grant_access_datafiles" },
          action => u_immediate,
         classes => u_if_repaired("bin_newpkg");

#########################################################

services:

bin_newpkg.windows::
  "CfengineNovaExec"
  service_policy => "stop",
         comment => "Stop the executor windows service before updating Cfengine";

#########################################################

reports:

 bin_newpkg::
  "An update for Cfengine binaries is downloaded, installing...";

 bin_update_success::
  "Successfully installed Cfengine binaries";

 bin_update_fail::
  "Failed updating Cfengine binaries, should revert to old version";

}


#########################################################
# Cfengine policy update
#########################################################

bundle agent update
{
vars:

 "inputs_dir"         string => translatepath("$(sys.workdir)/inputs"),
                     comment => "Directory containing Cfengine policies";

 "bin_dir"            string => translatepath("$(sys.workdir)/bin"),
                     comment => "Directory containing Cfengine robot agents";


 "ppkeys_file"        string => translatepath("$(sys.workdir)/ppkeys/localhost.pub"),
                     comment => "Path to public key file";

 "file_check"         string => translatepath("$(inputs_dir)/promises.cf"),
                     comment => "Path to a policy file";


 "master_location"    string => "/var/cfengine/masterfiles",
                     comment => "The master cfengine policy directory on the policy host";

#########################################################

classes:

  "have_ppkeys" expression => fileexists("$(ppkeys_file)");

  "policy_host_update_cf" or => {
                                 classmatch(canonify("ipv4_$(u_def.policy_server)")),
                                 classmatch(canonify("$(u_def.policy_server)"))
                                },
                     comment => "Define the ip identity of the policy source host";

  "files_ok" expression => fileexists("$(file_check)");

#########################################################

processes:

files_ok::

  "cf-serverd"  restart_class => "start_server";
  "cf-monitord" restart_class => "start_monitor";

files_ok.!windows::

  "cf-execd"    restart_class => "start_exec";

#########################################################

commands:

 start_server::

   "$(sys.cf_serverd)"
   action => u_ifwin_bg;

 start_monitor::

   "$(sys.cf_monitord)"
   action => u_ifwin_bg;


 !windows.start_exec::

   "$(sys.cf_execd)";

 !have_ppkeys::

    "$(sys.cf_key)",
          comment => "Generate cfengine encryption keys if necessary";

#########################################################

services:

 files_ok.windows::
 
  "CfengineNovaExec"
 
     service_policy => "start",
     service_method => u_bootstart,
            comment => "Start the executor windows service now and at boot time";

#########################################################

files:

  "$(inputs_dir)"

         comment => "Copy policy updates from master source on policy server",
       copy_from => u_rcp("$(master_location)","$(u_def.policy_server)"),
    depth_search => u_recurse("inf"),
    file_select  => u_input_files,
      depends_on => { "grant_access_policy" },
          action => u_immediate;

!windows::

  "$(sys.workdir)/bin"

         comment => "Make sure cfengine binaries have right file permissions",
           perms => u_m("755"),
    depth_search => u_recurse_basedir("inf"),
          action => u_immediate;

  "$(sys.workdir)/lib"

         comment => "Make sure cfengine libraries have right file permissions",
           perms => u_m("755"),
    depth_search => u_recurse_basedir("inf"),
          action => u_immediate;

  "/usr/local/sbin"

         comment => "Ensure cfengine binaries were copied to /usr/local/sbin",
           perms => u_m("755"),
       copy_from => u_cp("$(sys.workdir)/bin"),
     file_select => u_cf3_files,
    depth_search => u_recurse("1"),
          action => u_immediate;

policy_host_update_cf::

  "$(sys.workdir)/masterfiles/."

       comment => "Make sure masterfiles folder has right file permissions",
         perms => u_m("644"),
  depth_search => u_recurse_basedir("inf"),
        action => u_immediate;

}

#########################################################
# Self-contained bodies from the lib to avoid dependencies
#########################################################

body perms u_m(p)
{
mode  => "$(p)";
}

#########################################################

body file_select u_cf3_files
{
 leaf_name => { "cf-.*" };

 file_result => "leaf_name";
}

#########################################################

body file_select u_input_files
{
 leaf_name => { ".*.cf",".*.dat" };

 file_result => "leaf_name";
}

#########################################################

body copy_from u_rcp(from,server)
{
 source      => "$(from)";
 compare     => "digest";
 trustkey    => "true";

!policy_host_update_cf::

 servers => { "$(server)" };
}

#########################################################

body copy_from u_cp(from)
{
source      => "$(from)";
compare     => "digest";
}

#########################################################

body action u_immediate
{
ifelapsed => "0";
}

#########################################################

body depth_search u_recurse(d)

{
depth => "$(d)";
}

#########################################################

body depth_search u_recurse_basedir(d)

{
include_basedir => "true";
depth => "$(d)";
}

#########################################################

body classes u_if_repaired(x)
{
promise_repaired => { "$(x)" };
}

#########################################################

body classes u_if_else(yes,no)
{
promise_kept     => { "$(yes)" };
promise_repaired => { "$(yes)" };
repair_failed    => { "$(no)" };
repair_denied    => { "$(no)" };
repair_timeout   => { "$(no)" };
}

#########################################################

body action u_ifwin_bg
{
windows::
 background => "true";
}

#########################################################

body service_method u_bootstart
{
service_autostart_policy => "boot_time";
}

#########################################################

body package_method u_generic(repo)

{

debian::

 package_changes => "individual";
 package_list_command => "/usr/bin/dpkg -l";

 package_list_name_regex    => "ii\s+([^\s]+).*";
 package_list_version_regex => "ii\s+[^\s]+\s+([^\s]+).*";

 package_installed_regex => ".*"; # all reported are installed

 package_file_repositories => { "$(repo)" };

 package_name_convention => "$(name)_$(version)_$(arch).deb";

 package_add_command => "/usr/bin/dpkg --install";
 package_delete_command => "/usr/bin/dpkg --purge";
 package_update_command =>  "/usr/bin/dpkg --install";


redhat|SuSE::

 package_changes => "individual";

 package_list_command => "/bin/rpm -qa --queryformat \"i | repos | %{name} | %{version}-%{release} | %{arch}\n\"";


 package_list_name_regex    => "[^|]+\|[^|]+\|\s+([^\s|]+).*";
 package_list_version_regex => "[^|]+\|[^|]+\|[^|]+\|\s+([^\s|]+).*";

 package_installed_regex => "i.*";

 package_file_repositories => { "$(repo)" };

 package_name_convention => "$(name)-$(version).$(arch).rpm";

 package_add_command => "/bin/rpm -ivh ";
 package_delete_command => "/bin/rpm -e --nodeps";
 package_verify_command => "/bin/rpm -V";
 package_update_command => "/bin/rpm -Uvh ";
 package_noverify_regex => ".*[^\s].*";


windows::

 package_changes => "individual";
 package_file_repositories => { "$(repo)" };

 package_installed_regex => ".*";
 
 package_name_convention => "$(name)-$(version)-$(arch).msi";

 package_add_command => "\"$(sys.winsysdir)\msiexec.exe\" /qn /i";
 package_update_command => "\"$(sys.winsysdir)\msiexec.exe\" /qn /i";
 package_delete_command => "\"$(sys.winsysdir)\msiexec.exe\" /qn /x";


freebsd::

 package_changes => "individual";

 package_list_command => "/usr/sbin/pkg_info";

 package_list_name_regex    => "^(\S+)-(\d+\.?)+";
 package_list_version_regex => "^\S+-((\d+\.?)+\_\d)";

 package_file_repositories => { "$(repo)" };

 package_installed_regex => ".*";

 package_name_convention => "$(name)-$(version).tbz";
 package_delete_convention => "$(name)-$(version)";

 package_add_command => "/usr/sbin/pkg_add";
 package_delete_command => "/usr/sbin/pkg_delete";


solarisx86|solaris::
 
 package_changes => "individual";
 package_list_command => "/usr/bin/pkginfo -l";
 package_multiline_start    =>  "\s*PKGINST:\s+[^\s]+";
 package_list_name_regex    => "\s*PKGINST:\s+([^\s]+)";
 package_list_version_regex => "\s*VERSION:\s+([^\s]+)";
 
 package_file_repositories => { "$(repo)" };
 
 package_installed_regex => "\s*STATUS:\s*(completely|partially)\s+installed.*";
 package_name_convention => "$(name)-$(version)-$(arch).pkg";
 package_delete_convention => "$(name)";

 # Cfengine appends path to package and package name below, respectively
 package_add_command => "/bin/sh $(repo)/add_scr $(repo)/admin_file";
 package_delete_command => "/usr/sbin/pkgrm -n -a $(repo)/admin_file";

}
