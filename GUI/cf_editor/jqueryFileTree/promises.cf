#########################################################################
#
#   promises.cf - Basic Enterprise Policy
#
#########################################################################

body common control

{
 bundlesequence => {
                   "main"
                   };

         inputs => {
                   "cfengine_stdlib.cf",
                   "process_matching.cf",
                   "linux_harden_method.cf",
                   "scheduling.cf",
                   "file_change.cf",
                   "file_security.cf",
                   "software_local.cf",
                   "win_registry.cf",
                   "win_services.cf",
                   "win_emergency.cf",
                   "active_directory.cf",
                   "app_baseline.cf",
                   "software_policysrv.cf",
                   "generate_reports.cf",
                   "webserver.cf",
                   "knowledge.cf"
                   };

 host_licenses_paid => "1";

 version => "Promises.cf 1.1.0";
}

#########################################################################

bundle agent main
{							 
 methods:

  any::
   "any" usebundle => def;
   "any" usebundle => generate_reports;
   "any" usebundle => process_matching;
#   "any" usebundle => scheduling;
#   "any" usebundle => change_management;
#   "any" usebundle => file_security;
#   "any" usebundle => active_directory;
   
  windows::
#   "any" usebundle => software_local;
#   "any" usebundle => app_baseline;
#   "any" usebundle => win_services;
#   "any" usebundle => win_registry;
#   "any" usebundle => win_emergency;

  !windows::
#   "any" usebundle => linux_harden_methods;
#   "any" usebundle => garbage_collection;

  policy_host::
   "any" usebundle => software_policysrv;
   "any" usebundle => web_server("on");
   "any" usebundle => setup_knowledge;

}

#########################################################################

bundle common def
{
vars:

  "policy_server_file" string => translatepath("$(sys.workdir)/policy_server.dat"),
                      comment => "Path to file containing address to policy server";


  "policy_server"      string => readfile("$(policy_server_file)", 40),
                      comment => "IP address to locate your policy host.";


  # Begin change # Your domain name, for use in access control

     "domain" string => "cfengine.com";

  # List here the IP masks that we grant access to on the server

    "acl" slist => { 
                   "$(def.policy_server)/16"  # Assume /16 LAN clients to start with

                #  "2001:700:700:3.*", 
                #  "217.77.34.18", 
                #  "217.77.34.19",
                   }; 

  # End change #

  "dir_masterfiles" string => translatepath("$(sys.workdir)/masterfiles");
  "dir_reports"     string => translatepath("$(sys.workdir)/reports");
  "dir_software"    string => translatepath("$(sys.workdir)/master_software_updates");

 policy_host::

  "doc_root_file" string => translatepath("$(sys.workdir)/document_root.dat"),
                 comment => "Path to file containing knowledge base document root to policy server";

  "doc_root" string => readfile("$(doc_root_file)",40),
            comment => "Read the knowledge base document root for the web server";

classes:

   "policy_host" or => { 
                       classmatch(canonify("ipv4_$(def.policy_server)")),
                       classmatch(canonify("$(def.policy_server)"))
                       },
            comment => "Define the ip identity of the policy source host";

}

#########################################################################

body agent control

{
# Global default for time that must elapse before promise will be rechecked.
# Don't keep any promises.

 any::

 # This should normally be set to an interval like 1-5 mins
 # We set it to zero initially to avoid confusion.

  ifelapsed => "0";

 # Do not send IP/name during server connection if address resolution is broken.
 # Comment it out if you do NOT have a problem with DNS

  skipidentify => "true";

 # Environment variables based on Distro

 debian::
  environment => { 
                  "DEBIAN_FRONTEND=noninteractive",
                  "GDFONTPATH=/var/cfengine/fonts" 
                 };

 redhat|SuSE::
  environment => {
                  "GDFONTPATH=/var/cfengine/fonts"
                 };
}

#########################################################
# This part is for cf-serverd
#
# General IP access policy for the connection protocol
#  i.e. access to the server itself.
# Access to specific files must be granted in addition.
#########################################################

body server control 

{
denybadclocks         => "false";
allowconnects         => { "127.0.0.1" , "::1", @(def.acl) };
allowallconnects      => { "127.0.0.1" , "::1", @(def.acl) };
trustkeysfrom         => { "127.0.0.1" , "::1", @(def.acl) };

skipverify            => { ".*$(def.domain)", "127.0.0.1" , "::1", @(def.acl) };

allowusers            => { "root" };

# Uncomment the line below to allow remote users to run 
# cf-agent through cf-runagent

# cfruncommand          => "$(sys.cf_agent)";
}

#########################################################

bundle server access_rules()
{
access:

  "$(def.dir_masterfiles)"

     handle => "grant_access_policy",
    comment => "Grant access to the policy updates",
    admit   => { ".*$(def.domain)", @(def.acl) };

windows::
  "$(def.dir_reports)"

     handle => "grant_access_reports_windows",
    comment => "Grant access to the windows client reports",
    maproot => { "$(def.policy_server)" },
    admit   => { ".*$(def.domain)", @(def.acl) };

# Uncomment the promise below to allow cf-runagent to
# access cf-agent on Windows machines
#	
#  "c:\program files\cfengine\bin\cf-agent.exe"
#
#    handle => "grant_access_policy_agent",
#    comment => "Grant access to the agent (for cf-runagent)",
#    admit   => { ".*$(def.domain)", @(def.acl) };	

!windows::
  "$(def.dir_reports)"

     handle => "grant_access_reports",
    comment => "Grant access to the client reports",
    admit   => { ".*$(def.domain)", @(def.acl) };

any::
  "$(def.dir_software)"

     handle => "grant_access_datafiles",
    comment => "Grant access to software updates",
    admit   => { ".*$(def.domain)", @(def.acl) };
	
roles:

# Use roles to allow specific remote cf-runagent users to
# define certain soft-classes when running cf-agent on this host
#  "emergency"  authorize => { "root" };	
	
}

#########################################################
# This part is for cf-execd
#
# These body settings determine the behaviour of cf-execd, 
# including scheduling times and output capture to 
# $(sys.workdir)/outputs and relay via email.
#########################################################

body executor control

{
 any::

  splaytime  => "1";
  mailto     => "cfengine@example.org";
  mailfrom   => "cfengine@$(sys.host).example.org";
  smtpserver => "localhost";

# Default:
#
# schedule => { "Min00", "Min05", "Min10", "Min15", "Min20", 
#               "Min25", "Min30", "Min35", "Min40", "Min45",
#               "Min50", "Min55" };

# The full path and command to the executable run by default (overriding builtin).

exec_command => "$(sys.cf_twin) -f failsafe.cf && $(sys.cf_agent)";
}

#########################################################

body reporter control

{
 any::

  reports => { 
             "all" 
             };

  build_directory => "$(sys.workdir)/reports";
  report_output   => "html";
  style_sheet => "/cf_enterprise.css";

 policy_host.SuSE::

  aggregation_point => "/srv/www/htdocs/reports";

 policy_host.redhat::

  aggregation_point => "/var/www/html/reports";

 policy_host.debian::

  aggregation_point => "/var/www/reports";

}

#########################################################

body runagent control

{
# A list of hosts to contact when using cf-runagent

 hosts => { "127.0.0.1" };

# , "myhost.example.com:5308", ...
}

#########################################################

body monitor control

{
forgetrate => "0.7";
histograms => "true";
# tcpdump => "false";
# tcpdumpcommand => "/usr/sbin/tcpdump -t -n -v";
}
